Операционная система должна включать ==автоматизированные средства изоляции приложений, чувствительных к сетевым атакам==. 

___

chroot показываем

Продемонстрировать наличие соответствующих возможностей

Демонстрация работы автоматизированного средства изоляции приложений, чувствительных к сетевым атакам (например ping от root).

strace -o ping.log ping -c 3 127.0.0.1

less ping.log | grep chroot

cat ping.log | grep chroot  
chroot("/var/resolv")

Дополнительно выполнить следующую команду, чтобы показать пакеты, которые используют update_chrooted для подготовки своих чрутов. (или чрута /var/resolv)

apt-cache whatdepends chrooted


`firejail` - Firejail представляет собой готовый для использования инструмент запуска приложений внутри изолированной среды. Для создания изолированных окружений firejail использует такие механизмы ядра Linux, как namespaces, cgroups и seccomp https://vaiti.io/utilita-firejail-gotovaya-pesochnicza-dlya-vashih-prilozhenij/

`bubblewrap` - Аналогично **firejail** для создания изолированных окружений. **bubblewrap** использует такие механизмы ядра Linux, как namespaces и seccomp https://vaiti.io/bubblewrap-gibkij-instrument-sozdaniya-pesochnicz/

`fail2ban` присутствует  https://www.altlinux.org/Fail2ban , но это защита только от брутфорса

Также, в репозитории есть великие и ужасные `Docker` и `Podman (+ Podsec)`  - это у нас более мощная изоляция, её ещё контейнеризацией называют)

![[Pasted image 20250606164004.png]]

Ну, чисто технически, есть фаерволл, но вот слово ИЗОЛЯЦИЯ меня смущает

## Linux namespaces

==!!!На практике голые namespace использовать КРАЙНЕ сложно в связи с объемностью современных программ!!!==

Когда процессы в Linux имеют доступ ко всем системным ресурсам, это может создавать проблемы. Хорошо бы их отделить и друг от друга, и от тех частей системы, которые им все равно не нужны. Вот тут-то и пригодится инструмент namespace.  
  
Он создает изолированные «песочницы» для процессов, каждая из которых функционирует независимо от других. В результате каждая группа процессов может иметь собственное представление о системных ресурсах.  
  
В современных версиях ядра Linux, таких как 6.12.1, существует восемь типов «песочниц», каждая из которых играет свою роль в изоляции ресурсов и безопасности системы. Чтобы изолировать процессы с помощью Linux namespace, необходимо использовать команду unshare или другие утилиты, такие как ip для сетевой изоляции. Основная идея — это создание нового пространства для процессов, которые должны работать независимо друг от друга. Итак, перейдем к пошаговой инструкции.  
  
### PID namespace

Это пространство отвечает за изоляцию дерева процессов. Другими словами, каждый процесс видит только то, что происходит внутри его «песочницы». А вот доступа к происходящему на уровне хоста у него нет. Создадим такой процесс.  
  
```bash
# Создаем новый PID namespace и запускаем bash в нем
sudo unshare --pid --fork --mount-proc /bin/bash
```

В этом случае процессы, запущенные внутри пространства, будут изолированы и не смогут вмешиваться в работу других процессов на хосте. Команды вроде ps aux покажут только процессы, запущенные в нем.  
  
```bash
# Проверяем список процессов в новом namespace
ps aux
```

В результате увидим, что у процесса будет собственный список других процессов в новом пространстве, но не на хосте.  
  
### NET namespace

С помощью NET namespace можно создать изолированную сеть для процесса. Это полезно для создания контейнеров, каждый из которых будет иметь собственный сетевой интерфейс, IP-адреса и маршруты. Пример создания нового сетевого пространства:  
  
```bash
# Создаем новый сетевой namespace
sudo ip netns add mynetns
# Запускаем bash в новом namespace
sudo ip netns exec mynetns bash
# Проверяем сетевые интерфейсы в новом namespace
ip link show
```

В новом пространстве будет виден только локальный интерфейс. Сетевые интерфейсы, настроенные на хосте, не будут доступны.  
  
Если у вас есть несколько приложений, которые должны работать с независимыми сетями, вы можете использовать NET namespace для создания изолированных сетевых пространств, например, для тестирования приложений с разными IP-адресами.  

Пример: запускаем два приложения, каждое в своем сетевом пространстве, чтобы они не могли взаимодействовать друг с другом:  
  
```bash
# Создаем два разных сетевых namespace
sudo ip netns add app1_net
sudo ip netns add app2_net
# Запускаем приложение в первом namespace
sudo ip netns exec app1_net /bin/bash
# Запускаем приложение во втором namespace
sudo ip netns exec app2_net /bin/bash
```

Каждое приложение будет работать в своей изолированной сети. Это предотвращает конфликт между сетевыми интерфейсами.  
  
### MNT namespace
  
MNT namespace позволяет изолировать друг от друга файловые системы, создавая уникальные точки монтирования для каждого процесса. Пример:  
  
```bash
# Создаем новый MNT namespace
sudo unshare --mount /bin/bash
# Монтируем файловую систему в новом namespace
mount -t tmpfs tmpfs /mnt
# Проверяем точки монтирования
mount | grep /mnt
```

После выполнения этих команд появится отдельная точка монтирования, которая не будет видна процессам на уровне хоста.  

### UTS namespace
 
UTS namespace позволяет изолировать имя хоста и домен. Это полезно, когда нужно, чтобы процессы в изолированном пространстве имели разные имена хоста. Пример:  
 
```bash
# Создаем новый UTS namespace
sudo unshare -u /bin/bash
# Меняем имя хоста
hostname newname
# Проверяем имя хоста
hostname
```

В этом случае имя хоста будет изменено только в пределах пространства, не затрагивая имя хоста на уровне всей системы.  
  
### IPC namespace

Используется для изоляции механизмов межпроцессного взаимодействия, таких как очереди сообщений, семафоры и общая память. Процессы внутри одного IPC namespace не могут взаимодействовать с процессами в других пространствах.  
  
```bash
# Создаем новый IPC namespace
sudo unshare --ipc /bin/bash
# Проверяем текущие IPC-ресурсы
ipcs
# Попробуем создать очереди сообщений (это будет ограничено только для процессов в новом IPC namespace)
msgctl(IPC_PRIVATE, IPC_CREAT, 0666)
```

Это помогает изолировать различные компоненты системы или контейнеров, ограничивая их доступ к общим ресурсам.  
  
### USER namespace

Позволяет изолировать идентификаторы пользователей и групп (UID/GID). Это дает возможность создавать контейнеры, где процессы работают с различными правами, не затрагивая хост-систему. Такой подход полезен для повышения безопасности, так как контейнеры могут иметь собственные UID и GID, даже если они принадлежат той же системе. Создадим новый USER namespace:  
  
```bash
# Создаем новый USER namespace с маппингом UID и GID
sudo unshare --user --map-root-user /bin/bash
# Проверяем UID и GID в новом namespace
id
```

  
### CGROUP namespace

Используется для изоляции виртуальной файловой системы cgroup, которая управляет выделением ресурсов (например, CPU, память и сеть) для групп процессов. Это важно для контроля над ресурсами, особенно в контейнерных средах или для разделения нагрузки междеу различными процессами.  
  
```bash
# Создаем новый cgroup для ограничения памяти
sudo cgcreate -g memory:/mygroup
# Ограничиваем память для группы процессов
echo 100M > /sys/fs/cgroup/memory/mygroup/memory.limit_in_bytes
# Запускаем процесс в этом cgroup
sudo cgexec -g memory:mygroup /bin/bash
# Проверяем, что ограничения памяти применяются
cat /sys/fs/cgroup/memory/mygroup/memory.limit_in_bytes
```
  
Этот пример показывает, как ограничить память для группы процессов с использованием cgroup.  

### Time namespace

Time namespace используется для изоляции временных параметров, таких как системное время или настройки временной зоны. Процессы внутри одного Time namespace могут иметь собственное время, не влияя на время хостовой системы. Это особенно полезно для тестирования приложений или работы с контейнерами, требующими отдельного временного окружения.  

```bash
# Создаем новый Time namespace  
sudo unshare --time /bin/bash  
# Проверяем текущее время  
date  
# Изменяем время в новом namespace  
date --set="2025-01-01 00:00:00"  
# Убедимся, что изменения касаются только текущего namespace  
date
```

Time namespace помогает в следующих сценариях:  
- Эмулирование будущих или прошлых дат для тестирования приложений.
- Настройка временных зон для различных контейнеров.
- Предотвращение влияния изменений системного времени на хостовую систему.

Изоляция процессов позволяет не только минимизировать риски, связанные с эскалацией привилегий. Благодаря ей также можно повысить эффективность управления ресурсами, выделяя их конкретным процессам или приложениям, не влияя на систему в целом. Изоляция, как правило, получается достаточно гибкой, поэтому ее удобно применять в контейнерных средах и приложениях с микросервисной архитектурой.