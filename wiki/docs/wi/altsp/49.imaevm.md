Подсистема контроля целостности операционной системы должна поддерживать технологии IMA и EVM. 

___

https://www.altlinux.org/IMA_EVM
[[ЛКНВ.11100-01 99 03 Руководство по комплексу средств защиты.pdf]], стр 122-129

::: tip
Если head -n1 /sys/kernel/security/evm 2>/dev/null выводит 1, значит EVM включен.

su-
[ ! -f /sys/kernel/security/ima/capability ] &&
[ "$(< /sys/kernel/security/evm)" != 1 ] || integrity-remover


улики:

1. наличие ima_appraise=enforce в /proc/cmdline (в рантайме) и в /etc/sysconfig/grub2 (в конфиге);
2. наличие в /etc/initrd.mk фичи integrity (самая главная улика, но при условии, что make-initrd запускался и система действительно загружена с модифицированным /boot/initrd.img;
3. это можно проверить по сообщениям, которые пишет initrd в консоль (если успеть их прочитать);
4. наличие политики в /sys/kernel/security/ima/policy (кроме неё необходимо также ima_appraise=enforce в /proc/cmdline);
5. наличие сертификата /etc/x509_ima.der (слабая улика, он может не использоваться, если не попал в /boot/initrd.img);
5. наличие подписей на некоторых (так ведь?) бинарных файлах (проверяется командой getfattr или ima_inspect); (вот интересный вопрос, а как квалифицировать ситуацию, когда есть и подписанные, и не подписанные файлы?);
6. попытка запустить модифицированный бинарный файл (ELF) завершается ошибкой с соответствующей записью в журнале аудита;
7. не исключено, что при манипуляциях с _ima keyring ядро пишет сообщения в тот же журнал аудита: я это не проверял, но если это так, попытки включить IMA можно нагрепать в /var/log/audit.log

:::

::: tip
После многочасовых рукопашных мучений удалось добиться того, что в /sys/kernel/security/evm лежит 1, т.е. EVM вроде как стартует при загрузке. При этом в stage1 "moving filesystem [/run]... [FAILED]", всегда фейлится integalert.service, по ходу много всяких ошибок нехороших, стоит ли о них писать... Например, альтовый слак-way:
```
# rpm -qf /etc/keys/*
file /etc/keys/evm-key.blob is not owned by any package
file /etc/keys/kmk-user.blob is not owned by any package
file /etc/keys/x509_evm.der is not owned by any package
file /etc/keys/x509_ima.der is not owned by any package
```
Данный каталог надо удалять перед включением IMA/EVM, чтобы пройти дальше, т.к. sha1 уже всё равно не поддерживаются и симлинк создаётся в противоположную сторону. Значение "yes" в конфиге /etc/integrity/config работать не будет, т.к. в коде проверяется 0x*. Видимо тут верное значение 0x80000001, но на сам факт включения оно никак не влияет, опцию evm=enforce надо добавлять руками в конфиг grub. FEATURES = integrity -- плохая практика перезаписывать все фичи одной строкой, тут видимо нужно +=. Код в Сизифе ушёл вперёд, но код в Альт СП точно нерабочий. Проверялся ли IMA/EVM в новом образе 10.2.1? Судя по инструкции к этому образу, по крайней мере, в части EVM он точно нерабочий.
:::

1) Изменить параметры монтирования файловой системы. Для этого следует выставить параметр `iversion` на всех записях в файле `/etc/fstab` относящихся к местам, где могут быть исполняемые файлы

```bash
vim /etc/fstab 
# UUID=c7834d14-d0f0-4d70-94f5-f1ce09fda00c / ext4 relatime,iversion 1 1 
# UUID=16b090bf-8b7a-4e69-8df6-6a4374f3d550 /home ext4 noexec,nosuid,relatime,iversion 1 2
```

2) Настроить контроль целостности. Желаемый алгоритм хеширования (SHA или ГОСТ) можно выбрать в файле `/etc/integrity/config`. Там же можно включить EVM в дополнение к IMA. Для изменения алгоритма хеширования необходимо изменить значение переменной `HASH_ALGO` в файле `/etc/integrity/config`, например, заменить `HASH_ALGO="sha512"` на `HASH_ALGO="streebog512"`. Если необходимо выполнить активацию EVM, то следует раскоментировать строку: `WITH_EVM=yes`

3) Запустить инициализацию подсистем контроля целостности в автоматическом режиме: 
```bash
integrity-applier --auto
```

4) После перезагрузки системы войти в систему и проверить параметры командной строки ядра:
```bash
cat /proc/cmdline 
# BOOT_IMAGE=/boot/vmlinuz root=UUID=19124d73-ad8b-4b83- ba28-350312a1b7f7 ro panic=30 init_on_free=1 loglevel=3 splash lsm=integrity quiet ima_hash=streebog512 ima_appraise=enforce
```

В командной строке ядра должен присутствовать параметр `ima_appraise=enforce` – система находится в режиме оценки контроля целостности;

5) Добавить в автозагрузку и включить службы: 
```bash
systemctl enable --now integrity-scanner.service integrity-notifier.service ima-check.service
```

6) Проверить наличие маркировки у файла можно, выполнив команду (пример для `/usr/bin/less`):
```bash
getfattr -m - -d /usr/bin/less
echo /usr/bin/less | integrity-sign --stdin --verbose --verify --with-evm
evmctl -v ima_verify /usr/bin/less
```

Строка `security.ima=...` свидетельствует о том, что файл маркирован. 

В журнале записи, связанные с нарушением целостности можно просмотреть командой: 

```bash
journalctl -r | grep INTEGRITY_DATA
```

Есть конфиг /etc/integrity/config и в нём есть две переменные: LIBDIRS и EXECLIBDIR. Пусть заказчик настроит те пути, которые ему нужны. Можно задать несколько путей через пробел.

На всякий случай кусочек кода, чтобы было понятно:

```bash
find -P /bin /sbin /usr/bin /usr/sbin /usr/share /etc /var/lib $EXECLIBDIRS -type f -executable -print

# all libraries which don't carry an executable bit
#shellcheck disable=SC2086
find -P /var/lib $LIBDIRS -\! -executable -type f \( -name '*.so' -o -name '*.so.*' \) -print
```

- Как я понимаю, параметры `--cert=` and `--key=` позволяют указать пользовательские ключи и сертификаты во время запуска второй стадии?

Если запускаете с --auto, то да, нужно указать путь до сертификата и ключа и они автоматически подхватятся на второй стадии. Но если запускаете вторую стадию вручную, то тогда нужно прямо в этот момент и указать пути.

- А как тогда используется параметр `-B BASENAME | --basename=BASENAME` ?

По умолчанию он равен "x509" и сертификат устанавливается под именем /etc/keys/x509_ima.der. Опция на тот случай, если у вас несколько сертификатов и все их нужно установить в /etc/keys/. То есть, когда часть файлов вы подписываете одним ключом, а часть — другим. Там же такая история, что сторонние поставщики ПО будут подписывать его своими ключами. Следовательно, доверенных ключей в ядре может быть несколько.