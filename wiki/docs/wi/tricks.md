# Всякие фишки и мелочь

https://factory.altlinux.space/


## Своя репа Альта:

Создание собственного репозитория происходит в несколько шагов:

1. Создаём директорию, в которой будет располагаться Ваш репозиторий, например `testrepo`:

```bash
mkdir testrepo
```

2. Переходим в данную директорию:

```bash
cd testrepo/
```

3. Создаём структуру репозитория. В данном примере создаётся структура из трёх архитектур: `x86_64` — 64-битные программы, `i586` — 32-битные программы, `noarch` — всё, что не зависит от архитектуры.

```bash
mkdir -p x86_64/RPMS.classic i586/RPMS.classic noarch/RPMS.classic
```

4. В директории `RPMS.classic` необходимо поместить пакеты соответствующих архитектур.

5. Для каждой архитектуры создаём метаинформацию:

```bash
genbasedir --create --progress --topdir=. x86_64 classic
genbasedir --create --progress --topdir=. i586 classic
genbasedir --create --progress --topdir=. noarch classic
```

По итогу у Вас должна получиться следующая структура:

```bash
testrepo
├── i586 # пакеты архитектуры i586
│   ├── base # метаинформация
│   │   ├── pkglist.classic
│   │   ├── pkglist.classic.bz2
│   │   ├── pkglist.classic.xz
│   │   ├── release
│   │   └── release.classic
│   └── RPMS.classic
│       └── foobar-1.2-5.i586.rpm
├── noarch # архитектурно-независимые пакеты
│   ├── base # метаинформация
│   │   ├── pkglist.classic
│   │   ├── pkglist.classic.bz2
│   │   ├── pkglist.classic.xz
│   │   ├── release
│   │   └── release.classic
│   └── RPMS.classic
│       └── foobar-doc-1.2-5.noarch.rpm
└── x86_64 # пакеты архитектуры x86_64
    ├── base # метаинформация
    │   ├── pkglist.classic
    │   ├── pkglist.classic.bz2
    │   ├── pkglist.classic.xz
    │   ├── release
    │   └── release.classic
    └── RPMS.classic
        └── foobar-1.2-5.x86_64.rpm
```

Далее необходимо опубликовать всю директорию `testrepo` в сети, например:

- Nginx: https://docs.altlinux.org/ru-RU/alt-server/11.1/html/alt-server/server-network--mirror.html#nginx
- FTP: https://docs.altlinux.org/ru-RU/alt-server/11.1/html/alt-server/server-network--ftp.html

Вы можете опубликовать любым способом, используя следующие протоколы: `http`, `ftp`, `rsync`.

Дополнительно:  
Если потребуется обновить пакеты в репозитории, нужно будет также обновить и метаинформацию, например, следующей командой:

```bash
for arch in x86_64 i586 noarch; do genbasedir --bloat --progress --topdir=путь/до/testrepo/ $arch classic; done
```

___

На клиенте необходимо подключить созданный репозиторий, для этого создадим отдельный `source.list`, например:

```bash
touch /etc/apt/sources.list.d/testrepo.list
```

Далее необходимо заполнить данный файл. Содержимое будет примерно следующим:

```
# Протокол http
rpm http://<сервер>/testrepo x86_64 classic 
rpm http://<сервер>/testrepo i586 classic
rpm http://<сервер>/testrepo noarch classic

# Протокол ftp
rpm ftp://<сервер>/testrepo x86_64 classic 
rpm ftp://<сервер>/testrepo i586 classic
rpm ftp://<сервер>/testrepo noarch classic

# Протокол rsync
rpm rsync://<сервер>/testrepo x86_64 classic 
rpm rsync://<сервер>/testrepo i586 classic
rpm rsync://<сервер>/testrepo noarch classic
```

## Запуск графического приложения по ssh на удалённой машине с уже запущенной сессией

Мне нужно было запусить Rustdesk, чтобы подключиться полноценно, но клиент был выключен. Сессия у меня была Wayland. Я подключился к компьютеру по ssh под тем же пользователем, что и в графической сессии на той стороне и сделал:

```bash
$ export XDG_RUNTIME_DIR="/run/user/$(id -u)"
$ export WAYLAND_DISPLAY="wayland-0"
$ systemd-run --user --collect --wait rustdesk 
```

## Проверка работы динамиков

В Linux можно проверить звук через терминал несколькими способами. Вот основные из них:

**Проверка через `speaker-test` (встроенный тест динамика)**

Утилита `speaker-test` генерирует тестовый звук.

```bash
speaker-test -t wav -c 2
```

- `-t wav` — тип сигнала (можно также `sine` для синусоиды).
- `-c 2` — количество каналов (2 = стерео).

Чтобы остановить — нажмите **Ctrl+C**.

Если команда не найдена, установите пакет `alsa-utils`:
```bash
apt-get install alsa-utils
```


**Проверка уровня громкости и состояния звука**

Через ALSA:
```bash
amixer sget Master
```

Если звук выключен:
```bash
amixer sset Master unmute
amixer sset Master 80%   # установить громкость
```

```bash
pactl list sinks short    # список аудиовыходов
pactl get-sink-volume @DEFAULT_SINK@   # текущая громкость
pactl set-sink-volume @DEFAULT_SINK@ 80%   # установить громкость
pactl set-sink-mute @DEFAULT_SINK@ false   # включить звук
```


**Проверка, работает ли звуковая карта**

```bash
lspci | grep -i audio
# или для USB-устройств:
lsusb
```

Также можно посмотреть логи:
```bash
dmesg | grep -i audio
```

---

**Простой тест через `beep` (если поддерживается)**

Некоторые системы поддерживают системный спикер:

```bash
echo -e "\a"
# или
beep
```

> Утилита `beep` может потребовать установки и прав на `/dev/input/by-path/...`.



## 皆さんこんにちは！ Устанавливаем поддержку нормальной японской раскладки (Пока с этим гайдом есть проблемки)

`mozc` позволит печатать romaji и получать на выходе хирагану, катакану и, соответственно, кандзи.

Я настраивал это только в KDE Plasma 6

1. Устанавливаем необходимые пакеты:
```bash
apt-get install fcitx5-qt fcitx5-configtool fcitx5 fcitx5-gtk fcitx5-mozc
```

2. Редактируем файл:
```bash
nano ~/.bash_profile
```
Добавляем строки:
```bash
export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export XMODIFIERS=@im=fcitx
```

3. Перезагружаем компьютер. Теперь раскладкой управляет `fcitx5`.

4. Переходим в настройки KDE: Клавиатура - Клавиатура.

Включаем раскладки, удаляем все лишние, оставляем только `Английская (США)`

5. Переходим в `настройки fcitx5`. В трее правой кнопкой мыши по текущей раскладке, далее нажимаем настройки.

6. В группу добавляем метод ввода `mozc` и другие нужные раскладки.

![](/img/mozc.png)

Профит. Но после перезагрузки всё подохло окончательно)

::: warning Wayland-VS_Codium-fcitx5
С этой системой в Wayland шалит VS Codium. Чтобы это решить, отредактируйте параметры запуска, измените их на:
```bash
--enable-features=UseOzonePlatform --ozone-platform=wayland --enable-wayland-ime %F
```

Я привёл параметры запуска в ярлычке в меню приложений KDE. Если запускаете через консоль, то уберите `%F`
:::




## Проброс репозитория в закрытый контур

1) Разворачивают локальный репо. 
2) Далее с делают копию на флеш-устройство нашего репо. 
3) Проверяют флеш-устройство на антивирусе (требования ФСТЭК) . 
4) С проверенного флеш-устройствоа синхронизируют с локальным репо  в закрытом контуре. 
Синхранизации наш репо- флеш-устройство-локальный репо в закрытом контуре делают через rsync. Это стандартная процедура для закрытого контура.

Второй вариант. Если используются сертифицированные версии МЭ. И есть доступ через них в закрытый контур (Физически не разделены) То регулятор разрешает так скажем однустороннюю связь по определенным портам. Тогда Локальный репо в открытой их сети. Проверка этого репо чере антивирус. И синхронизациия уже этого репо с репо в закрытой сети через сертифицированный МЭ.

Обязательно в любом случае повторно проверяется перед использованием репо в закрытой сети антивирусом. Желательно другим. То есть в KAV в открытой (не сертифицированной сети) или флеш-устройство. В Закрытой Drweb. Или Наоборот. Но это рекомендация ФСТЭК. Можно и одним но опять не рекомендовано. Но наказание за это не предусмотрено. Максимум рекомендация ФСТЭК при проверке ОИ.

## Чем можно проверить диск в Альт Линукс

smartctl (smartmontools)

Дополнительно в gnome доступен следующий инструмент: gnome-disk-utility

hdparm — Инструмент для тестирования скорости чтения (бенчмаркинг) и управления параметрами работы в основном HDD-дисков через низкоуровневые настройки.

badblocks — Утилита для прямого поиска сбойных секторов на поверхности диска.

fsck — стандартная утилита для проверки и исправления ошибок файловых систем (ext2/ext3/ext4, FAT, NTFS и др.)

testdisk

btrfs check
