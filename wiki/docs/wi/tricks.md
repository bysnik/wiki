# Всякие фишки и мелочь

https://factory.altlinux.space/


## Своя репа Альта:

Создание собственного репозитория происходит в несколько шагов:

1. Создаём директорию, в которой будет располагаться Ваш репозиторий, например `testrepo`:

```bash
mkdir testrepo
```

2. Переходим в данную директорию:

```bash
cd testrepo/
```

3. Создаём структуру репозитория. В данном примере создаётся структура из трёх архитектур: `x86_64` — 64-битные программы, `i586` — 32-битные программы, `noarch` — всё, что не зависит от архитектуры.

```bash
mkdir -p x86_64/RPMS.classic i586/RPMS.classic noarch/RPMS.classic
```

4. В директории `RPMS.classic` необходимо поместить пакеты соответствующих архитектур.

5. Для каждой архитектуры создаём метаинформацию:

```bash
genbasedir --create --progress --topdir=. x86_64 classic
genbasedir --create --progress --topdir=. i586 classic
genbasedir --create --progress --topdir=. noarch classic
```

По итогу у Вас должна получиться следующая структура:

```bash
testrepo
├── i586 # пакеты архитектуры i586
│   ├── base # метаинформация
│   │   ├── pkglist.classic
│   │   ├── pkglist.classic.bz2
│   │   ├── pkglist.classic.xz
│   │   ├── release
│   │   └── release.classic
│   └── RPMS.classic
│       └── foobar-1.2-5.i586.rpm
├── noarch # архитектурно-независимые пакеты
│   ├── base # метаинформация
│   │   ├── pkglist.classic
│   │   ├── pkglist.classic.bz2
│   │   ├── pkglist.classic.xz
│   │   ├── release
│   │   └── release.classic
│   └── RPMS.classic
│       └── foobar-doc-1.2-5.noarch.rpm
└── x86_64 # пакеты архитектуры x86_64
    ├── base # метаинформация
    │   ├── pkglist.classic
    │   ├── pkglist.classic.bz2
    │   ├── pkglist.classic.xz
    │   ├── release
    │   └── release.classic
    └── RPMS.classic
        └── foobar-1.2-5.x86_64.rpm
```

Далее необходимо опубликовать всю директорию `testrepo` в сети, например:

- Nginx: https://docs.altlinux.org/ru-RU/alt-server/11.1/html/alt-server/server-network--mirror.html#nginx
- FTP: https://docs.altlinux.org/ru-RU/alt-server/11.1/html/alt-server/server-network--ftp.html

Вы можете опубликовать любым способом, используя следующие протоколы: `http`, `ftp`, `rsync`.

Дополнительно:  
Если потребуется обновить пакеты в репозитории, нужно будет также обновить и метаинформацию, например, следующей командой:

```bash
for arch in x86_64 i586 noarch; do genbasedir --bloat --progress --topdir=путь/до/testrepo/ $arch classic; done
```

___

На клиенте необходимо подключить созданный репозиторий, для этого создадим отдельный `source.list`, например:

```bash
touch /etc/apt/sources.list.d/testrepo.list
```

Далее необходимо заполнить данный файл. Содержимое будет примерно следующим:

```
# Протокол http
rpm http://<сервер>/testrepo x86_64 classic 
rpm http://<сервер>/testrepo i586 classic
rpm http://<сервер>/testrepo noarch classic

# Протокол ftp
rpm ftp://<сервер>/testrepo x86_64 classic 
rpm ftp://<сервер>/testrepo i586 classic
rpm ftp://<сервер>/testrepo noarch classic

# Протокол rsync
rpm rsync://<сервер>/testrepo x86_64 classic 
rpm rsync://<сервер>/testrepo i586 classic
rpm rsync://<сервер>/testrepo noarch classic
```

## Запуск графического приложения по ssh на удалённой машине с уже запущенной сессией

Мне нужно было запусить Rustdesk, чтобы подключиться полноценно, но клиент был выключен. Сессия у меня была Wayland. Я подключился к компьютеру по ssh под тем же пользователем, что и в графической сессии на той стороне и сделал:

```bash
$ export XDG_RUNTIME_DIR="/run/user/$(id -u)"
$ export WAYLAND_DISPLAY="wayland-0"
$ systemd-run --user --collect --wait rustdesk 
```

## Проверка работы динамиков

В Linux можно проверить звук через терминал несколькими способами. Вот основные из них:

**Проверка через `speaker-test` (встроенный тест динамика)**

Утилита `speaker-test` генерирует тестовый звук.

```bash
speaker-test -t wav -c 2
```

- `-t wav` — тип сигнала (можно также `sine` для синусоиды).
- `-c 2` — количество каналов (2 = стерео).

Чтобы остановить — нажмите **Ctrl+C**.

Если команда не найдена, установите пакет `alsa-utils`:
```bash
apt-get install alsa-utils
```


**Проверка уровня громкости и состояния звука**

Через ALSA:
```bash
amixer sget Master
```

Если звук выключен:
```bash
amixer sset Master unmute
amixer sset Master 80%   # установить громкость
```

```bash
pactl list sinks short    # список аудиовыходов
pactl get-sink-volume @DEFAULT_SINK@   # текущая громкость
pactl set-sink-volume @DEFAULT_SINK@ 80%   # установить громкость
pactl set-sink-mute @DEFAULT_SINK@ false   # включить звук
```


**Проверка, работает ли звуковая карта**

```bash
lspci | grep -i audio
# или для USB-устройств:
lsusb
```

Также можно посмотреть логи:
```bash
dmesg | grep -i audio
```

---

**Простой тест через `beep` (если поддерживается)**

Некоторые системы поддерживают системный спикер:

```bash
echo -e "\a"
# или
beep
```

> Утилита `beep` может потребовать установки и прав на `/dev/input/by-path/...`.



## 皆さんこんにちは！ Устанавливаем поддержку нормальной японской раскладки (Пока с этим гайдом есть проблемки)

`mozc` позволит печатать romaji и получать на выходе хирагану, катакану и, соответственно, кандзи.

Я настраивал это только в KDE Plasma 6

1. Устанавливаем необходимые пакеты:
```bash
apt-get install fcitx5-qt fcitx5-configtool fcitx5 fcitx5-gtk fcitx5-mozc
```

2. Редактируем файл:
```bash
nano ~/.bash_profile
```
Добавляем строки:
```bash
export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export XMODIFIERS=@im=fcitx
```

3. Перезагружаем компьютер. Теперь раскладкой управляет `fcitx5`.

4. Переходим в настройки KDE: Клавиатура - Клавиатура.

Включаем раскладки, удаляем все лишние, оставляем только `Английская (США)`

5. Переходим в `настройки fcitx5`. В трее правой кнопкой мыши по текущей раскладке, далее нажимаем настройки.

6. В группу добавляем метод ввода `mozc` и другие нужные раскладки.

![](/img/mozc.png)

Профит. Но после перезагрузки всё подохло окончательно)

::: warning Wayland-VS_Codium-fcitx5
С этой системой в Wayland шалит VS Codium. Чтобы это решить, отредактируйте параметры запуска, измените их на:
```bash
--enable-features=UseOzonePlatform --ozone-platform=wayland --enable-wayland-ime %F
```

Я привёл параметры запуска в ярлычке в меню приложений KDE. Если запускаете через консоль, то уберите `%F`
:::




## Проброс репозитория в закрытый контур

1) Разворачивают локальный репо. 
2) Далее с делают копию на флеш-устройство нашего репо. 
3) Проверяют флеш-устройство на антивирусе (требования ФСТЭК) . 
4) С проверенного флеш-устройствоа синхронизируют с локальным репо  в закрытом контуре. 
Синхранизации наш репо- флеш-устройство-локальный репо в закрытом контуре делают через rsync. Это стандартная процедура для закрытого контура.

Второй вариант. Если используются сертифицированные версии МЭ. И есть доступ через них в закрытый контур (Физически не разделены) То регулятор разрешает так скажем однустороннюю связь по определенным портам. Тогда Локальный репо в открытой их сети. Проверка этого репо чере антивирус. И синхронизациия уже этого репо с репо в закрытой сети через сертифицированный МЭ.

Обязательно в любом случае повторно проверяется перед использованием репо в закрытой сети антивирусом. Желательно другим. То есть в KAV в открытой (не сертифицированной сети) или флеш-устройство. В Закрытой Drweb. Или Наоборот. Но это рекомендация ФСТЭК. Можно и одним но опять не рекомендовано. Но наказание за это не предусмотрено. Максимум рекомендация ФСТЭК при проверке ОИ.

## Чем можно проверить диск в Альт Линукс

smartctl (smartmontools)

Дополнительно в gnome доступен следующий инструмент: gnome-disk-utility

hdparm — Инструмент для тестирования скорости чтения (бенчмаркинг) и управления параметрами работы в основном HDD-дисков через низкоуровневые настройки.

badblocks — Утилита для прямого поиска сбойных секторов на поверхности диска.

fsck — стандартная утилита для проверки и исправления ошибок файловых систем (ext2/ext3/ext4, FAT, NTFS и др.)

testdisk

btrfs check

## Ограничение пропускной способности сетевого соединения в Linux

Если в процессе работы с вашей системой Linux для настольных компьютеров вы нередко одновременно используете множество работающих с сетью приложений или разделяете пропускную способность своего домашнего сетевого соединения между несколькими компьютерами, вы наверняка хотите максимально контролировать использование ресурсов имеющегося сетевого соединения. В противном случае при загрузке файлов большого объема с помощью специализированного приложения ваша интерактивная сессия SSH может начать работать с большим замедлением или перестать работать вообще. Либо в процессе синхронизации директории большого объема с сервером Dropbox ваши домашние могут начать жаловаться на постоянные перерывы, возникающие в процессе просмотра видео из сети.

В данном руководстве я постараюсь описать два различных подхода к ограничению пропускной способности сетевого соединения в Linux.

### Ограничение пропускной способности сетевого соединения на уровне приложения в Linux

Одним из инструментов для ограничения пропускной способности сетевого соединения, использующим интерфейс командной строки системы, является утилита под названием [trickle](http://monkey.org/~marius/trickle). Trickle позволяет осуществлять шейпинг трафика, генерируемого любым из существующих приложений, путем «подгрузки» библиотеки с реализацией механизма сетевых сокетов и алгоритмов ограничения пропускной способности сетевого соединения в процессе запуска приложения. Преимущество утилиты trickle заключается в том, что она функционирует исключительно в пространстве пользователя, поэтому вам не понадобятся привилегии пользователя root для ограничения пропускной способности сетевого соединения на уровне какого-либо из приложений. Для совместимости с утилитой trickle приложение должно использовать интерфейс сетевых сокетов без статического связывания с соответствующей системной библиотекой. Утилита trickle может оказаться полезной тогда, когда вам нужно ограничить пропускную способность сетевого соединения на уровне приложения, которое не имеет аналогичного встроенного механизма.

Для установки trickle в Ubuntu, Debian и производных дистрибутивах следует использовать следующую команду:
```
$ sudo apt-get install trickle
```
Для установки trickle в дистрибутивах Fedora или CentOS/RHEL (с подключенным репозиторием EPEL) следует использовать следующую команду:
```
$ sudo yum install trickle
```
Утилита trickle используется следующим образом. Необходимо просто разместить вызов trickle (а также флаги и значения лимитов скоростей) перед командой, которую вы желаете исполнить.
```
$ trickle -d <лимит-скорости-приема> -u <лимит-скорости-передачи> <команда>
```
С помощью данной команды устанавливаются заданные лимиты скоростей приема и передачи данных (в КБ/с) для приложения, запускаемого с помощью заданной команды.

Например, для установки ограничения максимальной скорости передачи данных для утилиты scp, равного 100 КБ/с, может использоваться следующая команда:
```
$ trickle -u 100 scp backup.tgz alice@remote\_host.com:
```
При желании вы можете установить ограничение максимальной скорости приема данных (равное, к примеру, 300 КБ/с) для вашего веб-браузера Firefox, создав специальный файл запуска приложения со следующей командой запуска:
```
trickle -d 300 firefox %u
```
Наконец, утилита trickle может запускаться в режиме демона и контролировать «общую» пропускную способность сетевого соединения для всех приложений, которые были запущены с помощью нее. Для запуска trickle в режиме демона (т.е., trickled) может использоваться следующая команда:
```
$ sudo trickled -d 1000
```
После того, как демон trickled начнет работу в фоновом режиме, вы можете запускать другие приложения с помощью утилиты trickle. Теперь, если вы запустите с помощью утилиты trickle одно приложение, его скорость приема данных будет ограничиваться 1000 КБ/с. Если же вы запустите с помощью утилиты trickle еще одно приложение, скорость приема данных каждого из этих приложений будет ограничиваться 500 КБ/с и так далее…

### Ограничение пропускной способности сетевого соединения на уровне сетевого интерфейса в Linux

Еще один способ управления пропускной способностью вашего сетевого соединения заключается в установке лимитов скоростей приема и передачи данных на уровне сетевого интерфейса. Данный подход может оказаться полезным тогда, когда вы делите соединение с сетью Интернет с кем-либо еще. Как и в подавляющем большинстве случаев, в Linux есть необходимый для этого инструмент. Сценарий [wondershaper](http://lartc.org/wondershaper/) предназначен для выполнения описанной задачи: он ограничивает пропускную способность сетевого соединения на уровне сетевого интерфейса.

На самом деле, wondershaper является простым сценарием командной оболочки, который использует утилиту [tc](http://lartc.org/manpages/tc.txt) для установки параметров шейпинга трафика и качества сетевого соединения на уровне заданного сетевого интерфейса. Шейпинг исходящего трафика осуществляется путем распределения пакетов по очередям с разными приоритетами, шейпинг входящего трафика - путем отбрасывания пакетов.

Фактически, список полезных функций сценария wondershaper не ограничивался добавлением возможности управления пропускной способностью для каждого из сетевых интерфейсов. Wondershaper также пытается максимально снизить задержки интерактивных сессий, таких, как SSH в процессе загрузки или передачи файлов больших объемов. Кроме того, он гарантирует, что при передаче файлов больших объемов (например, при синхронизации директорий с сервером Dropbox) не будет значительно снижаться скорость загрузки файлов и наоборот.

Для установки wondershaper в Ubuntu, Debian и производных дистрибутивах следует использовать следующую команду:
```
$ sudo apt-get install wondershaper
```
Для установки wondershaper в дистрибутиве Fedora или CentOS/RHEL (с подключенным репозиторием EPEL) следует использовать следующую команду:
```
$ sudo yum install wondershaper
```
Сценарий wondershaper используется следующим образом:
```
$ sudo wondershaper <интерфейс> <лимит-скорости-приема> <лимит-скорости-передачи>
```
Например, для установки максимальных скоростей приема/передачи данных для сетевого интерфейса eth0, равных 1000 и 500 Кб/с соответственно, может использоваться следующая команда:
```
$ sudo wondershaper eth0 1000 500
```
Вы можете удалить установленное ограничение пропускной способности сетевого интерфейса с помощью следующей команды:
```
$ sudo wondershaper clear eth0
```
Если вас интересует принцип работы сценария wondershaper, вы можете изучить его содержимое (/sbin/wondershaper).

### Заключение

В данном руководстве я рассказал о двух различных вариантах ограничения пропускной способности сетевого соединения в системе Linux для настольных компьютеров, а именно, об ограничении пропускной способности сетевого соединения на уровне отдельных приложений и на уровне сетевых интерфейсов. Оба рассмотренных инструмента являются максимально простыми и позволяют быстро и просто организовать шейпинг ранее никоим образом не контролируемого сетевого трафика. Те из вас, кто желает узнать больше о способах ограничения пропускной способности сетевых соединений в Linux, могут ознакомиться со [следующим руководством](http://www.lartc.org/lartc.html).
