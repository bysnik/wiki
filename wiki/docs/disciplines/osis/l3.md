---
outline: deep
---

# Лекция 3. Interleaving, Race Condition, Mutual Exclusion, Программные алгоритмы организации взаимодействия процессов и Алгоритмы планирования процессов

Для корректного взаимодействия процессов недостаточно одних организационных усилий операционной системы. Необходимы определенные внутренние изменения в поведении процессов. В настоящей лекции рассматриваются вопросы, связанные с такими изменениями, приводятся программные алгоритмы корректной организации взаимодействия процессов.

## Interleaving, Race Condition, Mutual Exclusion

Давайте временно отвлечемся от операционных систем, процессов и нитей исполнения и поговорим о некоторых "активностях". Под активностями мы будем понимать последовательное выполнение ряда действий, направленных на достижение определенной цели. Мы будем разбивать активности на некоторые неделимые, или атомарные (операция выполняется либо целиком, либо вообще не выполняется), операции. Например, активность «приготовление бутерброда» можно разбить на следующие атомарные операции:

1. Отрезать ломтик хлеба.
2. Отрезать ломтик колбасы.
3. Намазать ломтик хлеба маслом.
4. Положить ломтик колбасы на подготовленный ломтик хлеба.

Неделимые операции могут иметь внутренние невидимые действия (взять батон хлеба в левую руку, взять нож в правую руку, произвести отрезание). Мы же называем их неделимыми потому, что считаем выполняемыми за раз, без прерывания деятельности.

Пусть имеется две активности:

```
P: a b c
Q: d e f
```

где a, b, c, d, e, f — атомарные операции. При последовательном выполнении активностей мы получаем такую последовательность атомарных действий:

```
PQ: a b c d e f
```

::: info Определение
При исполнении этих активностей псевдопараллельно активности могут расслоиться на неделимые операции с различным чередованием, то есть может произойти то, что на английском языке принято называть словом **interleaving**. 
:::

Представьте все возможные варианты чередования a, b, c, d, e, f.

Атомарные операции активностей могут чередоваться всевозможными различными способами с сохранением порядка расположения внутри активностей. Так как псевдопараллельное выполнение двух активностей приводит к чередованию их неделимых операций, результат псевдопараллельного выполнения может отличаться от результата последовательного выполнения. Рассмотрим пример. Пусть у нас имеется две активности P и Q, состоящие из двух атомарных операций каждая:

```
P: x=2      Q: x=3
   y=x-1       y=x+1
```

Что мы получим в результате их псевдопараллельного выполнения, если переменные x и y являются для активностей общими? Очевидно, что возможны четыре разных набора значений для пары (x, y): (3, 4), (2, 1), (2, 3) и (3, 2). Мы будем говорить, что набор активностей (например, программ) **детерминирован (определен)**, если всякий раз при псевдопараллельном исполнении для одного и того же набора входных данных он дает одинаковые выходные данные. Выше приведен пример недетерминированного набора программ.

Можно ли до получения результатов определить, является ли набор активностей детерминированным или нет? Для этого существуют **достаточные условия Бернстайна**.

Введем наборы входных и выходных переменных программы. Для каждой атомарной операции наборы входных и выходных переменных — это наборы переменных, которые атомарная операция считывает и записывает. Набор входных переменных программы R(P) (R от слова read) суть объединение наборов входных переменных для всех ее неделимых действий. Аналогично, набор выходных переменных программы W(P) (W от слова write) суть объединение наборов выходных переменных для всех ее неделимых действий. Например, для программы:

```
P: x=u+v
   y=x*w
```

получаем R(P) = {u, v, x, w}, W(P) = {x, y}. Заметим, что переменная x присутствует как в R(P), так и в W(P).

::: info
Теперь сформулируем условия Бернстайна.

Если для двух данных активностей P и Q:
- пересечение W(P) и W(Q) пусто,
- пересечение W(P) с R(Q) пусто,
- пересечение R(P) и W(Q) пусто,

тогда выполнение P и Q детерминировано.

Если эти условия не соблюдены, возможно, параллельное выполнение P и Q детерминировано, а может быть, и нет.

Случай двух активностей естественным образом обобщается на их большее количество.
:::

Условия Бернстайна информативны, но слишком жестки. По сути дела, они требуют практически невзаимодействующих процессов. А нам хотелось бы, чтобы детерминированный набор образовывали активности, совместно использующие информацию и обменивающиеся ею. Для этого нам необходимо ограничить число возможных чередований атомарных операций, исключив некоторые чередования с помощью механизмов синхронизации выполнения программ, обеспечив тем самым упорядоченный доступ программ к некоторым данным.

Про недетерминированный набор программ (и активностей вообще) говорят, что он имеет **race condition** (состояние гонки, состояние состязания). В приведенном выше примере процессы состязаются за вычисление значений переменных x и y.

Задачу упорядоченного доступа к разделяемым данным (устранение race condition) в том случае, когда нам не важна его очередность, можно решить, если обеспечить каждому процессу эксклюзивное право доступа к этим данным. Каждый процесс, обращающийся к разделяемым ресурсам, исключает для всех других процессов возможность одновременного общения с этими ресурсами, если это может привести к недетерминированному поведению набора процессов. Такой прием называется **взаимоисключением (mutual exclusion)**. Если очередность доступа к разделяемым ресурсам важна для получения правильных результатов, то одними взаимоисключениями уже не обойтись, нужна взаимосинхронизация поведения программ.

### Критическая секция

Важным понятием при изучении способов синхронизации процессов является понятие критической секции (critical section) программы.

::: info Определение
**Критическая секция** — это часть программы, исполнение которой может привести к возникновению race condition для определенного набора программ. Чтобы исключить эффект гонок по отношению к некоторому ресурсу, необходимо организовать работу так, чтобы в каждый момент времени только один процесс мог находиться в своей критической секции, связанной с этим ресурсом.
:::

<iframe
  src="https://viewer.diagrams.net/?highlight=0000ff&layers=1&nav=1&title=Diagram#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1hxw7a5Q2TT5Pi83es7RsKJ0tcJmoMN3M%26export%3Ddownload"
  width="100%"
  height="600px"
  frameborder="0"
  allowfullscreen
></iframe>

<!--https://drive.google.com/file/d/1hxw7a5Q2TT5Pi83es7RsKJ0tcJmoMN3M/view?usp=sharing-->

Итак, для решения задачи необходимо, чтобы в том случае, когда процесс находится в своем критическом участке, другие процессы не могли войти в свои критические участки.

#### Программные алгоритмы организации взаимодействия процессов

Пять условий, которые должны выполняться для хорошего программного алгоритма организации взаимодействия процессов, имеющих критические участки, если они могут проходить их в произвольном порядке:

1. Задача должна быть решена чисто программным способом на обычной машине, не имеющей специальных команд взаимоисключения.
2. Не должно существовать никаких предположений об относительных скоростях выполняющихся процессов или числе процессоров, на которых они исполняются.
3. Если процесс исполняется в своем критическом участке, то не существует никаких других процессов, которые исполняются в соответствующих критических секциях.
4. Процессы, которые находятся вне своих критических участков и не собираются входить в них, не могут препятствовать другим процессам входить в их собственные критические участки.
5. Не должно возникать неограниченно долгого ожидания для входа одного из процессов в свой критический участок.

##### Запрет прерываний

```c
while (some condition) {
    запретить_все_прерывания
    critical_section();
    разрешить_все_прерывания
    remainder_section();
}
```

При условии, когда процесс входит в критическую секцию, запрет прерываний действует так: запрещает прерывания, входит в критическую секцию, разрешает прерывания, оставшиеся этапы.

Однако такое решение может иметь далеко идущие последствия, поскольку позволяет процессу пользователя разрешать и запрещать прерывания во всей вычислительной системе. Допустим, что пользователь случайно или по злому умыслу запретил прерывания в системе и зациклил или завершил свой процесс. Без перезагрузки системы в такой ситуации не обойтись.

##### Переменная-замок

```c
shared int lock = 0; /* shared означает, что переменная является разделяемой */

while (some condition) {
    while(lock);
    lock = 1;
    critical_section();
    lock = 0;
    remainder_section();
}
```

Переменная-замок работает так: Процесс может войти в критическую секцию только тогда, когда значение этой переменной-замка равно 0, одновременно изменяя ее значение на 1 — закрывая замок; Выходит из критической секции, меняет значение переменной на 0; остальные этапы.

К сожалению, при внимательном рассмотрении мы видим, что такое решение не удовлетворяет условию взаимоисключения, так как действие `while(lock); lock = 1;` не является атомарным.

##### Строгое чередование

```c
shared int turn = 0;

while (some condition) {
    while(turn != i);
    critical_section();
    turn = 1 - i;
    remainder_section();
}
```

Строгое чередование работает так: если переменная равна 1, то процесс готов войти в критический участок; Входит в критический участок; переменная меняется на 0 — процесс не может войти в критический участок; остальные этапы.

Процессы входят в критическую секцию строго по очереди: P0, P1, P0, P1, P0, ...

Если turn равно 1, и процесс P0 готов войти в критический участок, он не может сделать этого, даже если процесс P1 находится в remainder section.

##### Флаги готовности

```c
shared int ready[2] = {0, 0};

while (some condition) {
    ready[i] = 1;
    while(ready[1 - i]);
    critical_section();
    ready[i] = 0;
    remainder_section();
}
```

Работает так: Для каждого процесса в массиве указано 0 — его состояние, поэтому знают о состоянии друг друга; Если переменная равна 1 — входит в критическую секцию; После выхода переменная меняется на 0; остальные этапы.

Полученный алгоритм обеспечивает взаимоисключение, позволяет процессу, готовому к входу в критический участок, войти в него сразу после завершения эпилога в другом процессе, но все равно нарушает условие прогресса.

После выполнения присваивания `ready[0]=1` планировщик передал процессор от процесса 0 процессу 1, который также выполнил присваивание `ready[1]=1`. После этого оба процесса бесконечно долго ждут друг друга на входе в критическую секцию. Возникает ситуация, которую принято называть **тупиковой (deadlock)**.

##### Алгоритм Петерсона

Алгоритм Деккера — первое известное корректное решение проблемы взаимного исключения в параллельном программировании. Эдсгер Дейкстра ссылается на голландского математика Т. Деккера как на автора данного алгоритма в своей работе о межпроцессном взаимодействии. Он позволяет двум потокам выполнения совместно использовать неразделяемый ресурс без возникновения конфликтов, используя только общую память для коммуникации. В 1981 году Гарри Петерсон предложил более изящное решение. Хотя изначально был сформулирован для 2-поточного случая, алгоритм может быть обобщён для произвольного количества потоков. 

Пусть оба процесса имеют доступ к массиву флагов готовности и к переменной очередности.

```c
shared int ready[2] = {0, 0};
shared int turn;

while (some condition) {
    ready[i] = 1;
    turn = 1 - i;
    while(ready[1 - i] && turn == 1 - i);
    critical_section();
    ready[i] = 0;
    remainder_section();
}
```

При исполнении пролога критической секции процесс Pi заявляет о своей готовности выполнить критический участок и одновременно предлагает другому процессу приступить к его выполнению. Если оба процесса подошли к прологу практически одновременно, то они оба объявят о своей готовности и предложат выполняться друг другу. При этом одно из предложений всегда следует после другого. Тем самым работу в критическом участке продолжит процесс, которому было сделано последнее предложение.

::: info Доказательство

Давайте докажем, что все пять наших требований к алгоритму действительно удовлетворяются.

Удовлетворение требований 1 и 2 очевидно.

Докажем выполнение условия взаимоисключения методом от противного. Пусть оба процесса одновременно оказались внутри своих критических секций. Заметим, что процесс Pi может войти в критическую секцию, только если `ready[1-i] == 0` или `turn == i`. Заметим также, что если оба процесса выполняют свои критические секции одновременно, то значения флагов готовности для обоих процессов совпадают и равны 1. Могли ли оба процесса войти в критические секции из состояния, когда они оба одновременно находились в процессе выполнения цикла while? Нет, так как в этом случае переменная turn должна была бы одновременно иметь значения 0 и 1 (когда оба процесса выполняют цикл, значения переменных измениться не могут). Пусть процесс P0 первым вошел в критический участок, тогда процесс P1 должен был выполнить перед вхождением в цикл while по крайней мере один предваряющий оператор (`turn = 0;`). Однако после этого он не может выйти из цикла до окончания критического участка процесса P0, так как при входе в цикл `ready[0] == 1` и `turn == 0`, и эти значения не могут измениться до тех пор, пока процесс P0 не покинет свой критический участок. Мы пришли к противоречию. Следовательно, имеет место взаимоисключение.

Докажем выполнение условия прогресса. Возьмем, без ограничения общности, процесс P0. Заметим, что он не может войти в свою критическую секцию только при совместном выполнении условий `ready[1] == 1` и `turn == 1`. Если процесс P1 не готов к выполнению критического участка, то `ready[1] == 0`, и процесс P0 может осуществить вход. Если процесс P1 готов к выполнению критического участка, то `ready[1] == 1` и переменная turn имеет значение 0 либо 1, позволяя процессу P0 либо процессу P1 начать выполнение критической секции. Если процесс P1 завершил выполнение критического участка, то он сбросит свой флаг готовности `ready[1] == 0`, разрешая процессу P0 приступить к выполнению критической работы. Таким образом, условие прогресса выполняется.

Отсюда же вытекает выполнение условия ограниченного ожидания. Так как в процессе ожидания разрешения на вход процесс P0 не изменяет значения переменных, он сможет начать исполнение своего критического участка после не более чем одного прохода по критической секции процесса P1.
:::

##### Алгоритм булочной (Bakery algorithm)

Алгоритм Петерсона дает нам решение задачи корректной организации взаимодействия двух процессов. Давайте рассмотрим теперь соответствующий алгоритм для n взаимодействующих процессов, который получил название алгоритм булочной, хотя применительно к нашим условиям его следовало бы скорее назвать алгоритм регистратуры в поликлинике. Основная его идея выглядит так. Каждый вновь прибывающий клиент (он же процесс) получает талончик на обслуживание с номером. Клиент с наименьшим номером на талончике обслуживается следующим. К сожалению, из-за неатомарности операции вычисления следующего номера алгоритм булочной не гарантирует, что у всех процессов будут талончики с разными номерами. В случае равенства номеров на талончиках у двух или более клиентов первым обслуживается клиент с меньшим значением имени (имена можно сравнивать в лексикографическом порядке).

Разделяемые структуры данных для алгоритма – это два массива:

```c
shared enum {false, true} choosing[n];
shared int number[n];
```

Изначально элементы этих массивов инициируются значениями `false` и `0` соответственно.

Введем следующие обозначения:

- `(a,b) < (c,d)`, если `a < c` или если `a == c` и `b < d`
- `max(a0, a1, ...., an)` – это число `k` такое, что `k >= ai` для всех `i = 0, ..., n`

Структура процесса `Pi` для алгоритма булочной приведена ниже:

```c
while (some condition) {
    choosing[i] = true;
    number[i] = max(number[0], ..., number[n-1]) + 1;
    choosing[i] = false;
    
    for(j = 0; j < n; j++) {
        while(choosing[j]);
        while(number[j] != 0 && (number[j],j) < (number[i],i));
    }
    
    critical section
    number[i] = 0;
    remainder section
}
```

Доказательство того, что этот алгоритм удовлетворяет условиям 1–5, выполните самостоятельно в качестве упражнения.


#### Аппаратная поддержка взаимоисключений

Наличие аппаратной поддержки взаимоисключений позволяет упростить алгоритмы и повысить их эффективность точно так же, как это происходит и в других областях программирования. Мы уже обращались к общепринятому hardware для решения задачи реализации взаимоисключений, когда говорили об использовании механизма запрета/разрешения прерываний.

Многие вычислительные системы помимо этого имеют специальные команды процессора, которые позволяют проверить и изменить значение машинного слова или поменять местами значения двух машинных слов в памяти, выполняя эти действия как атомарные операции. Давайте обсудим, как концепции таких команд могут использоваться для реализации взаимоисключений.

##### Команда Test-and-Set (проверить и присвоить 1)

О выполнении команды Test-and-Set, осуществляющей проверку значения логической переменной с одновременной установкой ее значения в 1, можно думать как о выполнении функции:

```c
int Test_and_Set(int *target) {
    int tmp = *target;
    *target = 1;
    return tmp;
}
```

С использованием этой атомарной команды мы можем модифицировать наш алгоритм для переменной-замка, так чтобы он обеспечивал взаимоисключения:

```c
shared int lock = 0;

while (some condition) {
    while(Test_and_Set(&lock));
    critical section
    lock = 0;
    remainder section
}
```

К сожалению, даже в таком виде полученный алгоритм не удовлетворяет условию ограниченного ожидания для алгоритмов. Подумайте, как его следует изменить для соблюдения всех условий.

##### Команда Swap (обменять значения)

Выполнение команды Swap, обменивающей два значения, находящихся в памяти, можно проиллюстрировать следующей функцией:

```c
void Swap(int *a, int *b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```

Применяя атомарную команду Swap, мы можем реализовать предыдущий алгоритм, введя дополнительную логическую переменную `key`, локальную для каждого процесса:

```c
shared int lock = 0;
int key;

while (some condition) {
    key = 1;
    do Swap(&lock, &key);
    while (key);
    
    critical section
    lock = 0;
    remainder section
}
```


## Планирование процессов

### Уровни планирования

В первой лекции, рассматривая эволюцию компьютерных систем, мы говорили о двух видах планирования в вычислительных системах: планировании заданий и планировании использования процессора.

Планирование заданий используется в качестве **долгосрочного планирования** процессов. Оно отвечает за порождение новых процессов в системе, определяя ее степень **мультипрограммирования, т. е. количество процессов, одновременно находящихся в ней**. Если среднее количество процессов в компьютере не меняется, то новые процессы могут появляться только после завершения ранее загруженных. Поэтому долгосрочное планирование осуществляется достаточно редко. Решение о выборе для запуска того или иного процесса оказывает влияние на функционирование вычислительной системы на протяжении достаточно длительного времени. Отсюда и название этого уровня планирования — долгосрочное. В некоторых операционных системах долгосрочное планирование сведено к минимуму или отсутствует вовсе.

Планирование использования процессора применяется в качестве **краткосрочного планирования** процессов. Оно проводится, к примеру, при обращении исполняющегося процесса к устройствам ввода-вывода или просто по завершении определенного интервала времени. Поэтому краткосрочное планирование осуществляется, как правило, не реже одного раза в 100 миллисекунд. Выбор нового процесса для исполнения оказывает влияние на функционирование системы до наступления очередного аналогичного события, т. е. в течение короткого промежутки времени, чем и обусловлено название этого уровня планирования — краткосрочное.

**Swapping («перекачка» или «подкачка»)** — временное удаление какого-либо частично выполнившегося процесса из оперативной памяти на диск, а позже возвращение его обратно для дальнейшего выполнения. Это делается для повышения производительности.

Когда и какой из процессов нужно перекачать на диск и вернуть обратно, решается дополнительным промежуточным уровнем планирования процессов — **среднесрочным.**

### Критерии планирования и требования к алгоритмам

Цели:
- **Справедливость** — гарантировать каждому заданию или процессу определенную часть времени использования процессора, стараясь не допустить возникновения ситуации, когда процесс одного пользователя постоянно занимает процессор, в то время как процесс другого пользователя фактически не начинал выполняться.
- **Эффективность** — постараться занять процессор на все 100% рабочего времени, не позволяя ему простаивать в ожидании процессов, готовых к исполнению. В реальных вычислительных системах загрузка процессора колеблется от 40 до 90%.
- **Сокращение полного времени выполнения (turnaround time)** — обеспечить минимальное время между стартом процесса или постановкой задания в очередь для загрузки и его завершением.
- **Сокращение времени ожидания (waiting time)** — сократить время, которое проводят процессы в состоянии готовность и задания в очереди для загрузки.
- **Сокращение времени отклика (response time)** — минимизировать время, которое требуется процессу в интерактивных системах для ответа на запрос пользователя.

Независимо от поставленных целей планирования желательно также, чтобы алгоритмы обладали следующими свойствами:
- **Были предсказуемыми**. Одно и то же задание должно выполняться приблизительно за одно и то же время.
- **Были связаны с минимальными накладными расходами.** Если на каждые 100 миллисекунд, выделенные процессу для использования процессора, будет приходиться 200 миллисекунд на определение того, какой именно процесс получит процессор в свое распоряжение, и на переключение контекста, то такой алгоритм, очевидно, применять не стоит.
- **Равномерно загружали ресурсы вычислительной системы**, отдавая предпочтение тем процессам, которые будут занимать малоиспользуемые ресурсы.
- **Обладали масштабируемостью**, т. е. не сразу теряли работоспособность при увеличении нагрузки. Например, рост количества процессов в системе в два раза не должен приводить к увеличению полного времени выполнения процессов на порядок.

Многие из приведенных выше целей и свойств являются противоречивыми. Улучшая работу алгоритма с точки зрения одного критерия, мы ухудшаем ее с точки зрения другого. Приспосабливая алгоритм под один класс задач, мы тем самым дискриминируем задачи другого класса.

### Параметры планирования

Все параметры планирования можно разбить на две большие группы: статические параметры и динамические параметры. **Статические параметры** не изменяются в ходе функционирования вычислительной системы, **динамические** — подвержены постоянным изменениям.

К статическим параметрам вычислительной системы можно отнести **предельные значения ее ресурсов** (размер оперативной памяти, максимальное количество памяти на диске для осуществления свопинга, количество подключенных устройств ввода-вывода и т. п.). Динамические параметры системы описывают количество свободных ресурсов на данный момент.

К статическим параметрам процессов относятся характеристики, как правило присущие заданиям уже на этапе загрузки.
- Каким пользователем запущен процесс или сформировано задание.
- Насколько важной является поставленная задача, т. е. каков приоритет ее выполнения.
- Сколько процессорного времени запрошено пользователем для решения задачи.
- Каково соотношение процессорного времени и времени, необходимого для осуществления операций ввода-вывода.
- Какие ресурсы вычислительной системы (оперативная память, устройства ввода-вывода, специальные библиотеки и системные программы и т. д.) и в каком количестве необходимы заданию.

Алгоритмы **долгосрочного планирования** используют статические и динамические параметры вычислительной системы и статические параметры.

Алгоритмы **краткосрочного и среднесрочного планирования** дополнительно учитывают и динамические характеристики процессов. Для среднесрочного планирования в качестве таких характеристик может использоваться следующая информация:
- сколько времени прошло с момента выгрузки процесса на диск или его загрузки в оперативную память;
- сколько оперативной памяти занимает процесс;
- сколько процессорного времени уже предоставлено процессу.

<iframe
  src="https://viewer.diagrams.net/?highlight=0000ff&layers=1&nav=1&title=Diagram#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1MsU8XwFYgKl1PmvbRTbm63SBcZTv7A6L%26export%3Ddownload"
  width="100%"
  height="600px"
  frameborder="0"
  allowfullscreen
></iframe>

<!--https://drive.google.com/file/d/1MsU8XwFYgKl1PmvbRTbm63SBcZTv7A6L/view?usp=sharing-->

*Фрагмент деятельности процесса с выделением промежутков непрерывного использования процессора и ожидания ввода-вывода*

Для краткосрочного планирования нам понадобится ввести еще два динамических параметра. Деятельность любого процесса можно представить как последовательность циклов использования процессора и ожидания завершения операций ввода-вывода. Промежуток времени **непрерывного использования процессора** носит название **CPU burst**, а промежуток времени **непрерывного ожидания ввода-вывода — I/O burst**. Значения продолжительности последних и очередных CPU burst и I/O burst являются важными динамическими параметрами процесса.

### Вытесняющее и невытесняющее планирование

Процесс планирования осуществляется частью операционной системы, называемой **планировщиком**.

Планировщик может принимать решения о выборе для исполнения нового процессора из числа находящихся в состоянии готовность в следующих четырех случаях:

1. Когда процесс переводится из состояния исполнение в состояние закончил исполнение.
2. Когда процесс переводится из состояния исполнение в состояние ожидание.
3. Когда процесс переводится из состояния исполнение в состояние готовность (например, после прерывания от таймера).
4. Когда процесс переводится из состояния ожидание в состояние готовность (завершилась операция ввода-вывода или произошло другое событие).

В случаях 1 и 2 процесс, находившийся в состоянии исполнение, не может дальше исполняться, и операционная система вынуждена осуществлять планирование, выбирая новый процесс для выполнения. В случаях 3 и 4 планирование может как проводиться, так и не проводиться, планировщик не вынужден обязательно принимать решение о выборе процесса для выполнения, процесс, находившийся в состоянии исполнение, может просто продолжить свою работу.

**Невытесняющее планирование** — планирование осуществляется только в вынужденных ситуациях. Процесс занимает столько процессорного времени, сколько ему необходимо. При этом переключение процессов возникает только при желании самого исполняющегося процесса передать управление (для ожидания завершения операции ввода-вывода или по окончании работы). Однако возникает проблема возможности полного захвата процессора одним процессом, который вследствие каких-либо причин (например, из-за ошибки в программе) зацикливается и не может передать управление другому процессу. В такой ситуации спасает только перезагрузка всей вычислительной системы.

Если планировщик принимает и вынужденные, и невынужденные решения, говорят о **вытесняющем (preemptive)** планировании. Термин «вытесняющее планирование» возник потому, что исполняющийся процесс помимо своей воли может быть вытеснен из состояния исполнение другим процессом. **Вытесняющее планирование** обычно используется в системах разделения времени. В этом режиме планирования процесс может быть приостановлен в любой момент исполнения. Операционная система устанавливает специальный таймер для генерации сигнала прерывания по истечении некоторого интервала времени — кванта. После прерывания процессор передается в распоряжение следующего процесса. Временные прерывания помогают гарантировать приемлемое время отклика процессов для пользователей, работающих в диалоговом режиме, и предотвращают «зависание» компьютерной системы из-за зацикливания какой-либо программы.

### Алгоритмы планирования

Рассмотрим простейшие алгоритмы планирования.

#### First-Come, First-Served (FCFS)

Представим себе, что процессы, находящиеся в состоянии готовность, выстроены в очередь.

Когда процесс переходит в состояние готовность, он, а точнее, ссылка на его PCB помещается в конец этой очереди. Выбор нового процесса для исполнения осуществляется из начала очереди с удалением оттуда ссылки на его PCB. Очередь подобного типа имеет в программировании специальное наименование — FIFO (First In, First Out — первым вошел, первым вышел).

Такой алгоритм выбора процесса осуществляет невытесняющее планирование. Процесс, получивший в свое распоряжение процессор, занимает его до истечения текущего CPU burst. После этого для выполнения выбирается новый процесс из начала очереди.

Процесс    | Продолжительность очередного CPU burst
-----------|---------------------------------------
p0         | 13
p1         | 4
p2         | 1

Преимуществом алгоритма FCFS является легкость его реализации, но в то же время он имеет и много недостатков. Рассмотрим следующий пример. Пусть в состоянии готовность находятся три процесса p0, p1 и p2, для которых известны времена их очередных CPU burst. Эти времена приведены в таблице выше в некоторых условных единицах. Для простоты будем полагать, что вся деятельность процессов ограничивается использованием только одного промежутка CPU burst, что процессы не совершают операций ввода-вывода и что время переключения контекста так мало, что им можно пренебречь. Если процессы расположены в очереди процессов, готовых к исполнению, в порядке p0, p1, p2, то картина их выполнения выглядит так, как показано на рисунке ниже.

Вот как можно представить вашу информацию в виде таблицы в стиле GitHub Markdown:


| Время | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
|-------|---|---|---|---|---|---|---|---|---|---|----|----|----|----|----|----|----|----|
| p0    | И | И | И | И | И | И | И | И | И | И | И  | И  | И  |    |    |    |    |    |
| p1    |   |   |   |   |   |   |   |   |   |   |    |    |    |  И |  И | И  | И  |    |
| p2    |   |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    | И  |

*Выполнение процессов при порядке p0, p1, p2*

Первым для выполнения выбирается процесс p0, который получает процессор на все время своего CPU burst, т. е. на 13 единиц времени. После его окончания в состояние исполнение переводится процесс p1, он занимает процессор на 4 единицы времени. И, наконец, возможность работать получает процесс p2. Время ожидания для процесса p0 составляет 0 единиц времени, для процесса p1 — 13 единиц, для процесса p2 — $13 + 4 = 17$ единиц. Таким образом, среднее время ожидания в этом случае — $(0 + 13 + 17)/3 = 10$ единиц времени. Полное время выполнения для процесса p0 составляет 13 единиц времени, для процесса p1 — $13 + 4 = 17$ единиц, для процесса p2 — $13 + 4 + 1 = 18$ единиц. Среднее полное время выполнения оказывается равным $(13 + 17 + 18)/3 = 16$ единицам времени.

Если те же самые процессы расположены в порядке p2, p1, p0, то картина их выполнения будет соответствовать рисунку ниже.

| Время | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
|-------|---|---|---|---|---|---|---|---|---|---|----|----|----|----|----|----|----|----|
| p2    | И |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |
| p1    |   | И | И | И | И |   |   |   |   |   |    |    |    |    |    |    |    |    |
| p0    |   |   |   |   |   | И | И | И | И | И | И  | И  | И  | И  | И  | И  | И  | И  |

*Выполнение процессов при порядке p2, p1, p0*

Время ожидания для процесса p0 равняется 5 единицам времени, для процесса p1 — 1 единице, для процесса p2 — 0 единиц. Среднее время ожидания составит $(5 + 1 + 0)/3 = 2$ единицы времени. Это в 5 (!) раз меньше, чем в предыдущем случае. Полное время выполнения для процесса p0 получается равным 18 единицам времени, для процесса p1 — 5 единицам, для процесса p2 — 1 единице. Среднее полное время выполнения составляет $(18 + 5 + 1)/3 = 8$ единиц времени, что почти в 2 раза меньше, чем при первой расстановке процессов.

Как мы видим, среднее время ожидания и среднее полное время выполнения для этого алгоритма существенно зависят от порядка расположения процессов в очереди. Если у нас есть процесс с длительным CPU burst, то короткие процессы, перешедшие в состояние готовность после длительного процесса, будут очень долго ждать начала выполнения. **Поэтому алгоритм FCFS практически неприменим для систем разделения времени — слишком большим получается среднее время отклика в интерактивных процессах.**

#### Round Robin (RR)

Модификацией алгоритма FCFS является алгоритм, получивший название Round Robin или сокращенно RR. По сути дела, это тот же самый алгоритм, только реализованный в режиме вытесняющего планирования. Каждый процесс находится около процессора небольшой фиксированный квант времени, обычно 10 — 100 миллисекунд. Пока процесс находится рядом с процессором, он получает процессор в свое распоряжение и может исполняться.

<iframe
  src="https://viewer.diagrams.net/?highlight=0000ff&layers=1&nav=1&title=Diagram#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1IcEU__1MZ8lRRqNxbmyLsSf3hxsfP7qB%26export%3Ddownload"
  width="100%"
  height="400px"
  frameborder="0"
  allowfullscreen
></iframe>

<!--https://drive.google.com/file/d/1IcEU__1MZ8lRRqNxbmyLsSf3hxsfP7qB/view?usp=sharing-->
*Процессы на карусели*

При выполнении процесса возможны два варианта:
- Время непрерывного использования процессора, необходимое процессу (остаток текущего CPU burst), меньше или равно продолжительности кванта времени. Тогда процесс по своей воле освобождает процессор до истечения кванта времени, на исполнение поступает новый процесс из начала очереди, и таймер начинает отсчет кванта заново.
- Продолжительность остатка текущего CPU burst процесса больше, чем квант времени. Тогда по истечении этого кванта процесс прерывается таймером и помещается в конец очереди процессов, готовых к исполнению, а процессор выделяется для использования процессу, находящемуся в ее начале.

Рассмотрим предыдущий пример с порядком процессов p0, p1, p2 и величиной кванта времени равной 4. Выполнение этих процессов иллюстрируется таблицей ниже. Обозначение «И» используется в ней для процесса, находящегося в состоянии исполнение, обозначение «Г» — для процессов в состоянии готовность, пустые ячейки соответствуют завершившимся процессам. Состояния процессов показаны на протяжении соответствующей единицы времени, т. е. колонка с номером 1 соответствует промежутку времени от 0 до 1.

| Время | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 |
|-------|---|---|---|---|---|---|---|---|---|----|----|----|----|----|----|----|----|----|
| p0    | И | И | И | И | Г | Г | Г | Г | Г | И  | И  | И  | И  | И  | И  | И  | И  | И  |
| p1    | Г | Г | Г | Г | И | И | И | И |   |    |    |    |    |    |    |    |    |    |
| p2    | Г | Г | Г | Г | Г | Г | Г | Г | И |    |    |    |    |    |    |    |    |    |

Первым для исполнения выбирается процесс p0. Продолжительность его CPU burst больше, чем величина кванта времени, и поэтому процесс исполняется до истечения кванта, т. е. в течение 4 единиц времени. После этого он помещается в конец очереди готовых к исполнению процессов, которая принимает вид p1, p2, p0. Следующим начинает выполняться процесс p1. Время его исполнения совпадает с величиной выделенного кванта, поэтому процесс работает до своего завершения. Теперь очередь процессов в состоянии готовность состоит из двух процессов, p2 и p0. Процессор выделяется процессу p2. Он завершается до истечения отпущенного ему процессорного времени, и очередные кванты отмеряются процессу p0 — единственному не закончившему к этому моменту свою работу. Время ожидания для процесса p0 (количество символов «Г» в соответствующей строке) составляет 5 единиц времени, для процесса p1 – 4 единицы времени, для процесса p2 – 8 единиц времени. Таким образом, среднее время ожидания для этого алгоритма получается равным $(5 + 4 + 8)/3 = 5,6(6)$ единицы времени. Полное время выполнения для процесса p0 (количество непустых столбцов в соответствующей строке) составляет 18 единиц времени, для процесса p1 – 8 единиц, для процесса p2 – 9 единиц. Среднее полное время выполнения оказывается равным $(18 + 8 + 9)/3 = 11,6(6)$ единицы времени.

Легко увидеть, что среднее время ожидания и среднее полное время выполнения для обратного порядка процессов не отличаются от соответствующих времен для алгоритма FCFS и составляют 2 и 6 единиц времени соответственно.

На производительность алгоритма RR сильно влияет величина кванта времени. Рассмотрим тот же самый пример с порядком процессов p0, p1, p2 для величины кванта времени, равной 1. Время ожидания для процесса p0 составит 5 единиц времени, для процесса p1 – тоже 5 единиц, для процесса p2 – 2 единицы. В этом случае среднее время ожидания получается равным $(5 + 5 + 2)/3 = 4$ единицам времени. Среднее полное время исполнения составит $(18 + 9 + 3)/3 = 10$ единиц времени.

| Время | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 |
|-------|---|---|---|---|---|---|---|---|---|----|----|----|----|----|----|----|----|----|
| p0    | И | Г | Г | И | Г | И | Г | И | Г | И  | И  | И  | И  | И  | И  | И  | И  | И  |
| p1    | Г | И | Г | Г | И | Г | И | Г | И |    |    |    |    |    |    |    |    |    |
| p2    | Г | Г | И |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |

При очень больших величинах кванта времени, когда каждый процесс успевает завершить свой CPU burst до возникновения прерывания по времени, алгоритм RR вырождается в алгоритм FCFS. При очень малых величинах создается иллюзия того, что каждый из n процессов работает на собственном виртуальном процессоре с производительностью ~1/n от производительности реального процессора. Правда, это справедливо лишь при теоретическом анализе при условии пренебрежения временами переключения контекста процессов. В реальных условиях при слишком малой величине кванта времени и, соответственно, слишком частом переключении контекста накладные расходы на переключение резко снижают производительность системы.

::: info Заметка о планировщике в Linux
https://habr.com/ru/articles/807645/

![](https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/Simplified_Structure_of_the_Linux_Kernel.svg/2880px-Simplified_Structure_of_the_Linux_Kernel.svg.png)

[Completely Fair Scheduler (CFS)](https://en.wikipedia.org/wiki/Completely_Fair_Scheduler) — это основной планировщик задач в ядре Linux, внедрённый в 2007 году (начиная с версии 2.6.23) для замены устаревшего O(1) Scheduler. Его ключевая цель — обеспечение «справедливого» распределения процессорного времени между всеми задачами, минимизируя задержки и предотвращая «голодание» процессов. В отличие от предшественников, CFS не использует фиксированные кванты времени, а ориентируется на понятие виртуального времени (vruntime), которое увеличивается пропорционально фактическому времени выполнения задачи. Планировщик выбирает для исполнения процесс с наименьшим vruntime, что гарантирует баланс между интерактивными (требующими быстрого отклика) и фоновыми задачами. Для эффективного поиска подходящего процесса CFS применяет **красно-чёрное дерево**, а приоритеты задач регулируются через веса (nice values), позволяя более важным процессам получать большую долю CPU. Этот подход делает систему отзывчивой и масштабируемой, особенно в условиях многозадачности и на многопроцессорных системах.
:::

Остальные алогиртмы будут рассмотрены в самостоятельной работе 2