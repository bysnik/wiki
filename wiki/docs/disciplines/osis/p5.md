### Практическая работа по теме:  
**"Подсистемы управления вводом/выводом Linux"**  
*Для выполнения требуется доступ к Linux (рекомендуется использовать виртуальную машину или тестовый сервер).*

---

## Блок теории (краткое резюме предыдущего занятия)

### Основные принципы организации ввода-вывода в Linux
1. **Физические принципы**:  
   - Жесткие диски (HDD) состоят из пластин, головок, цилиндров и секторов.  
   - Доступ к данным требует перемещения головки (seek time) и ожидания поворота диска (rotational latency).  
   - SSD не имеют механических частей, поэтому seek time и rotational latency отсутствуют.

2. **Логические принципы**:  
   - Ядро Linux использует **блочную подсистему** для работы с устройствами.  
   - Запросы к дискам обрабатываются через **очереди запросов** (request queue), где они сортируются и объединяются.  
   - **VFS (Virtual File System)** абстрагирует файловые системы, предоставляя единый интерфейс для приложений.

3. **Алгоритмы планирования запросов**:  
   - **CFQ (Completely Fair Queuing)**: Распределяет квоты времени между процессами для "справедливого" доступа к диску. Подходит для HDD.  
   - **Deadline**: Гарантирует обработку запросов в течение заданного времени (deadline), минимизируя голодание процессов. Оптимален для серверов.  
   - **NOOP**: Простая FIFO-очередь без сортировки. Используется для SSD или виртуальных дисков (меньше накладных расходов).  
   - **kyber/mq-deadline**: Современные планировщики для многопоточных систем (актуально для новых ядер Linux).

4. **Пути в sysfs**:  
   Параметры подсистемы ввода-вывода настраиваются через виртуальную файловую систему `/sys/block/`.

---

## Практическая часть  
*Преподаватель демонстрирует действия, студенты повторяют в своих терминалах.*

---

### Задание 1. Просмотр текущего планировщика ввода-вывода
**Цель**: Узнать, какой планировщик используется для диска.

#### Шаги:
1. Определите имя диска (обычно `sda`, `nvme0n1`):  
   ```bash
   lsblk
   ```
   *Пример вывода:*  
   ```
   NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
   sda           8:0    0   100G  0 disk 
   ├─sda1        8:1    0   512M  0 part /boot
   └─sda2        8:2    0  99.5G  0 part /
   ```

2. Проверьте текущий планировщик для диска `sda`:  
   ```bash
   cat /sys/block/sda/queue/scheduler
   ```
   *Пример вывода:*  
   ```
   [mq-deadline] kyber bfq none
   ```
   - Квадратные скобки `[ ]` указывают активный планировщик.

#### Вопрос для студентов:  
> Почему для SSD рекомендуется использовать `NOOP` или `mq-deadline`, а не `CFQ`?

---

### Задание 2. Смена планировщика ввода-вывода
**Цель**: Изменить планировщик на `deadline` и проверить результат.

#### Шаги:
1. Установите планировщик `deadline` для диска `sda`:  
   ```bash
   echo deadline | sudo tee /sys/block/sda/queue/scheduler
   ```
   *Примечание:* Требуются права `root`.

2. Убедитесь, что планировщик изменился:  
   ```bash
   cat /sys/block/sda/queue/scheduler
   ```
   *Ожидаемый вывод:*  
   ```
   [deadline] mq-deadline kyber bfq none
   ```

#### Важно!  
- Для SSD смена на `noop` может улучшить производительность:  
  ```bash
  echo noop | sudo tee /sys/block/sda/queue/scheduler
  ```

---

### Задание 3. Мониторинг активности диска с помощью `iostat`
**Цель**: Анализировать статистику ввода-вывода в реальном времени.

#### Шаги:
1. Установите утилиту `sysstat` (если не установлена):  
   ```bash
   sudo apt install sysstat  # Для Debian/Ubuntu
   ```

2. Запустите мониторинг каждые 2 секунды:  
   ```bash
   iostat -x 2
   ```
   *Ключевые параметры:*  
   - `%util` — загрузка диска (100% = дисковый ствол).  
   - `await` — среднее время ожидания запроса (мс).  
   - `svctm` — среднее время обслуживания запроса (мс).

3. Выполните операцию с диском (например, копирование файла) и наблюдайте за изменениями:  
   ```bash
   dd if=/dev/zero of=testfile bs=1G count=1
   ```

#### Вопрос для студентов:  
> Как изменятся значения `await` и `%util` при использовании `deadline` по сравнению с `cfq`?

---

### Задание 4. Анализ параметров очереди запросов
**Цель**: Изучить настройки очереди ввода-вывода.

#### Шаги:
1. Просмотрите максимальный размер очереди (в секторах):  
   ```bash
   cat /sys/block/sda/queue/max_sectors_kb
   ```

2. Узнайте текущую глубину очереди:  
   ```bash
   cat /sys/block/sda/queue/nr_requests
   ```

3. Проверьте время "ожидания" для планировщика `deadline`:  
   ```bash
   cat /sys/block/sda/queue/iosched/read_expire
   cat /sys/block/sda/queue/iosched/write_expire
   ```
   *По умолчанию:*  
   - `read_expire = 100` мс (макс. задержка для чтения),  
   - `write_expire = 5000` мс (макс. задержка для записи).

#### Эксперимент:  
- Увеличьте `read_expire` до 500 мс и сравните задержки при чтении:  
  ```bash
  echo 500 | sudo tee /sys/block/sda/queue/iosched/read_expire
  ```

---

### Задание 5. Тест производительности с разными планировщиками (опционально)
**Цель**: Сравнить скорость работы диска с `deadline` и `noop`.

#### Шаги:
1. Установите утилиту `fio` (Flexible I/O Tester):  
   ```bash
   sudo apt install fio
   ```

2. Запустите тест с планировщиком `deadline`:  
   ```bash
   fio --name=randread --ioengine=libaio --rw=randread --bs=4k --numjobs=4 --size=256M --runtime=30 --time_based --group_reporting
   ```

3. Повторите тест для `noop` (предварительно сменив планировщик, см. Задание 2).

4. Сравните результаты (IOPS, latency).

---

## Контрольные вопросы
1. Какой планировщик лучше использовать для HDD в системе с высокой нагрузкой на запись?  
   **Ответ**: `deadline` (минимизирует задержки для записи).

2. Почему для SSD не рекомендуется использовать `cfq`?  
   **Ответ**: `cfq` оптимизирован для HDD, из-за ненужной сортировки запросов снижает производительность SSD.

3. Как проверить, поддерживает ли ваше устройство многопоточную очередь (multiqueue)?  
   **Ответ**:  
   ```bash
   ls /sys/block/sda/mq
   ```
   Если каталог существует — поддерживается.

---

## Рекомендации
- Все изменения в `/sys/block/` **временные** (сбрасываются после перезагрузки). Для постоянной настройки используйте `udev`-правила или параметры ядра в `/etc/default/grub`.
- При работе с реальными серверами тестируйте планировщики в нерабочее время.

**Готово!** После выполнения работы студенты должны понимать, как управлять подсистемой ввода-вывода Linux и выбирать оптимальные настройки для разных типов дисков.