---
outline: deep
---

# Практическая работа №1  
**Тема:** Ядерные и внеядерные компоненты Linux  
**Цель работы:** Научиться различать ядерные и внеядерные компоненты операционной системы Linux, изучить их взаимодействие через практические примеры.  


## Инструкция по выполнению работы  
*Преподаватель демонстрирует каждый шаг, студенты повторяют команды в терминале и фиксируют результаты.*

::: tip Пояснение
Архитектура Linux построена на принципе разделения пространства ядра (kernel space) и пользовательского пространства (user space). Ядро — это центральный компонент, который напрямую взаимодействует с аппаратным обеспечением. Все остальное — приложения, оболочки, сервисы — работают во внеядерном (пользовательском) пространстве и обращаются к ядру через системные вызовы (system calls). Это разделение обеспечивает стабильность, безопасность и модульность системы.
:::

### **Шаг 1. Изучение информации о ядре Linux**  
**Цель:** Убедиться, что вы работаете с ядром Linux, и изучить его параметры.  

1. **Проверьте версию ядра:**  
```bash
uname -a
```
*Пример вывода:*  
`Linux altlinux 6.12.42-6.12-alt1 #1 SMP PREEMPT_DYNAMIC Tue Aug 26 13:33:43 UTC 2025 x86_64 GNU/Linux`  

::: tip Пояснение
Версия ядра следует схеме [семантического версионирования](https://semver.org/lang/ru/): `MAJOR.MINOR.PATCH`. Например, 5.15.0 означает:   
- 5 — основная версия (мажорная),  
- 15 — второстепенная (минорная), часто добавляет новые функции,  
- 0 — патч (исправления ошибок).
:::

2. **Посмотрите детали ядра через файловую систему `/proc`:**  
```bash
cat /proc/version
```
*Вывод:* Тот же, что и в `uname -a`, но в «сыром» виде.

`Linux version 6.12.42-6.12-alt1 (builder@localhost.localdomain) (gcc-13 (GCC) 13.2.1 20240128 (ALT Sisyphus 13.2.1-alt3), GNU ld (GNU Binutils) 2.41.0.20230826) #1 SMP PREEMPT_DYNAMIC Tue Aug 26 13:33:43 UTC 2025`  

::: warning Подробное пояснение вывода

#### 1. **`Linux version 6.12.42-6.12-alt1`**
- Это основная информация о версии ядра Linux.
- **`6.12.42`** — версия ядра Linux:
  - `6` — мажорная (основная) версия.
  - `12` — минорная (второстепенная) версия.
  - `42` — патч-уровень (ревизия, накопленные исправления).
- **`-6.12-alt1`** — суффикс, указывающий на специфику сборки:
  - Это **пакет ядра**, собранный для дистрибутива **ALT Linux**.
  - `alt1` — номер релиза пакета в репозитории ALT Linux.


#### 2. **`(builder@localhost.localdomain)`**
- Указывает на **пользователя и хост**, с которого была произведена сборка ядра.
- `builder` — имя пользователя (обычно это автоматизированный аккаунт сборки).
- `localhost.localdomain` — имя машины, где происходила компиляция (стандартное имя для сборочных систем).
- Это **не обязательно реальное имя хоста**, часто используется по умолчанию в автоматизированных средах.

#### 3. **`(gcc-13 (GCC) 13.2.1 20240128 (ALT Sisyphus 13.2.1-alt3)`**
- Информация о **компиляторе**, использованном для сборки ядра.
- **`gcc-13`** — версия GCC (GNU Compiler Collection), использованная для компиляции.
- **`13.2.1`** — конкретная версия GCC.
- **`20240128`** — дата сборки этого конкретного бинарника GCC.
- **`ALT Sisyphus 13.2.1-alt3`** — указывает, что это версия GCC, пакованная для дистрибутива **ALT Linux**, ветка **Sisyphus** (основной репозиторий пакетов).

#### 4. **`GNU ld (GNU Binutils) 2.41.0.20230826`**
- Указывает на **компоновщик (linker)**, использованный при сборке ядра.
- **`GNU ld`** — это стандартный компоновщик из пакета **GNU Binutils**.
- **`2.41.0.20230826`** — версия Binutils (дата указывает на момент сборки).
- Компоновщик отвечает за объединение объектных файлов в единый образ ядра.

#### 5. **`#1 SMP PREEMPT_DYNAMIC`**
- Это **тег сборки ядра**, содержит важные флаги конфигурации:
  - **`#1`** — номер сборки (в данном случае первая сборка с такими параметрами).
  - **`SMP`** — **Symmetric Multi-Processing**:
    - Ядро поддерживает многопроцессорные (или многоядерные) системы.
    - Может использовать несколько CPU/ядер одновременно.
  - **`PREEMPT_DYNAMIC`** — режим вытесняющего планирования:
    - Ядро поддерживает **динамическое вытеснение** (preemption).
    - Это компромисс между производительностью и латентностью: можно включать/выключать вытеснение в зависимости от нагрузки.
    - Более гибкий, чем `PREEMPT_NONE`, но не такой агрессивный, как `PREEMPT_FULL`.

#### 6. **`Tue Aug 26 13:33:43 UTC 2025`**
- **Дата и время сборки ядра**.
- Указывается в формате: день недели, месяц, число, время, часовой пояс, год.
- Здесь: **вторник, 26 августа 2025 года, 13:33:43 по UTC**.
:::

::: tip Пояснение
Файловая система `/proc` — это интерфейс ядра для пользовательского пространства. Она не хранит данные на диске, а генерируется ядром «на лету». Например, `/proc/cpuinfo` показывает информацию о процессоре, `/proc/meminfo` — о памяти. Это пример того, как ядро предоставляет свои данные через файловый интерфейс, что упрощает взаимодействие с пользовательскими программами.
:::

### **Шаг 2. Анализ загруженных модулей ядра**  
**Цель:** Увидеть, какие модули ядра активны в системе.  

1. **Список загруженных модулей:**  
```bash
lsmod
```
*Пример вывода:*  
```
Module                  Size  Used by
snd_hda_codec_generic    81920  1
...
```
**Пояснение:**  
- Модули ядра (например, `snd_hda_codec_generic` для звука) — это **ядерные компоненты**, расширяющие функционал ядра без перезагрузки.

::: tip Пояснение
Модули ядра — это динамически загружаемые компоненты, которые позволяют ядру оставаться компактным. Вместо того чтобы включать поддержку всех возможных устройств «навсегда», ядро загружает модули по мере необходимости (например, при подключении USB-устройства). Это называется динамической загрузкой модулей. Модули имеют расширение `.ko` (kernel object) и находятся в `/lib/modules/$(uname -r)/`.
:::

2. **Поиск конкретного модуля (например, связанного с сетью):**  
```bash
lsmod | grep net
```
::: tip Пояснение
Сетевые модули (например, `af_packet`, `nf_conntrack`) отвечают за обработку сетевых пакетов, работу с интерфейсами, NAT и т.д. Их наличие в `lsmod` означает, что соответствующие функции активны в ядре. Это показывает, как ядро масштабируется под задачи системы, загружая только нужные компоненты.
:::

### **Шаг 3. Исследование процессов ядра**  
**Цель:** Найти процессы, непосредственно связанные с ядром.  

1. **Просмотр всех процессов:**  
```bash
ps -ef
```
**Обратите внимание на процессы вида `[kthreadd]`, `[kworker/*]`:**  
- Это потоки ядра (kernel threads), управляющие задачами в фоне (например, обработка прерываний).  
- **Ядерный компонент:** Такие процессы не имеют PID в пользовательском пространстве и создаются самим ядром.

::: tip Пояснение
kthreadd — это родитель всех потоков ядра. Он запускается при загрузке и порождает другие ядерные потоки, такие как:   
- kworker/* — выполняют отложенные задачи (work queues),  
- migration/* — переносят процессы между CPU-ядрами,  
- ksoftirqd/* — обрабатывают программные прерывания.

Эти потоки не являются обычными процессами — они работают исключительно в пространстве ядра и не могут быть завершены пользователем.
     
:::

2. **Фильтрация процессов ядра:**  
```bash
ps -ef | grep "\[.*\]"
```

*Вывод:* Список процессов в квадратных скобках — это внутренние задачи ядра.

::: tip Пояснение
Квадратные скобки [...] в выводе `ps` — это визуальный индикатор того, что процесс является внутренним потоком ядра. Система не создаёт для них реальных исполняемых файлов — они существуют только в памяти. Это отличает их от пользовательских процессов, которые всегда связаны с исполняемым файлом (например, `/usr/bin/firefox`).
:::

### **Шаг 4. Изучение внеядерных компонентов**  
**Цель:** Определить компоненты, работающие в пользовательском пространстве.  

1. **Просмотр установленных пакетов (пакетный менеджер):**  
```bash
dpkg -l | head -n 10  # Для Ubuntu/Debian
# Или
rpm -qa | head -n 10   # Для CentOS/RHEL/ALT
```
**Пояснение:**  
- Пакеты (например, `bash`, `nginx`, `firefox`) — это **внеядерные компоненты**.  
- Они работают в пользовательском пространстве и взаимодействуют с ядром через системные вызовы.

::: tip Пояснение
Пакетный менеджер (например, `dpkg`, `rpm`, `apt`, `yum`) — это инфраструктура управления внеядерными компонентами. Он отслеживает, какие программы установлены, их зависимости и версии. Эти компоненты не являются частью ядра, но критически важны для функциональности системы. Например, `bash` — это просто программа, как и любой другой бинарник, но она предоставляет интерфейс для взаимодействия с ОС.
:::

2. **Просмотр активных сервисов (демонов):**  
```bash
systemctl list-units --type=service --state=running
```
*Пример вывода:*  
```
UNIT                     LOAD   ACTIVE SUB     DESCRIPTION
ssh.service              loaded active running OpenBSD Secure Shell server
...
```
**Пояснение:**  
- Сервисы (демоны) — внеядерные компоненты, управляющие фоновыми задачами (например, веб-сервер, SSH).

::: tip Пояснение
Демоны — это внеядерные процессы, которые запускаются при загрузке или по требованию. Они работают в фоне и предоставляют сетевые или системные услуги. Например, `sshd` слушает порт 22 и обрабатывает входящие SSH-подключения. Он взаимодействует с ядром через системные вызовы (например, `socket()`, `bind()`, `accept()`), чтобы работать с сетью.
:::

3. **Проверка оболочки (shell):**  
```bash
echo $SHELL
```

*Вывод:* `/bin/bash` — путь к оболочке, которая является **внеядерным компонентом**.

::: tip Пояснение
Оболочка (shell) — это пользовательская программа, которая интерпретирует команды. Она не является частью ядра, хотя и кажется «фундаментальной». Например, `bash` можно удалить и заменить на `zsh` или `fish` — система продолжит работать. Shell использует системные вызовы (`fork`, `exec`, `read`, `write`) для выполнения команд и взаимодействия с ядром.
:::

### **Шаг 5. Сравнение ядерных и внеядерных компонентов**  
**Цель:** Систематизировать полученные данные.  

1. **Заполните таблицу в тетради:**  

   | Компонент          | Пример                  | Принадлежность       | Как проверить?         |
   |--------------------|-------------------------|----------------------|------------------------|
   | Ядерный            | Модуль `snd_hda_codec`  | Ядро                 | `lsmod`                |
   | Внеядерный         | Сервис `ssh.service`    | Пользовательское пространство | `systemctl` |
   | Ядерный            | Процесс `[kworker/0:1]` | Ядро                 | `ps -ef`               |
   | Внеядерный         | Оболочка `bash`         | Пользовательское пространство | `echo $SHELL` |

2. **Вывод:**  
- Ядро — «мозг» системы, отвечающий за управление ресурсами.  
- Внеядерные компоненты (пакеты, сервисы, оболочки) предоставляют пользователю функционал, но зависят от ядра.

::: tip Пояснение
Важно понимать, что разделение на ядро и пользовательское пространство — это не просто классификация, а архитектурный принцип безопасности и стабильности. Если программа в пользовательском пространстве «падает», это не приводит к краху всей системы. Но если падает ядро — система зависает (BSOD в Windows, kernel panic в Linux). Поэтому критически важные функции (управление памятью, планирование процессов) остаются в ядре, а всё остальное — «снаружи».
:::

### **Шаг 6. Изучение вывода htop**
1. Установите новый пакет (например, `htop`):  
```bash
apt-get install htop
```
2. Запустите его и сравните процессы, отображаемые в `htop` и `ps -ef`.  
3. Объясните, к какой категории (ядерные/внеядерные) относится `htop`.

::: tip Пояснение
Установка `htop` — хороший пример того, как внеядерный компонент может отображать информацию о ядре. `htop` читает данные из `/proc` и `/sys` — виртуальных файловых систем, предоставляемых ядром. Он не «видит» ядро напрямую, а интерпретирует его данные, как и любой другой пользовательский процесс. Это иллюстрирует, как пользовательское пространство «наблюдает» за ядром через стандартизированные интерфейсы.
:::

::: info Шпаргалка по `htop`
#### 1. Запуск htop

Просто введите в терминале:
```bash
htop
```

> Для просмотра всех процессов (включая чужие) может потребоваться `sudo`:
```bash
sudo htop
```

---

#### 2. Интерфейс htop

После запуска вы увидите:

##### Верхняя часть (панель ресурсов):
- **CPU**: использование каждого ядра (в процентах и графически).
- **Mem**: использование оперативной памяти.
- **Swp**: использование swap-раздела.

> Цвета:
- Синий — низкоприоритетные задачи (nice)
- Зелёный — пользовательские процессы
- Красный — системные процессы
- Жёлтый — время ожидания ввода/вывода (iowait)

---

##### Средняя часть (список процессов):
Колонки по умолчанию:
- **PID** — идентификатор процесса
- **USER** — владелец процесса
- **PRI** — приоритет
- **NI** — nice-значение (приоритет планировщика)
- **VIRT** — виртуальная память
- **RES** — физическая память (резидентная)
- **SHR** — разделяемая память
- **S** — состояние (R=работает, S=спит, Z=зомби, D=ожидание I/O)
- **CPU%** — загрузка CPU
- **MEM%** — использование памяти
- **TIME+** — общее время работы процесса
- **Command** — команда/имя процесса

---

#### 3. Управление с помощью клавиатуры

| Клавиша | Действие |
|--------|--------|
| **↑ / ↓**, **Page Up / Page Down** | Прокрутка списка процессов |
| **F1** | Помощь (Help) — подробная справка по всем клавишам |
| **F2** | Настройки (Setup) — настройка отображения |
| **F3** | Поиск процесса по имени |
| **F4** | Фильтр — показывать только процессы, содержащие введённую строку |
| **F5** | Режим дерева — отображение процессов в виде дерева (с учётом родительских процессов) |
| **F6** | Сортировка — выбрать колонку для сортировки (например, по CPU%, MEM%, PID и т.д.) |
| **F7** | Уменьшить приоритет (Nice --) |
| **F8** | Увеличить приоритет (Nice ++) |
| **F9** | Отправить сигнал процессу (например, SIGKILL для завершения) |
| **F10** | Выход из htop |
| **Space** | Пометить/снять пометку с процесса (для массовых действий) |
| **u** | Показать только процессы определённого пользователя |
| **k** | Показать/скрыть названия сигналов (в режиме отправки сигнала) |
| **H** | Включить/выключить отображение потоков (threads) |
| **U** | Снять пометки со всех процессов |
| **l** | Показать открытые файлы процесса (через `lsof`) |
| **i** | Показать/скрыть задержку ввода-вывода (iowait) на графике CPU |

---

#### 4. Полезные настройки (F2 — Setup)

##### Вкладки:
- **[Display options]** — отображение:
  - `Hide kernel threads` — скрыть системные потоки (начинающиеся с `kthreadd`, `kworker`)
  - `Hide userland process threads` — не показывать потоки пользовательских процессов
  - `Show custom thread names` — показывать имена потоков
  - `Highlight changes` — подсвечивать изменения при обновлении
- **[Colors]** — выбрать цветовую схему (напр., black on white, blue, green и т.п.)
- **[Fields]** — выбрать, какие колонки отображать в списке процессов

---

#### 5. Поиск и фильтрация

- **F3** → введите имя процесса (например, `firefox`) — htop найдёт и подсветит.
- **F4** → введите строку — останутся только процессы, содержащие её в команде.
- Чтобы сбросить фильтр — нажмите **F4**, затем **Backspace** и **Enter**.

---

#### 6. Управление процессами

##### Завершение процесса:
1. Выделите нужный процесс стрелками.
2. Нажмите **F9**.
3. Выберите сигнал:
   - `SIGTERM` (15) — вежливое завершение (рекомендуется).
   - `SIGKILL` (9) — принудительное уничтожение (если процесс не отвечает).
4. Нажмите **Enter**.

> Можно пометить несколько процессов через **Пробел**, затем применить сигнал ко всем.

---

#### 7. Сортировка

- Нажмите **F6**.
- Выберите колонку для сортировки:
  - `CPU%` — по загрузке процессора
  - `MEM%` — по использованию памяти
  - `TIME+` — по времени работы
  - `PID` — по номеру процесса
- Сортировка обновляется в реальном времени.

---

#### 8. Режим дерева (F5)

- Включает древовидное отображение: дочерние процессы показываются под родительскими.
- Удобно для анализа, какие процессы порождены другими (например, скрипты, сервисы, оболочки).

---

#### 9. Полезные советы

- Запускайте `htop` с `sudo`, чтобы видеть все процессы.
- Используйте `htop --no-color` — если терминал некорректно отображает цвета.
- Можно запустить `htop` и оставить его работать в фоне, например, в `tmux` или `screen`.
- Чтобы быстро найти "тяжёлые" процессы — сортируйте по `CPU%` или `MEM%`.

---

#### 10. Примеры использования

##### Показать только процессы пользователя `alex`:
```bash
htop -u alex
```

##### Отсортировать по памяти при запуске:
(в htop нажмите F6 → MEM%)

##### Запустить в режиме дерева:
```bash
htop -t
```

**Совет:** Нажмите **F1**, чтобы всегда иметь под рукой полную справку!

:::

### Контрольные вопросы
1. Какая команда покажет версию ядра Linux?  
2. Почему процессы в квадратных скобках (например, `[kthreadd]`) считаются ядерными?  
3. Приведите 3 примера внеядерных компонентов и объясните их назначение.  
4. Как проверить, какие модули ядра используются для работы Wi-Fi?  


### Требования к отчету
1. Скриншоты выполнения ключевых команд.  
2. Заполненная таблица из Шага 5.  
3. Ответы на контрольные вопросы.  

::: tip Пояснение
При оформлении отчета обратите внимание: скриншоты должны отражать не только результат, но и контекст. Например, если вы показываете `lsmod`, полезно добавить пояснение: «Этот модуль отвечает за X и был загружен автоматически при обнаружении устройства Y». Это покажет понимание, а не просто копирование вывода.
:::

**Примечание:** Эта работа закрепляет теорию архитектуры ОС, показывая разделение на ядро (монолитное ядро Linux) и пользовательское пространство (POSIX-совместимые утилиты, демоны).

::: warning Выводы
Linux использует монолитное ядро, но с поддержкой модулей — это компромисс между производительностью (все в одном адресном пространстве) и гибкостью (возможность загружать компоненты динамически). В отличие от микроядер (например, в системах на базе Mach), где многие компоненты работают во внеядерном пространстве, Linux держит большую часть драйверов и подсистем внутри ядра, что даёт высокую производительность, но требует большей осторожности при разработке. 
:::