# **Практическая работа №3**  
## **Тема: Исследование структуры памяти процесса и виртуальной памяти в Linux**

**Цель работы:**  
Научиться анализировать структуру виртуального адресного пространства процесса, изучить основные компоненты памяти процесса, понять принципы отображения виртуальной памяти на физическую, а также познакомиться с инструментами анализа потребления памяти в Linux.

**Оборудование и программное обеспечение:**  
- Компьютер с ОС Linux (рекомендуется Ubuntu/Debian/Fedora)  
- Терминал  
- Утилиты: `pmap`, `cat /proc/<PID>/maps`, `vmstat`, `free`, `ps`, `top`, `lscpu`  
- Язык программирования C (для компиляции простого тестового приложения)

---

## **Часть 1: Подготовка — анализ физической и виртуальной памяти системы**

### **Шаг 1.1: Изучение параметров памяти системы**
Преподаватель демонстрирует, студенты повторяют.

```bash
# Просмотр информации о процессоре (размер страницы)
lscpu | grep "Page size"

# Просмотр объёма оперативной памяти
free -h

# Просмотр использования памяти в реальном времени
vmstat -s | grep -i memory
```

**Вопрос для обсуждения:**  
> Какой стандартный размер страницы памяти в x86_64 системах? (Ответ: 4 КБ)

---

## **Часть 2: Запуск и анализ процесса**

### **Шаг 2.1: Создание простого C-приложения**
Создайте файл `mem_example.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int global_var = 42;  // Данные в секции .data

int main() {
    int local_var = 100;             // Стек
    static int static_var = 200;     // Секция .data
    char *heap_mem = malloc(1024);   // Куча

    printf("PID процесса: %d\n", getpid());
    printf("Адрес global_var: %p\n", &global_var);
    printf("Адрес local_var: %p\n", &local_var);
    printf("Адрес static_var: %p\n", &static_var);
    printf("Адрес в куче: %p\n", heap_mem);

    printf("Ожидание... (не закрывайте)\n");
    sleep(300);  // Задержка, чтобы посмотреть память
    return 0;
}
```

**Компиляция:**
```bash
gcc mem_example.c -o mem_example
```

**Запуск:**
```bash
./mem_example
```

> Запомните PID процесса (выводится в консоль).

---

### **Шаг 2.2: Анализ виртуального адресного пространства процесса**

#### **Использование `/proc/<PID>/maps`**

```bash
# Замените <PID> на реальный PID процесса
cat /proc/<PID>/maps
```

**Разбор вывода (преподаватель объясняет):**
- Адресные диапазоны: стек, куча, код, данные, библиотеки
- Флаги: `r` — чтение, `w` — запись, `x` — выполнение, `p` — частная, `s` — разделяемая
- Пример:
  ```
  555555559000-55555555a000 r--p 00000000 08:01 123456 /home/user/mem_example
  ```

**Задание студентам:**  
Найти в выводе:
- Сегмент кода (`.text`)
- Сегмент данных (`.data`)
- Кучу (heap)
- Стек (stack)
- Отображённые библиотеки (например, `libc`)

---

### **Шаг 2.3: Использование утилиты `pmap`**

```bash
pmap <PID>
```

**Объяснение:**  
Утилита показывает детализированное распределение памяти процесса: размер, типы отображений, anon (анонимная память), файлы.

**Задание:**  
Определите:
- Общий объём памяти процесса
- Размер анонимной памяти (куча, стек)
- Какие shared-объекты загружены?

---

## **Часть 3: Исследование виртуальной памяти и подкачки**

### **Шаг 3.1: Мониторинг использования памяти системой**

```bash
# Текущее состояние памяти
free -h

# Статистика по страницам памяти и подкачке
vmstat 1 5
```

**Объяснение полей:**
- `si` — свопинг (подкачка) в память (KB/s)
- `so` — выгрузка в своп (KB/s)
- Если `si` и `so` > 0 — активная подкачка

**Задание:**  
Запустите процесс, потребляющий много памяти (например, скрипт на Python, выделяющий массив), и понаблюдайте за `vmstat`.

---

### **Шаг 3.2: Анализ потребления памяти процессами**

```bash
# Топ процессов по потреблению памяти
top -o %MEM

# Или через ps
ps aux --sort=-%mem | head -10
```

**Вопрос:**  
> Почему виртуальная память (VSZ) может быть намного больше физической (RSS)?

**Ответ:**  
> VSZ — это виртуальное адресное пространство, включая неиспользуемые страницы, отображённые файлы, своп. RSS — реально загруженные в RAM страницы.

---

## **Часть 4: Отображение файлов в память (mmap)**

### **Шаг 4.1: Демонстрация mmap через /proc/maps**

Создайте файл:
```bash
echo "Hello, mmap!" > testfile.txt
```

Запустите программу, которая использует `mmap`, или просто откройте файл в редакторе (например, `vim testfile.txt`). Затем проверьте `/proc/<PID>/maps` — вы увидите отображение файла в память.

**Пример строки в maps:**
```
7f8a1c000000-7f8a1c001000 r--p 00000000 08:01 123456 /home/user/testfile.txt
```

**Объяснение:**  
Файл отображён в виртуальную память процесса. Чтение/запись идёт через страницы памяти, а не через системные вызовы `read/write`.

---

## **Часть 5: Заключение и вопросы**

### **Контрольные вопросы (для самопроверки):**
1. Что такое виртуальная память и зачем она нужна?
2. Как организована таблица страниц в x86_64?
3. Чем отличается RSS от VSZ?
4. Как работает отображение файлов в память (mmap)?
5. Для чего используется TLB (Translation Lookaside Buffer)?
6. Почему размер страницы обычно 4 КБ? Какие есть альтернативы (huge pages)?

---

## **Отчёт по работе (для студентов)**

Студенты должны подготовить краткий отчёт (1–2 страницы), включающий:
1. PID исследуемого процесса.
2. Скриншот или текст вывода `cat /proc/<PID>/maps`.
3. Выделение и описание основных секций памяти (стек, куча, код, данные).
4. Объём RSS и VSZ процесса (из `ps` или `top`).
5. Ответы на 2 контрольных вопроса по выбору.

---

## **Методические рекомендации преподавателю**

- Убедитесь, что все студенты могут запустить C-программу и получить PID.
- Контролируйте, чтобы студенты не закрывали процесс до завершения анализа.
- Поощряйте самостоятельный поиск: «Найдите в maps libc» или «Где находится стек?»
- Для продвинутых: можно показать `/proc/<PID>/smaps` — более детальную статистику по каждой области памяти.


---

**Итог:**  
Практическая работа позволяет закрепить теорию виртуальной памяти через реальные инструменты Linux, формируя у студентов понимание того, как ядро организует память процессов, использует страничное отображение и управляет ресурсами.

