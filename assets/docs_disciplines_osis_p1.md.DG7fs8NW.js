import{_ as t,c as i,o as a,ag as o}from"./chunks/framework.D4Vqf8I7.js";const g=JSON.parse('{"title":"Практическая работа №1","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"docs/disciplines/osis/p1.md","filePath":"docs/disciplines/osis/p1.md","lastUpdated":1761114217000}'),e={name:"docs/disciplines/osis/p1.md"};function l(n,s,d,r,c,h){return a(),i("div",null,s[0]||(s[0]=[o('<h1 id="практическая-работа-no1" tabindex="-1">Практическая работа №1 <a class="header-anchor" href="#практическая-работа-no1" aria-label="Permalink to &quot;Практическая работа №1&quot;">​</a></h1><p><strong>Тема:</strong> Ядерные и внеядерные компоненты Linux<br><strong>Цель работы:</strong> Научиться различать ядерные и внеядерные компоненты операционной системы Linux, изучить их взаимодействие через практические примеры.</p><h2 id="инструкция-по-выполнению-работы" tabindex="-1">Инструкция по выполнению работы <a class="header-anchor" href="#инструкция-по-выполнению-работы" aria-label="Permalink to &quot;Инструкция по выполнению работы&quot;">​</a></h2><p><em>Преподаватель демонстрирует каждый шаг, студенты повторяют команды в терминале и фиксируют результаты.</em></p><div class="tip custom-block"><p class="custom-block-title">Пояснение</p><p>Архитектура Linux построена на принципе разделения пространства ядра (kernel space) и пользовательского пространства (user space). Ядро — это центральный компонент, который напрямую взаимодействует с аппаратным обеспечением. Все остальное — приложения, оболочки, сервисы — работают во внеядерном (пользовательском) пространстве и обращаются к ядру через системные вызовы (system calls). Это разделение обеспечивает стабильность, безопасность и модульность системы.</p></div><h3 id="шаг-1-изучение-информации-о-ядре-linux" tabindex="-1"><strong>Шаг 1. Изучение информации о ядре Linux</strong> <a class="header-anchor" href="#шаг-1-изучение-информации-о-ядре-linux" aria-label="Permalink to &quot;**Шаг 1. Изучение информации о ядре Linux**&quot;">​</a></h3><p><strong>Цель:</strong> Убедиться, что вы работаете с ядром Linux, и изучить его параметры.</p><ol><li><strong>Проверьте версию ядра:</strong></li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">uname</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -a</span></span></code></pre></div><p><em>Пример вывода:</em><br><code>Linux altlinux 6.12.42-6.12-alt1 #1 SMP PREEMPT_DYNAMIC Tue Aug 26 13:33:43 UTC 2025 x86_64 GNU/Linux</code></p><div class="tip custom-block"><p class="custom-block-title">Пояснение</p><p>Версия ядра следует схеме <a href="https://semver.org/lang/ru/" target="_blank" rel="noreferrer">семантического версионирования</a>: <code>MAJOR.MINOR.PATCH</code>. Например, 5.15.0 означает:</p><ul><li>5 — основная версия (мажорная),</li><li>15 — второстепенная (минорная), часто добавляет новые функции,</li><li>0 — патч (исправления ошибок).</li></ul></div><ol start="2"><li><strong>Посмотрите детали ядра через файловую систему <code>/proc</code>:</strong></li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/version</span></span></code></pre></div><p><em>Вывод:</em> Тот же, что и в <code>uname -a</code>, но в «сыром» виде.</p><p><code>Linux version 6.12.42-6.12-alt1 (builder@localhost.localdomain) (gcc-13 (GCC) 13.2.1 20240128 (ALT Sisyphus 13.2.1-alt3), GNU ld (GNU Binutils) 2.41.0.20230826) #1 SMP PREEMPT_DYNAMIC Tue Aug 26 13:33:43 UTC 2025</code></p><div class="warning custom-block"><p class="custom-block-title">Подробное пояснение вывода</p><h4 id="_1-linux-version-6-12-42-6-12-alt1" tabindex="-1">1. <strong><code>Linux version 6.12.42-6.12-alt1</code></strong> <a class="header-anchor" href="#_1-linux-version-6-12-42-6-12-alt1" aria-label="Permalink to &quot;1. **`Linux version 6.12.42-6.12-alt1`**&quot;">​</a></h4><ul><li>Это основная информация о версии ядра Linux.</li><li><strong><code>6.12.42</code></strong> — версия ядра Linux: <ul><li><code>6</code> — мажорная (основная) версия.</li><li><code>12</code> — минорная (второстепенная) версия.</li><li><code>42</code> — патч-уровень (ревизия, накопленные исправления).</li></ul></li><li><strong><code>-6.12-alt1</code></strong> — суффикс, указывающий на специфику сборки: <ul><li>Это <strong>пакет ядра</strong>, собранный для дистрибутива <strong>ALT Linux</strong>.</li><li><code>alt1</code> — номер релиза пакета в репозитории ALT Linux.</li></ul></li></ul><h4 id="_2-builder-localhost-localdomain" tabindex="-1">2. <strong><code>(builder@localhost.localdomain)</code></strong> <a class="header-anchor" href="#_2-builder-localhost-localdomain" aria-label="Permalink to &quot;2. **`(builder@localhost.localdomain)`**&quot;">​</a></h4><ul><li>Указывает на <strong>пользователя и хост</strong>, с которого была произведена сборка ядра.</li><li><code>builder</code> — имя пользователя (обычно это автоматизированный аккаунт сборки).</li><li><code>localhost.localdomain</code> — имя машины, где происходила компиляция (стандартное имя для сборочных систем).</li><li>Это <strong>не обязательно реальное имя хоста</strong>, часто используется по умолчанию в автоматизированных средах.</li></ul><h4 id="_3-gcc-13-gcc-13-2-1-20240128-alt-sisyphus-13-2-1-alt3" tabindex="-1">3. <strong><code>(gcc-13 (GCC) 13.2.1 20240128 (ALT Sisyphus 13.2.1-alt3)</code></strong> <a class="header-anchor" href="#_3-gcc-13-gcc-13-2-1-20240128-alt-sisyphus-13-2-1-alt3" aria-label="Permalink to &quot;3. **`(gcc-13 (GCC) 13.2.1 20240128 (ALT Sisyphus 13.2.1-alt3)`**&quot;">​</a></h4><ul><li>Информация о <strong>компиляторе</strong>, использованном для сборки ядра.</li><li><strong><code>gcc-13</code></strong> — версия GCC (GNU Compiler Collection), использованная для компиляции.</li><li><strong><code>13.2.1</code></strong> — конкретная версия GCC.</li><li><strong><code>20240128</code></strong> — дата сборки этого конкретного бинарника GCC.</li><li><strong><code>ALT Sisyphus 13.2.1-alt3</code></strong> — указывает, что это версия GCC, пакованная для дистрибутива <strong>ALT Linux</strong>, ветка <strong>Sisyphus</strong> (основной репозиторий пакетов).</li></ul><h4 id="_4-gnu-ld-gnu-binutils-2-41-0-20230826" tabindex="-1">4. <strong><code>GNU ld (GNU Binutils) 2.41.0.20230826</code></strong> <a class="header-anchor" href="#_4-gnu-ld-gnu-binutils-2-41-0-20230826" aria-label="Permalink to &quot;4. **`GNU ld (GNU Binutils) 2.41.0.20230826`**&quot;">​</a></h4><ul><li>Указывает на <strong>компоновщик (linker)</strong>, использованный при сборке ядра.</li><li><strong><code>GNU ld</code></strong> — это стандартный компоновщик из пакета <strong>GNU Binutils</strong>.</li><li><strong><code>2.41.0.20230826</code></strong> — версия Binutils (дата указывает на момент сборки).</li><li>Компоновщик отвечает за объединение объектных файлов в единый образ ядра.</li></ul><h4 id="_5-1-smp-preempt-dynamic" tabindex="-1">5. <strong><code>#1 SMP PREEMPT_DYNAMIC</code></strong> <a class="header-anchor" href="#_5-1-smp-preempt-dynamic" aria-label="Permalink to &quot;5. **`#1 SMP PREEMPT_DYNAMIC`**&quot;">​</a></h4><ul><li>Это <strong>тег сборки ядра</strong>, содержит важные флаги конфигурации: <ul><li><strong><code>#1</code></strong> — номер сборки (в данном случае первая сборка с такими параметрами).</li><li><strong><code>SMP</code></strong> — <strong>Symmetric Multi-Processing</strong>: <ul><li>Ядро поддерживает многопроцессорные (или многоядерные) системы.</li><li>Может использовать несколько CPU/ядер одновременно.</li></ul></li><li><strong><code>PREEMPT_DYNAMIC</code></strong> — режим вытесняющего планирования: <ul><li>Ядро поддерживает <strong>динамическое вытеснение</strong> (preemption).</li><li>Это компромисс между производительностью и латентностью: можно включать/выключать вытеснение в зависимости от нагрузки.</li><li>Более гибкий, чем <code>PREEMPT_NONE</code>, но не такой агрессивный, как <code>PREEMPT_FULL</code>.</li></ul></li></ul></li></ul><h4 id="_6-tue-aug-26-13-33-43-utc-2025" tabindex="-1">6. <strong><code>Tue Aug 26 13:33:43 UTC 2025</code></strong> <a class="header-anchor" href="#_6-tue-aug-26-13-33-43-utc-2025" aria-label="Permalink to &quot;6. **`Tue Aug 26 13:33:43 UTC 2025`**&quot;">​</a></h4><ul><li><strong>Дата и время сборки ядра</strong>.</li><li>Указывается в формате: день недели, месяц, число, время, часовой пояс, год.</li><li>Здесь: <strong>вторник, 26 августа 2025 года, 13:33:43 по UTC</strong>.</li></ul></div><div class="tip custom-block"><p class="custom-block-title">Пояснение</p><p>Файловая система <code>/proc</code> — это интерфейс ядра для пользовательского пространства. Она не хранит данные на диске, а генерируется ядром «на лету». Например, <code>/proc/cpuinfo</code> показывает информацию о процессоре, <code>/proc/meminfo</code> — о памяти. Это пример того, как ядро предоставляет свои данные через файловый интерфейс, что упрощает взаимодействие с пользовательскими программами.</p></div><h3 id="шаг-2-анализ-загруженных-модулеи-ядра" tabindex="-1"><strong>Шаг 2. Анализ загруженных модулей ядра</strong> <a class="header-anchor" href="#шаг-2-анализ-загруженных-модулеи-ядра" aria-label="Permalink to &quot;**Шаг 2. Анализ загруженных модулей ядра**&quot;">​</a></h3><p><strong>Цель:</strong> Увидеть, какие модули ядра активны в системе.</p><ol><li><strong>Список загруженных модулей:</strong></li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lsmod</span></span></code></pre></div><p><em>Пример вывода:</em></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Module                  Size  Used by</span></span>\n<span class="line"><span>snd_hda_codec_generic    81920  1</span></span>\n<span class="line"><span>...</span></span></code></pre></div><p><strong>Пояснение:</strong></p><ul><li>Модули ядра (например, <code>snd_hda_codec_generic</code> для звука) — это <strong>ядерные компоненты</strong>, расширяющие функционал ядра без перезагрузки.</li></ul><div class="tip custom-block"><p class="custom-block-title">Пояснение</p><p>Модули ядра — это динамически загружаемые компоненты, которые позволяют ядру оставаться компактным. Вместо того чтобы включать поддержку всех возможных устройств «навсегда», ядро загружает модули по мере необходимости (например, при подключении USB-устройства). Это называется динамической загрузкой модулей. Модули имеют расширение <code>.ko</code> (kernel object) и находятся в <code>/lib/modules/$(uname -r)/</code>.</p></div><ol start="2"><li><strong>Поиск конкретного модуля (например, связанного с сетью):</strong></li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lsmod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> net</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">Пояснение</p><p>Сетевые модули (например, <code>af_packet</code>, <code>nf_conntrack</code>) отвечают за обработку сетевых пакетов, работу с интерфейсами, NAT и т.д. Их наличие в <code>lsmod</code> означает, что соответствующие функции активны в ядре. Это показывает, как ядро масштабируется под задачи системы, загружая только нужные компоненты.</p></div><h3 id="шаг-3-исследование-процессов-ядра" tabindex="-1"><strong>Шаг 3. Исследование процессов ядра</strong> <a class="header-anchor" href="#шаг-3-исследование-процессов-ядра" aria-label="Permalink to &quot;**Шаг 3. Исследование процессов ядра**&quot;">​</a></h3><p><strong>Цель:</strong> Найти процессы, непосредственно связанные с ядром.</p><ol><li><strong>Просмотр всех процессов:</strong></li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -ef</span></span></code></pre></div><p><strong>Обратите внимание на процессы вида <code>[kthreadd]</code>, <code>[kworker/*]</code>:</strong></p><ul><li>Это потоки ядра (kernel threads), управляющие задачами в фоне (например, обработка прерываний).</li><li><strong>Ядерный компонент:</strong> Такие процессы не имеют PID в пользовательском пространстве и создаются самим ядром.</li></ul><div class="tip custom-block"><p class="custom-block-title">Пояснение</p><p>kthreadd — это родитель всех потоков ядра. Он запускается при загрузке и порождает другие ядерные потоки, такие как:</p><ul><li>kworker/* — выполняют отложенные задачи (work queues),</li><li>migration/* — переносят процессы между CPU-ядрами,</li><li>ksoftirqd/* — обрабатывают программные прерывания.</li></ul><p>Эти потоки не являются обычными процессами — они работают исключительно в пространстве ядра и не могут быть завершены пользователем.</p></div><ol start="2"><li><strong>Фильтрация процессов ядра:</strong></li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -ef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;\\[.*\\]&quot;</span></span></code></pre></div><p><em>Вывод:</em> Список процессов в квадратных скобках — это внутренние задачи ядра.</p><div class="tip custom-block"><p class="custom-block-title">Пояснение</p><p>Квадратные скобки [...] в выводе <code>ps</code> — это визуальный индикатор того, что процесс является внутренним потоком ядра. Система не создаёт для них реальных исполняемых файлов — они существуют только в памяти. Это отличает их от пользовательских процессов, которые всегда связаны с исполняемым файлом (например, <code>/usr/bin/firefox</code>).</p></div><h3 id="шаг-4-изучение-внеядерных-компонентов" tabindex="-1"><strong>Шаг 4. Изучение внеядерных компонентов</strong> <a class="header-anchor" href="#шаг-4-изучение-внеядерных-компонентов" aria-label="Permalink to &quot;**Шаг 4. Изучение внеядерных компонентов**&quot;">​</a></h3><p><strong>Цель:</strong> Определить компоненты, работающие в пользовательском пространстве.</p><ol><li><strong>Просмотр установленных пакетов (пакетный менеджер):</strong></li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dpkg</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -l</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> head</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # Для Ubuntu/Debian</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Или</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rpm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -qa</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> head</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   # Для CentOS/RHEL/ALT</span></span></code></pre></div><p><strong>Пояснение:</strong></p><ul><li>Пакеты (например, <code>bash</code>, <code>nginx</code>, <code>firefox</code>) — это <strong>внеядерные компоненты</strong>.</li><li>Они работают в пользовательском пространстве и взаимодействуют с ядром через системные вызовы.</li></ul><div class="tip custom-block"><p class="custom-block-title">Пояснение</p><p>Пакетный менеджер (например, <code>dpkg</code>, <code>rpm</code>, <code>apt</code>, <code>yum</code>) — это инфраструктура управления внеядерными компонентами. Он отслеживает, какие программы установлены, их зависимости и версии. Эти компоненты не являются частью ядра, но критически важны для функциональности системы. Например, <code>bash</code> — это просто программа, как и любой другой бинарник, но она предоставляет интерфейс для взаимодействия с ОС.</p></div><ol start="2"><li><strong>Просмотр активных сервисов (демонов):</strong></li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">systemctl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> list-units</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --type=service</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --state=running</span></span></code></pre></div><p><em>Пример вывода:</em></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UNIT                     LOAD   ACTIVE SUB     DESCRIPTION</span></span>\n<span class="line"><span>ssh.service              loaded active running OpenBSD Secure Shell server</span></span>\n<span class="line"><span>...</span></span></code></pre></div><p><strong>Пояснение:</strong></p><ul><li>Сервисы (демоны) — внеядерные компоненты, управляющие фоновыми задачами (например, веб-сервер, SSH).</li></ul><div class="tip custom-block"><p class="custom-block-title">Пояснение</p><p>Демоны — это внеядерные процессы, которые запускаются при загрузке или по требованию. Они работают в фоне и предоставляют сетевые или системные услуги. Например, <code>sshd</code> слушает порт 22 и обрабатывает входящие SSH-подключения. Он взаимодействует с ядром через системные вызовы (например, <code>socket()</code>, <code>bind()</code>, <code>accept()</code>), чтобы работать с сетью.</p></div><ol start="3"><li><strong>Проверка оболочки (shell):</strong></li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $SHELL</span></span></code></pre></div><p><em>Вывод:</em> <code>/bin/bash</code> — путь к оболочке, которая является <strong>внеядерным компонентом</strong>.</p><div class="tip custom-block"><p class="custom-block-title">Пояснение</p><p>Оболочка (shell) — это пользовательская программа, которая интерпретирует команды. Она не является частью ядра, хотя и кажется «фундаментальной». Например, <code>bash</code> можно удалить и заменить на <code>zsh</code> или <code>fish</code> — система продолжит работать. Shell использует системные вызовы (<code>fork</code>, <code>exec</code>, <code>read</code>, <code>write</code>) для выполнения команд и взаимодействия с ядром.</p></div><h3 id="шаг-5-сравнение-ядерных-и-внеядерных-компонентов" tabindex="-1"><strong>Шаг 5. Сравнение ядерных и внеядерных компонентов</strong> <a class="header-anchor" href="#шаг-5-сравнение-ядерных-и-внеядерных-компонентов" aria-label="Permalink to &quot;**Шаг 5. Сравнение ядерных и внеядерных компонентов**&quot;">​</a></h3><p><strong>Цель:</strong> Систематизировать полученные данные.</p><ol><li><p><strong>Заполните таблицу в тетради:</strong></p><table tabindex="0"><thead><tr><th>Компонент</th><th>Пример</th><th>Принадлежность</th><th>Как проверить?</th></tr></thead><tbody><tr><td>Ядерный</td><td>Модуль <code>snd_hda_codec</code></td><td>Ядро</td><td><code>lsmod</code></td></tr><tr><td>Внеядерный</td><td>Сервис <code>ssh.service</code></td><td>Пользовательское пространство</td><td><code>systemctl</code></td></tr><tr><td>Ядерный</td><td>Процесс <code>[kworker/0:1]</code></td><td>Ядро</td><td><code>ps -ef</code></td></tr><tr><td>Внеядерный</td><td>Оболочка <code>bash</code></td><td>Пользовательское пространство</td><td><code>echo $SHELL</code></td></tr></tbody></table></li><li><p><strong>Вывод:</strong></p></li></ol><ul><li>Ядро — «мозг» системы, отвечающий за управление ресурсами.</li><li>Внеядерные компоненты (пакеты, сервисы, оболочки) предоставляют пользователю функционал, но зависят от ядра.</li></ul><div class="tip custom-block"><p class="custom-block-title">Пояснение</p><p>Важно понимать, что разделение на ядро и пользовательское пространство — это не просто классификация, а архитектурный принцип безопасности и стабильности. Если программа в пользовательском пространстве «падает», это не приводит к краху всей системы. Но если падает ядро — система зависает (BSOD в Windows, kernel panic в Linux). Поэтому критически важные функции (управление памятью, планирование процессов) остаются в ядре, а всё остальное — «снаружи».</p></div><h3 id="шаг-6-изучение-вывода-htop" tabindex="-1"><strong>Шаг 6. Изучение вывода htop</strong> <a class="header-anchor" href="#шаг-6-изучение-вывода-htop" aria-label="Permalink to &quot;**Шаг 6. Изучение вывода htop**&quot;">​</a></h3><ol><li>Установите новый пакет (например, <code>htop</code>):</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apt-get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> htop</span></span></code></pre></div><ol start="2"><li>Запустите его и сравните процессы, отображаемые в <code>htop</code> и <code>ps -ef</code>.</li><li>Объясните, к какой категории (ядерные/внеядерные) относится <code>htop</code>.</li></ol><div class="tip custom-block"><p class="custom-block-title">Пояснение</p><p>Установка <code>htop</code> — хороший пример того, как внеядерный компонент может отображать информацию о ядре. <code>htop</code> читает данные из <code>/proc</code> и <code>/sys</code> — виртуальных файловых систем, предоставляемых ядром. Он не «видит» ядро напрямую, а интерпретирует его данные, как и любой другой пользовательский процесс. Это иллюстрирует, как пользовательское пространство «наблюдает» за ядром через стандартизированные интерфейсы.</p></div><div class="info custom-block"><p class="custom-block-title">Шпаргалка по <code>htop</code></p><h4 id="_1-запуск-htop" tabindex="-1">1. Запуск htop <a class="header-anchor" href="#_1-запуск-htop" aria-label="Permalink to &quot;1. Запуск htop&quot;">​</a></h4><p>Просто введите в терминале:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">htop</span></span></code></pre></div><blockquote><p>Для просмотра всех процессов (включая чужие) может потребоваться <code>sudo</code>:</p></blockquote><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> htop</span></span></code></pre></div><hr><h4 id="_2-интерфеис-htop" tabindex="-1">2. Интерфейс htop <a class="header-anchor" href="#_2-интерфеис-htop" aria-label="Permalink to &quot;2. Интерфейс htop&quot;">​</a></h4><p>После запуска вы увидите:</p><h5 id="верхняя-часть-панель-ресурсов" tabindex="-1">Верхняя часть (панель ресурсов): <a class="header-anchor" href="#верхняя-часть-панель-ресурсов" aria-label="Permalink to &quot;Верхняя часть (панель ресурсов):&quot;">​</a></h5><ul><li><strong>CPU</strong>: использование каждого ядра (в процентах и графически).</li><li><strong>Mem</strong>: использование оперативной памяти.</li><li><strong>Swp</strong>: использование swap-раздела.</li></ul><blockquote><p>Цвета:</p></blockquote><ul><li>Синий — низкоприоритетные задачи (nice)</li><li>Зелёный — пользовательские процессы</li><li>Красный — системные процессы</li><li>Жёлтый — время ожидания ввода/вывода (iowait)</li></ul><hr><h5 id="средняя-часть-список-процессов" tabindex="-1">Средняя часть (список процессов): <a class="header-anchor" href="#средняя-часть-список-процессов" aria-label="Permalink to &quot;Средняя часть (список процессов):&quot;">​</a></h5><p>Колонки по умолчанию:</p><ul><li><strong>PID</strong> — идентификатор процесса</li><li><strong>USER</strong> — владелец процесса</li><li><strong>PRI</strong> — приоритет</li><li><strong>NI</strong> — nice-значение (приоритет планировщика)</li><li><strong>VIRT</strong> — виртуальная память</li><li><strong>RES</strong> — физическая память (резидентная)</li><li><strong>SHR</strong> — разделяемая память</li><li><strong>S</strong> — состояние (R=работает, S=спит, Z=зомби, D=ожидание I/O)</li><li><strong>CPU%</strong> — загрузка CPU</li><li><strong>MEM%</strong> — использование памяти</li><li><strong>TIME+</strong> — общее время работы процесса</li><li><strong>Command</strong> — команда/имя процесса</li></ul><hr><h4 id="_3-управление-с-помощью-клавиатуры" tabindex="-1">3. Управление с помощью клавиатуры <a class="header-anchor" href="#_3-управление-с-помощью-клавиатуры" aria-label="Permalink to &quot;3. Управление с помощью клавиатуры&quot;">​</a></h4><table tabindex="0"><thead><tr><th>Клавиша</th><th>Действие</th></tr></thead><tbody><tr><td><strong>↑ / ↓</strong>, <strong>Page Up / Page Down</strong></td><td>Прокрутка списка процессов</td></tr><tr><td><strong>F1</strong></td><td>Помощь (Help) — подробная справка по всем клавишам</td></tr><tr><td><strong>F2</strong></td><td>Настройки (Setup) — настройка отображения</td></tr><tr><td><strong>F3</strong></td><td>Поиск процесса по имени</td></tr><tr><td><strong>F4</strong></td><td>Фильтр — показывать только процессы, содержащие введённую строку</td></tr><tr><td><strong>F5</strong></td><td>Режим дерева — отображение процессов в виде дерева (с учётом родительских процессов)</td></tr><tr><td><strong>F6</strong></td><td>Сортировка — выбрать колонку для сортировки (например, по CPU%, MEM%, PID и т.д.)</td></tr><tr><td><strong>F7</strong></td><td>Уменьшить приоритет (Nice --)</td></tr><tr><td><strong>F8</strong></td><td>Увеличить приоритет (Nice ++)</td></tr><tr><td><strong>F9</strong></td><td>Отправить сигнал процессу (например, SIGKILL для завершения)</td></tr><tr><td><strong>F10</strong></td><td>Выход из htop</td></tr><tr><td><strong>Space</strong></td><td>Пометить/снять пометку с процесса (для массовых действий)</td></tr><tr><td><strong>u</strong></td><td>Показать только процессы определённого пользователя</td></tr><tr><td><strong>k</strong></td><td>Показать/скрыть названия сигналов (в режиме отправки сигнала)</td></tr><tr><td><strong>H</strong></td><td>Включить/выключить отображение потоков (threads)</td></tr><tr><td><strong>U</strong></td><td>Снять пометки со всех процессов</td></tr><tr><td><strong>l</strong></td><td>Показать открытые файлы процесса (через <code>lsof</code>)</td></tr><tr><td><strong>i</strong></td><td>Показать/скрыть задержку ввода-вывода (iowait) на графике CPU</td></tr></tbody></table><hr><h4 id="_4-полезные-настроики-f2-—-setup" tabindex="-1">4. Полезные настройки (F2 — Setup) <a class="header-anchor" href="#_4-полезные-настроики-f2-—-setup" aria-label="Permalink to &quot;4. Полезные настройки (F2 — Setup)&quot;">​</a></h4><h5 id="вкладки" tabindex="-1">Вкладки: <a class="header-anchor" href="#вкладки" aria-label="Permalink to &quot;Вкладки:&quot;">​</a></h5><ul><li><strong>[Display options]</strong> — отображение: <ul><li><code>Hide kernel threads</code> — скрыть системные потоки (начинающиеся с <code>kthreadd</code>, <code>kworker</code>)</li><li><code>Hide userland process threads</code> — не показывать потоки пользовательских процессов</li><li><code>Show custom thread names</code> — показывать имена потоков</li><li><code>Highlight changes</code> — подсвечивать изменения при обновлении</li></ul></li><li><strong>[Colors]</strong> — выбрать цветовую схему (напр., black on white, blue, green и т.п.)</li><li><strong>[Fields]</strong> — выбрать, какие колонки отображать в списке процессов</li></ul><hr><h4 id="_5-поиск-и-фильтрация" tabindex="-1">5. Поиск и фильтрация <a class="header-anchor" href="#_5-поиск-и-фильтрация" aria-label="Permalink to &quot;5. Поиск и фильтрация&quot;">​</a></h4><ul><li><strong>F3</strong> → введите имя процесса (например, <code>firefox</code>) — htop найдёт и подсветит.</li><li><strong>F4</strong> → введите строку — останутся только процессы, содержащие её в команде.</li><li>Чтобы сбросить фильтр — нажмите <strong>F4</strong>, затем <strong>Backspace</strong> и <strong>Enter</strong>.</li></ul><hr><h4 id="_6-управление-процессами" tabindex="-1">6. Управление процессами <a class="header-anchor" href="#_6-управление-процессами" aria-label="Permalink to &quot;6. Управление процессами&quot;">​</a></h4><h5 id="завершение-процесса" tabindex="-1">Завершение процесса: <a class="header-anchor" href="#завершение-процесса" aria-label="Permalink to &quot;Завершение процесса:&quot;">​</a></h5><ol><li>Выделите нужный процесс стрелками.</li><li>Нажмите <strong>F9</strong>.</li><li>Выберите сигнал: <ul><li><code>SIGTERM</code> (15) — вежливое завершение (рекомендуется).</li><li><code>SIGKILL</code> (9) — принудительное уничтожение (если процесс не отвечает).</li></ul></li><li>Нажмите <strong>Enter</strong>.</li></ol><blockquote><p>Можно пометить несколько процессов через <strong>Пробел</strong>, затем применить сигнал ко всем.</p></blockquote><hr><h4 id="_7-сортировка" tabindex="-1">7. Сортировка <a class="header-anchor" href="#_7-сортировка" aria-label="Permalink to &quot;7. Сортировка&quot;">​</a></h4><ul><li>Нажмите <strong>F6</strong>.</li><li>Выберите колонку для сортировки: <ul><li><code>CPU%</code> — по загрузке процессора</li><li><code>MEM%</code> — по использованию памяти</li><li><code>TIME+</code> — по времени работы</li><li><code>PID</code> — по номеру процесса</li></ul></li><li>Сортировка обновляется в реальном времени.</li></ul><hr><h4 id="_8-режим-дерева-f5" tabindex="-1">8. Режим дерева (F5) <a class="header-anchor" href="#_8-режим-дерева-f5" aria-label="Permalink to &quot;8. Режим дерева (F5)&quot;">​</a></h4><ul><li>Включает древовидное отображение: дочерние процессы показываются под родительскими.</li><li>Удобно для анализа, какие процессы порождены другими (например, скрипты, сервисы, оболочки).</li></ul><hr><h4 id="_9-полезные-советы" tabindex="-1">9. Полезные советы <a class="header-anchor" href="#_9-полезные-советы" aria-label="Permalink to &quot;9. Полезные советы&quot;">​</a></h4><ul><li>Запускайте <code>htop</code> с <code>sudo</code>, чтобы видеть все процессы.</li><li>Используйте <code>htop --no-color</code> — если терминал некорректно отображает цвета.</li><li>Можно запустить <code>htop</code> и оставить его работать в фоне, например, в <code>tmux</code> или <code>screen</code>.</li><li>Чтобы быстро найти &quot;тяжёлые&quot; процессы — сортируйте по <code>CPU%</code> или <code>MEM%</code>.</li></ul><hr><h4 id="_10-примеры-использования" tabindex="-1">10. Примеры использования <a class="header-anchor" href="#_10-примеры-использования" aria-label="Permalink to &quot;10. Примеры использования&quot;">​</a></h4><h5 id="показать-только-процессы-пользователя-alex" tabindex="-1">Показать только процессы пользователя <code>alex</code>: <a class="header-anchor" href="#показать-только-процессы-пользователя-alex" aria-label="Permalink to &quot;Показать только процессы пользователя `alex`:&quot;">​</a></h5><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">htop</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -u</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> alex</span></span></code></pre></div><h5 id="отсортировать-по-памяти-при-запуске" tabindex="-1">Отсортировать по памяти при запуске: <a class="header-anchor" href="#отсортировать-по-памяти-при-запуске" aria-label="Permalink to &quot;Отсортировать по памяти при запуске:&quot;">​</a></h5><p>(в htop нажмите F6 → MEM%)</p><h5 id="запустить-в-режиме-дерева" tabindex="-1">Запустить в режиме дерева: <a class="header-anchor" href="#запустить-в-режиме-дерева" aria-label="Permalink to &quot;Запустить в режиме дерева:&quot;">​</a></h5><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">htop</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -t</span></span></code></pre></div><p><strong>Совет:</strong> Нажмите <strong>F1</strong>, чтобы всегда иметь под рукой полную справку!</p></div><h3 id="контрольные-вопросы" tabindex="-1">Контрольные вопросы <a class="header-anchor" href="#контрольные-вопросы" aria-label="Permalink to &quot;Контрольные вопросы&quot;">​</a></h3><ol><li>Какая команда покажет версию ядра Linux?</li><li>Почему процессы в квадратных скобках (например, <code>[kthreadd]</code>) считаются ядерными?</li><li>Приведите 3 примера внеядерных компонентов и объясните их назначение.</li><li>Как проверить, какие модули ядра используются для работы Wi-Fi?</li></ol><h3 id="требования-к-отчету" tabindex="-1">Требования к отчету <a class="header-anchor" href="#требования-к-отчету" aria-label="Permalink to &quot;Требования к отчету&quot;">​</a></h3><ol><li>Скриншоты выполнения ключевых команд.</li><li>Заполненная таблица из Шага 5.</li><li>Ответы на контрольные вопросы.</li></ol><div class="tip custom-block"><p class="custom-block-title">Пояснение</p><p>При оформлении отчета обратите внимание: скриншоты должны отражать не только результат, но и контекст. Например, если вы показываете <code>lsmod</code>, полезно добавить пояснение: «Этот модуль отвечает за X и был загружен автоматически при обнаружении устройства Y». Это покажет понимание, а не просто копирование вывода.</p></div><p><strong>Примечание:</strong> Эта работа закрепляет теорию архитектуры ОС, показывая разделение на ядро (монолитное ядро Linux) и пользовательское пространство (POSIX-совместимые утилиты, демоны).</p><div class="warning custom-block"><p class="custom-block-title">Выводы</p><p>Linux использует монолитное ядро, но с поддержкой модулей — это компромисс между производительностью (все в одном адресном пространстве) и гибкостью (возможность загружать компоненты динамически). В отличие от микроядер (например, в системах на базе Mach), где многие компоненты работают во внеядерном пространстве, Linux держит большую часть драйверов и подсистем внутри ядра, что даёт высокую производительность, но требует большей осторожности при разработке.</p></div>',76)]))}const u=t(e,[["render",l]]);export{g as __pageData,u as default};
