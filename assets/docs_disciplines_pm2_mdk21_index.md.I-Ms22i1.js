import{_ as t,c as l,o as r,ag as a}from"./chunks/framework.D4Vqf8I7.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/disciplines/pm2/mdk21/index.md","filePath":"docs/disciplines/pm2/mdk21/index.md","lastUpdated":1756739716000}'),s={name:"docs/disciplines/pm2/mdk21/index.md"};function n(i,e,u,p,o,d){return r(),l("div",null,e[0]||(e[0]=[a('<p>Основы работы в ФС, iperf3, df, du, smartctl, iotop, iostat, top, htop, vmstat, systemctl, ps, strace, netstat, ifconfig, ip, traceroute, ping, mtr, tcpdump, syslog, dmesg, journalctl</p><p>Большая часть дисциплины - это изучение сетевых конфигураций. Это вам не два компа пинговать. Ансибле и прочее</p><p><a href="http://www2.kangran.su/~nnz/pub/perf_rs/perf_rs_latest.pdf" target="_blank" rel="noreferrer">http://www2.kangran.su/~nnz/pub/perf_rs/perf_rs_latest.pdf</a> - книжонка по iptables</p><h2 id="что-такое-уровень-выполнения-runlevel-в-linux-и-как-посмотреть-текущии" tabindex="-1">Что такое уровень выполнения (runlevel) в Linux и как посмотреть текущий? <a class="header-anchor" href="#что-такое-уровень-выполнения-runlevel-в-linux-и-как-посмотреть-текущии" aria-label="Permalink to &quot;Что такое уровень выполнения (runlevel) в Linux и как посмотреть текущий?&quot;">​</a></h2><p>Уровни выполнения (runlevel) Linux можно представить, как режим, в котором запускается система. Каждый из этих режимов обладают своими процессами, которые включены или выключены в зависимости от запущенного уровня выполнения. С момента загрузки Linux выполняется в одном из режимов, нельзя запускать систему одновременно в нескольких режимах, но есть возможность переключаться между уровнями во время работы на компьютере.</p><p>В системе Linux есть семь уровней выполнения, которые нумеруются от 0 до 6. Разные дистрибутивы по-разному используют уровни выполнения, так что очень сложно составить список задач, которые выполняет конкретный уровень.</p><p>Обычно уровни выполнения выглядят следующим образом:</p><ul><li>Runlevel 0 завершает работу системы.</li><li>Runlevel 1 однопользовательский режим работы. Чаще всего используется в целях обслуживания и выполнения других административных задач. Это уровень также может называться runlevel S, где S означает single-user.</li></ul><div class="tip custom-block"><p class="custom-block-title">Цитата из <a href="http://www2.kangran.su/~nnz/pub/s4a/s4a_latest.pdf" target="_blank" rel="noreferrer">systemd для администраторов Lennart Poettering</a></p><p>Дистрибутивно-специфичные квази-уровни исполнения, используемые для организации запуска скриптов на ранних стадиях загрузки, больше не поддерживаются. Примерами таких уровней являются S в Debian и b в openSUSE. Разумеется, это никак незатрагивает поддержку обычных уровней исполнения, которую мы намерены сохранять еще очень долго.</p></div><ul><li>Runlevel 2 многопользовательский режим работы без поддержки сетевых служб (демонов).</li><li>Runlevel 3 многопользовательский режим с поддержкой сети, но без графического интерфейса. Чаще всего серверные версии Linux работают именно на этом уровне выполнения.</li><li>Runlevel 4 не используется. Пользователь может настраивать этот уровень исходя из его целей.</li><li>Runlevel 5 этот режим схож с уровнем 3, но тут еще запускается графический интерфейс. В этом режиме работают десктопные версии Linux.</li><li>Runlevel 6 этот уровень перезагружает систему.</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Чтобы узнать текущий уровень выполнения достаточно ввести команду runlevel в командной строке. Текущий уровень выполнения можно менять командой telinit</p><p>Неа, в альте нет этого софта, этот софт не относится к временам systemd</p></div><p>Чтобы проверить текущий «runlevel» (уровень выполнения) в системе с systemd, используйте команду systemctl get-default для определения целевого юнита (target), который соответствует традиционному уровню запуска, или команду who -r, чтобы увидеть текущий уровень выполнения (хотя этот метод больше относится к классическим системам init).</p><p>Чтобы изменить текущий runlevel в системе с systemd, используйте команду <code>sudo systemctl isolate &lt;target&gt;</code>, где <code>&lt;target&gt;</code> — это название целевого объекта (target), например, <code>multi-user.target</code> для запуска в режиме командной строки или <code>graphical.target</code> для графического режима. Вы также можете изменить целевой объект по умолчанию, чтобы система загружалась в него при каждом запуске, используя команду <code>sudo systemctl set-default &lt;target&gt;</code>.</p><p>В последние годы systemd сменила многолетнюю систему уровней доступа (System V init). Фактически он работает по тому же принципу, но использует новые команды, которые в целом используют «runlevel» как «target»:</p><ul><li>Runlevel 0 = poweroff.target (runlevel0.target)</li><li>Runlevel 1 = rescue.target (runlevel1.target)</li><li>Runlevel 2 = multi-user.target (runlevel2.target)</li><li>Runlevel 3 = multi-user.target (runlevel3.target)</li><li>Runlevel 4 = multi-user.target (runlevel4.target)</li><li>Runlevel 5 = graphical.target (runlevel5.target)</li><li>Runlevel 6 = reboot.target (runlevel6.target)</li></ul><div class="tip custom-block"><p class="custom-block-title">Цитата из <a href="http://www2.kangran.su/~nnz/pub/s4a/s4a_latest.pdf" target="_blank" rel="noreferrer">systemd для администраторов Lennart Poettering</a></p><p>По умолчанию, уровни исполнения 2, 3 и 4 являются эквивалентами целевого состояния <code>multi-user.target</code>. Если включить службу на одном из них, то она будет включена и на остальных. Впрочем, это лишь настройка по умолчанию, и ничто не мешает вам определить их независимо. Тем не менее, мы рекомендуем отказаться от уровней исполнения в пользу более гибкого механизма целевых состояний systemd.</p></div>',16)]))}const m=t(s,[["render",n]]);export{g as __pageData,m as default};
