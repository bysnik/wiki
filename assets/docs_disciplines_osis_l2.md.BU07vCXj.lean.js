import{_ as l,c as n,o as p,ag as a,j as i,a as t}from"./chunks/framework.D4Vqf8I7.js";const y=JSON.parse('{"title":"Лекция 2. Процессы и нити: механизмы обмена информацией","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"docs/disciplines/osis/l2.md","filePath":"docs/disciplines/osis/l2.md","lastUpdated":1758211769000}'),e={name:"docs/disciplines/osis/l2.md"},h={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},d={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.186ex"},xmlns:"http://www.w3.org/2000/svg",width:"6.816ex",height:"2.072ex",role:"img",focusable:"false",viewBox:"0 -833.9 3012.6 915.9","aria-hidden":"true"};function k(o,s,r,g,c,u){return p(),n("div",null,[s[8]||(s[8]=a("",14)),s[9]||(s[9]=i("iframe",{src:"https://viewer.diagrams.net/?highlight=0000ff&layers=1&nav=1&title=Diagram#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1sHhsGhJREe7aB6HNjPgVEcGvIcENGcJf%26export%3Ddownload",width:"100%",height:"300px",frameborder:"0",allowfullscreen:""},null,-1)),s[10]||(s[10]=i("p",null,'Процесс, находящийся в состоянии "процесс исполняется", через некоторое время может быть завершен операционной системой или приостановлен и снова переведен в состояние "процесс не исполняется". Приостановка процесса происходит по двум причинам: для его дальнейшей работы потребовалось какое-либо событие (например, завершение операции ввода-вывода) или истек временной интервал, отведенный операционной системе для работы данного процесса. После этого операционная система по определенному алгоритму выбирает для исполнения один из процессов, находящихся в состоянии "процесс не исполняется", и переводит его в состояние "процесс исполняется". Новый процесс, появляющийся в системе, первоначально помещается в состояние "процесс не исполняется".',-1)),s[11]||(s[11]=i("p",null,"Составим диаграмму состояния, принятую в курсе:",-1)),s[12]||(s[12]=i("iframe",{src:"https://viewer.diagrams.net/?highlight=0000ff&layers=1&nav=1&title=Diagram#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1m8crMPfTCQyOqD1DsWv_5eq_TtgeBU7r%26export%3Ddownload",width:"100%",height:"500px",frameborder:"0",allowfullscreen:""},null,-1)),s[13]||(s[13]=i("p",null,'При рождении процесс получает в свое распоряжение адресное пространство, в которое загружается программный код процесса; ему выделяются стек и системные ресурсы; устанавливается начальное значение программного счетчика этого процесса и т. д. Родившийся процесс переводится в состояние "готовность".',-1)),s[14]||(s[14]=i("p",null,'Операционная система, пользуясь каким-либо алгоритмом планирования, выбирает один из готовых процессов и переводит его в состояние "исполнение". В состоянии "исполнение" происходит непосредственное выполнение программного код процесса. Выйти из этого состояния процесс может по трем причинам:',-1)),s[15]||(s[15]=i("ul",null,[i("li",null,"операционная система прекращает его деятельность;"),i("li",null,"он не может продолжать свою работу, пока не произойдет некоторое событие, и операционная система переводит его в состояние ожидание;"),i("li",null,"в результате возникновения прерывания в вычислительной системе (например, прерывания от таймера по истечении предусмотренного времени выполнения) его возвращают в состояние готовность.")],-1)),s[16]||(s[16]=i("p",null,'Из состояния "ожидание" процесс попадает в состояние "готовность" после того, как ожидаемое событие произошло, и он снова может быть выбран для исполнения.',-1)),s[17]||(s[17]=i("p",null,'При завершении своей деятельности процесс из состояния "исполнение" попадает в состояние "закончил исполнение".',-1)),s[18]||(s[18]=i("p",null,"В конкретных операционных системах состояния процесса могут быть еще более детализированы. Так, например, модель состояний процессов для операционной системы Windows NT содержит 7 различных состояний, а для операционной системы Unix – 9.",-1)),s[19]||(s[19]=i("div",{class:"info custom-block"},[i("p",{class:"custom-block-title"},"Высокая сложность"),i("h3",{id:"диаграмма-состоянии-unix",tabindex:"-1"},[t("Диаграмма состояний Unix "),i("a",{class:"header-anchor",href:"#диаграмма-состоянии-unix","aria-label":'Permalink to "Диаграмма состояний Unix"'},"​")]),i("p",null,"Полный набор состояний процесса содержится в следующем перечне:"),i("ol",null,[i("li",null,"Процесс выполняется в режиме задачи."),i("li",null,"Процесс выполняется в режиме ядра."),i("li",null,"Процесс не выполняется, но готов к запуску под управлением ядра."),i("li",null,"Процесс приостановлен и находится в оперативной памяти."),i("li",null,"Процесс готов к запуску, но программа подкачки (нулевой процесс) должна еще загрузить процесс в оперативную память, прежде чем он будет запущен под управлением ядра. Это состояние будет предметом обсуждения в главе 9 при рассмотрении системы подкачки."),i("li",null,"Процесс приостановлен и программа подкачки выгрузила его во внешнюю память, чтобы в оперативной памяти освободить место для других процессов."),i("li",null,"Процесс возвращен из привилегированного режима (режима ядра) в непривилегированный (режим задачи), ядро резервирует его и переключает контекст на другой процесс. Об отличии этого состояния от состояния 3 (готовность к запуску) пойдет речь ниже."),i("li",null,"Процесс вновь создан и находится в переходном состоянии; процесс существует, но не готов к выполнению, хотя и не приостановлен. Это состояние является начальным состоянием всех процессов, кроме нулевого."),i("li",null,"Процесс вызывает системную функцию exit и прекращает существование. Однако, после него осталась запись, содержащая код выхода, и некоторая хронометрическая статистика, собираемая родительским процессом. Это состояние является последним состоянием процесса.")]),i("p",null,'Рисунок представляет собой полную диаграмму переходов процесса из состояния в состояние. Рассмотрим с помощью модели переходов типичное поведение процесса. Ситуации, которые будут обсуждаться, несколько искусственны и процессы не всегда имеют дело с ними, но эти ситуации вполне применимы для иллюстрации различных переходов. Начальным состоянием модели является создание процесса родительским процессом с помощью системной функции fork(); из этого состояния процесс неминуемо переходит в состояние готовности к запуску (3 или 5). Для простоты предположим, что процесс перешел в состояние "готовности к запуску в памяти" (3). Планировщик процессов в конечном счете выберет процесс для выполнения и процесс перейдет в состояние "выполнения в режиме ядра", где доиграет до конца роль, отведенную ему функцией fork().'),i("iframe",{src:"https://viewer.diagrams.net/?highlight=0000ff&layers=1&nav=1&title=Diagram#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1aGtVaSSSzRb0SMrLu1TNqP-tXoXmEMAk%26export%3Ddownload",width:"100%",height:"700px",frameborder:"0",allowfullscreen:""}),i("p",null,'После всего этого процесс может перейти в состояние "выполнения в режиме задачи". По прохождении определенного периода времени может произойти прерывание работы процессора по таймеру и процесс снова перейдет в состояние "выполнения в режиме ядра". Как только программа обработки прерывания закончит работу, ядру может понадобиться подготовить к запуску другой процесс, поэтому первый процесс перейдет в состояние "резервирования", уступив дорогу второму процессу. Состояние "резервирования" в действительности не отличается от состояния "готовности к запуску в памяти" (пунктирная линия на рисунке, соединяющая между собой оба состояния, подчеркивает их эквивалентность), но они выделяются в отдельные состояния, чтобы подчеркнуть, что процесс, выполняющийся в режиме ядра, может быть зарезервирован только в том случае, если он собирается вернуться в режим задачи. Следовательно, ядро может при необходимости подкачивать процесс из состояния "резервирования". При известных условиях планировщик выберет процесс для исполнения и тот снова вернется в состояние "выполнения в режиме задачи".'),i("p",null,'Когда процесс выполняет вызов системной функции, он из состояния "выполнения в режиме задачи" переходит в состояние "выполнения в режиме ядра". Предположим, что системной функции требуется ввод-вывод с диска и поэтому процесс вынужден дожидаться завершения ввода-вывода. Он переходит в состояние "приостанова в памяти", в котором будет находиться до тех пор, пока не получит извещения об окончании ввода-вывода. Когда ввод-вывод завершится, произойдет аппаратное прерывание работы центрального процессора и программа обработки прерывания возобновит выполнение процесса, в результате чего он перейдет в состояние "готовности к запуску в памяти".'),i("p",null,'Предположим, что система выполняет множество процессов, которые одновременно никак не могут поместиться в оперативной памяти, и программа подкачки (нулевой процесс) выгружает один процесс, чтобы освободить место для другого процесса, находящегося в состоянии "готов к запуску, но выгружен". Первый процесс, выгруженный из оперативной памяти, переходит в то же состояние. Когда программа подкачки выбирает наиболее подходящий процесс для загрузки в оперативную память, этот процесс переходит в состояние "готовности к запуску в памяти". Планировщик выбирает процесс для исполнения и он переходит в состояние "выполнения в режиме ядра". Когда процесс завершается, он исполняет системную функцию exit, последовательно переходя в состояния "выполнения в режиме ядра" и, наконец, в состояние "прекращения существования".'),i("p",null,'Процесс может управлять некоторыми из переходов на уровне задачи. Во-первых, один процесс может создать другой процесс. Тем не менее, в какое из состояний процесс перейдет после создания (т.е. в состояние "готов к выполнению, находясь в памяти" или в состояние "готов к выполнению, но выгружен") зависит уже от ядра. Процессу эти состояния не подконтрольны. Во-вторых, процесс может обратиться к различным системным функциям, чтобы перейти из состояния "выполнения в режиме задачи" в состояние "выполнения в режиме ядра", а также перейти в режим ядра по своей собственной воле. Тем не менее, момент возвращения из режима ядра от процесса уже не зависит; в результате каких-то событий он может никогда не вернуться из этого режима и из него перейдет в состояние "прекращения существования" (см. раздел 7.2, где говорится о сигналах). Наконец, процесс может завершиться с помощью функции exit по своей собственной воле, но как указывалось ранее, внешние события могут потребовать завершения процесса без явного обращения к функции exit. Все остальные переходы относятся к жестко закрепленной части модели, закодированной в ядре, и являются результатом определенных событий, реагируя на них в соответствии с правилами, сформулированными в этой и последующих главах. Некоторые из правил уже упоминались: например, то, что процесс может выгрузить другой процесс, выполняющийся в ядре.')],-1)),s[20]||(s[20]=a("",15)),i("p",null,[s[2]||(s[2]=t("В операционной системе GNU/Linux присвоение идентификационных номеров процессов начинается с номера 0, который получает процесс ")),s[3]||(s[3]=i("code",null,"kernel",-1)),s[4]||(s[4]=t(" при старте операционной системы. Этот номер впоследствии не может быть присвоен никакому другому процессу. Максимально возможное значение для номера процесса в Linux на базе 32-разрядных процессоров Intel составляет ")),i("mjx-container",h,[(p(),n("svg",d,s[0]||(s[0]=[a("",1)]))),s[1]||(s[1]=i("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[i("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[i("msup",null,[i("mn",null,"2"),i("mrow",{"data-mjx-texclass":"ORD"},[i("mn",null,"31")])]),i("mo",null,"−"),i("mn",null,"1")])],-1))]),s[5]||(s[5]=t('. Процессы создают иерархию в виде дерева. Самым "главным" предком, то есть процессом, стоящим на вершине этого дерева, является процесс ')),s[6]||(s[6]=i("code",null,"init (PID=1)",-1)),s[7]||(s[7]=t("."))]),s[21]||(s[21]=a("",37)),s[22]||(s[22]=i("iframe",{src:"https://viewer.diagrams.net/?highlight=0000ff&layers=1&nav=1&title=Diagram#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D16wwivex5uqbn5z3tFI2dFyDnMa358Emc%26export%3Ddownload",width:"100%",height:"600px",frameborder:"0",allowfullscreen:""},null,-1)),s[23]||(s[23]=a("",50))])}const E=l(e,[["render",k]]);export{y as __pageData,E as default};
