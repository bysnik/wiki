import{_ as t,c as s,o as r,j as o}from"./chunks/framework.D4Vqf8I7.js";const D=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/disciplines/osis/l9.md","filePath":"docs/disciplines/osis/l9.md","lastUpdated":1760531635000}'),c={name:"docs/disciplines/osis/l9.md"};function i(n,e,a,S,d,N){return r(),s("div",null,e[0]||(e[0]=[o("p",null,'Основы операционных систем 153 либо отброшена (если процесса-адресата на данном компьютере нет), либо доставлена по назначению. Так как все данные постоянно передаются от одного комплекса ко всем остальным, такую одноуровне- вую схему обычно применяют только в локальных сетях с прямой физической связью всех компьютеров между собой (например, в сети NetBIOS на базе Ethernet), но она является существенно менее эффектив- ной, чем двухуровневая схема адресации. Двухуровневые адреса При двухуровневой адресации полный сетевой адрес процесса или промежуточного объекта для хране- ния данных складывается из двух частей – адреса вычислительного комплекса, на котором находится процесс или объект в сети (удаленного адреса), и адреса самого процесса или объекта на этом вычисли- тельном комплексе (локального адреса). Уникальность полного адреса будет обеспечиваться уникально- стью удаленного адреса для каждого компьютера в сети и уникальностью локальных адресов объектов на компьютере. Давайте подробнее рассмотрим проблемы, возникающие для каждого из компонентов пол- ного адреса. Удаленная адресация и разрешение адресов Инициатором связи процессов друг с другом всегда является человек, будь то программист или обычный пользователь. Как мы неоднократно отмечали в лекциях, человеку свойственно думать словами, он легче воспринимает символьную информацию. Поэтому очевидно, что каждая машина в сети получает сим- вольное, часто даже содержательное имя. Компьютер не разбирается в смысловом содержании символов, ему проще оперировать числами, желательно одного и того же формата, которые помещаются, например, в 4 байта или в 16 байт. Поэтому каждый компьютер в сети для удобства работы вычислительных систем получает числовой адрес. Возникает проблема отображения пространства символьных имен (или адре- сов) вычислительных комплексов в пространство их числовых адресов. Эта проблема получила наимено- вание проблемы разрешения адресов. С подобными задачами мы уже сталкивались, обсуждая организацию памяти в вычислительных системах (отображение имен переменных в их адреса в процессе компиляции и редактирования связей) и органи- зацию файловых систем (отображение имен файлов в их расположении на диске). Посмотрим, как она может быть решена в сетевом варианте. Первый способ решения заключается в том, что на каждом сетевом компьютере создается файл, содер- жащий имена всех машин, доступных по сети, и их числовые эквиваленты. Обращаясь к этому файлу, операционная система легко может перевести символьный удаленный адрес в числовую форму. Такой подход использовался на заре эпохи глобальных сетей и применяется в изолированных локальных сетях в настоящее время. Действительно, легко поддерживать файл соответствий в корректном виде, внося в него необходимые изменения, когда общее число сетевых машин не превышает нескольких десятков. Как правило, изменения вносятся на некотором выделенном административном вычислительном ком- плексе, откуда затем обновленный файл рассылается по всем компонентам сети. В современной сетевой паутине этот подход является неприемлемым. Дело даже не в размерах подобно- го файла, а в частоте требуемых обновлений и в огромном количестве рассылок, что может полностью подорвать производительность сети. Проблема состоит в том, что добавление или удаление компонента сети требует внесения изменений в файлы на всех сетевых машинах. Второй метод разрешения адресов заключается в частичном распределении информации о соответствии символьных и числовых адресов по многим комплексам сети, так что каждый из этих комплексов содержит лишь часть полных данных. Он же определяет и правила построения символических имен компьютеров. Один из таких способов, используемый в Internet, получил английское наименование Domain Name Service или сокращенно DNS. Эта аббревиатура широко используется и в русскоязычной литературе. Да- вайте рассмотрим данный метод подробнее. Организуем логически все компьютеры сети в некоторую древовидную структуру, напоминающую структуру директорий файловых систем, в которых отсутствует возможность организации жестких и мягких связей и нет пустых директорий. Будем рассматривать все компьютеры, входящие во Всемирную Основы операционных систем 154 сеть, как область самого низкого ранга (аналог корневой директории в файловой системе) – ранга 0. Ра- зобьем все множество компьютеров области на какое-то количество подобластей (domains). При этом не- которые подобласти будут состоять из одного компьютера (аналоги регулярных файлов в файловых сис- темах), а некоторые – более чем из одного компьютера (аналоги директорий в файловых системах). Каж- дую подобласть будем рассматривать как область более высокого ранга. Присвоим подобластям собст- венные имена таким образом, чтобы в рамках разбиваемой области все они были уникальны. Повторим такое разбиение рекурсивно для каждой области более высокого ранга, которая состоит более чем из од- ного компьютера, несколько раз, пока при последнем разбиении в каждой подобласти не окажется ровно по одному компьютеру. Глубина рекурсии для различных областей одного ранга может быть разной, но обычно в целом ограничиваются 3 – 5 разбиениями, начиная от ранга 0. В результате мы получим дерево, неименованной вершиной которого является область, объединяющая все компьютеры, входящие во Всемирную сеть, именованными терминальными узлами – отдельные компьютеры (точнее – подобласти, состоящие из отдельных компьютеров), а именованными нетерми- нальными узлами – области различных рангов. Используем полученную структуру для построения имен компьютеров, подобно тому как мы поступали при построении полных имен файлов в структуре дирек- торий файловой системы. Только теперь, двигаясь от корневой вершины к терминальному узлу – отдель- ному компьютеру, будем вести запись имен подобластей справа налево и отделять имена друг от друга с помощью символа ".". Допустим, некоторая подобласть, состоящая из одного компьютера, получила имя serv, она входит в по- добласть, объединяющую все компьютеры некоторой лаборатории, с именем crec. Та, в свою очередь, входит в подобласть всех компьютеров Московского физико-технического института с именем mipt, ко- торая включается в область ранга 1 всех компьютеров России с именем ru. Тогда имя рассматриваемого компьютера во Всемирной сети будет serv.crec.mipt.ru. Аналогичным образом можно именовать и подоб- ласти, состоящие более чем из одного компьютера. В каждой полученной именованной области, состоящей более чем из одного узла, выберем один из ком- пьютеров и назначим его ответственным за эту область – сервером DNS. Сервер DNS знает числовые ад- реса серверов DNS для подобластей, входящих в его зону ответственности, или числовые адреса отдель- ных компьютеров, если такая подобласть включает в себя только один компьютер. Кроме того, он также знает числовой адрес сервера DNS, в зону ответственности которого входит рассматриваемая область (если это не область ранга 1), или числовые адреса всех серверов DNS ранга 1 (в противном случае). От- дельные компьютеры всегда знают числовые адреса серверов DNS, которые непосредственно за них от- вечают. Рассмотрим теперь, как процесс на компьютере serv.crec.mipt.ru может узнать числовой адрес компьюте- ра ssp.brown.edu. Для этого он обращается к своему DNS-серверу, отвечающему за область crec.mipt.ru, и передает ему нужный адрес в символьном виде. Если этот DNS-сервер не может сразу представить необ- ходимый числовой адрес, он передает запрос DNS-серверу, отвечающему за область mipt.ru. Если и тот не в силах самостоятельно справиться с проблемой, он перенаправляет запрос серверу DNS, отвечающе- му за область 1-го ранга ru. Этот сервер может обратиться к серверу DNS, обслуживающему область 1-го ранга edu, который, наконец, затребует информацию от сервера DNS области brown.edu, где должен быть нужный числовой адрес. Полученный числовой адрес по всей цепи серверов DNS в обратном порядке будет передан процессу, направившему запрос (см. рис. 14.2). Основы операционных систем 155 Рис. 14.2. Пример разрешения имен с использованием DNS-серверов В действительности, каждый сервер DNS имеет достаточно большой кэш, содержащий адреса серверов DNS для всех последних запросов. Поэтому реальная схема обычно существенно проще, из приведенной цепочки общения DNS-серверов выпадают многие звенья за счет обращения напрямую. Рассмотренный способ разрешения адресов позволяет легко добавлять компьютеры в сеть и исключать их из сети, так как для этого необходимо внести изменения только на DNS-сервере соответствующей об- ласти. Если DNS-сервер, отвечающий за какую-либо область, выйдет из строя, то может оказаться невозмож- ным разрешение адресов для всех компьютеров этой области. Поэтому обычно назначается не один сер- вер DNS, а два – основной и запасной. В случае выхода из строя основного сервера его функции немед- ленно начинает выполнять запасной. В реальных сетевых вычислительных системах обычно используется комбинация рассмотренных подхо- дов. Для компьютеров, с которыми чаще всего приходится устанавливать связь, в специальном файле хранится таблица соответствий символьных и числовых адресов. Все остальные адреса разрешаются с использованием служб, аналогичных службе DNS. Способ построения удаленных адресов и методы раз- решения адресов обычно определяются протоколами сетевого уровня эталонной модели. Мы разобрались с проблемой удаленных адресов и знаем, как получить числовой удаленный адрес нуж- ного нам компьютера. Давайте рассмотрим теперь проблему адресов локальных: как нам задать адрес процесса или объекта для хранения данных на удаленном компьютере, который в конечном итоге и дол- жен получить переданную информацию. Локальная адресация. Понятие порта Во второй лекции мы говорили, что каждый процесс, существующий в данный момент в вычислительной системе, уже имеет собственный уникальный номер – PID. Но этот номер неудобно использовать в каче- стве локального адреса процесса при организации удаленной связи. Номер, который получает процесс при рождении, определяется моментом его запуска, предысторией работы вычислительного комплекса и является в значительной степени случайным числом, изменяющимся от запуска к запуску. Представьте себе, что адресат, с которым вы часто переписываетесь, постоянно переезжает с место на место, меняя адреса, так что, посылая очередное письмо, вы не можете с уверенностью сказать, где он сейчас прожи- вает, и поймете все неудобство использования идентификатора процесса в качестве его локального адре- са. Все сказанное выше справедливо и для идентификаторов промежуточных объектов, использующихся при локальном взаимодействии процессов в схемах с непрямой адресацией. Основы операционных систем 156 Для локальной адресации процессов и промежуточных объектов при удаленной связи обычно организу- ется новое специальное адресное пространство, например представляющее собой ограниченный набор положительных целочисленных значений или множество символических имен, аналогичных полным именам файлов в файловых системах. Каждый процесс, желающий принять участие в сетевом взаимо- действии, после рождения закрепляет за собой один или несколько адресов в этом адресном пространст- ве. Каждому промежуточному объекту при его создании присваивается свой адрес из этого адресного пространства. При этом удаленные пользователи могут заранее договориться о том, какие именно адреса будут зарезервированы для данного процесса, независимо от времени его старта, или для данного объек- та, независимо от момента его создания. Подобные адреса получили название портов, по аналогии с пор- тами ввода-вывода. Необходимо отметить, что в системе может существовать несколько таких адресных пространств для различных способов связи. При получении данных от удаленного процесса операционная система смот- рит, на какой порт и для какого способа связи они были отправлены, определяет процесс, который заявил этот порт в качестве своего адреса, или объект, которому присвоен данный адрес, и доставляет получен- ную информацию адресату. Виды адресного пространства портов (т. е. способы построения локальных адресов) определяются, как правило, протоколами транспортного уровня эталонной модели. Полные адреса. Понятие сокета (socket) Таким образом, полный адрес удаленного процесса или промежуточного объекта для конкретного спосо- ба связи с точки зрения операционных систем определяется парой адресов: <числовой адрес компьютера в сети, порт>. Подобная пара получила наименование socket (в переводе – "гнездо" или, как стали писать в последнее время, сокет), а сам способ их использования – организация связи с помощью сокетов. В случае непрямой адресации с использованием промежуточных объектов сами эти объекты также принято называть сокетами. Поскольку разные протоколы транспортного уровня требуют разных адресных про- странств портов, то для каждой пары надо указывать, какой транспортный протокол она использует, – говорят о разных типах сокетов. В современных сетевых системах числовой адрес обычно получает не сам вычислительный комплекс, а его сетевой адаптер, с помощью которого комплекс подключается к линии связи. При наличии несколь- ких сетевых адаптеров для разных линий связи один и тот же вычислительный комплекс может иметь несколько числовых адресов. В таких системах полные адреса удаленного адресата (процесса или про- межуточного объекта) задаются парами <числовой адрес сетевого адаптера, порт> и требуют доставки информации через указанный сетевой адаптер. Проблемы маршрутизации в сетях При наличии прямой линии связи между двумя компьютерами обычно не возникает вопросов о том, ка- ким именно путем должна быть доставлена информация. Но, как уже упоминалось, одно из отличий взаимодействия удаленных процессов от взаимодействия процессов локальных состоит в использовании в большинстве случаев процессов-посредников, расположенных на вычислительных комплексах, не яв- ляющихся комплексами отправителя и получателя. В сложных топологических схемах организации сетей информация между двумя компьютерами может передаваться по различным путям. Возникает вопрос: как организовать работу операционных систем на комплексах -участниках связи (это могут быть конеч- ные или промежуточные комплексы) для определения маршрута передачи данных? По какой из несколь- ких линий связи (или через какой сетевой адаптер) нужно отправить пакет информации? Какие протоко- лы маршрутизации возможны? Существует два принципиально разных подхода к решению этой пробле- мы: маршрутизация от источника передачи данных и одношаговая маршрутизация. • Маршрутизация от источника передачи данных. При маршрутизации от источника данных пол- ный маршрут передачи пакета по сети формируется на компьютере-отправителе в виде последова- тельности числовых адресов сетевых адаптеров, через которые должен пройти пакет, чтобы доб- раться до компьютера-получателя, и целиком включается в состав этого пакета. В этом случае промежуточные компоненты сети при определении дальнейшего направления движения пакета не принимают самостоятельно никаких решений, а следуют указаниям, содержащимся в пакете. Основы операционных систем 157 • Одношаговая маршрутизация. При одношаговой маршрутизации каждый компонент сети, прини- мающий участие в передаче информации, самостоятельно определяет, какому следующему ком- поненту, находящемуся в зоне прямого доступа, она должна быть отправлена. Решение принима- ется на основании анализа содержащегося в пакете адреса получателя. Полный маршрут передачи данных складывается из одношаговых решений, принятых компонентами сети. Маршрутизация от источника передачи данных легко реализуется на промежуточных компонентах сети, но требует полного знания маршрутов на конечных компонентах. Она достаточно редко используется в современных сетевых системах, и далее мы ее рассматривать не будем. Для работы алгоритмов одношаговой маршрутизации, которые являются основой соответствующих протоколов, на каждом компоненте сети, имеющем возможность передавать информацию более чем од- ному компоненту, обычно строится специальная таблица маршрутов (см. рис. 14.3). В простейшем слу- чае каждая запись такой таблицы содержит: адрес вычислительного комплекса получателя; адрес компо- нента сети, напрямую подсоединенного к данному, которому следует отправить пакет, предназначенный для этого получателя; указание о том, по какой линии связи (через какой сетевой адаптер) должен быть отправлен пакет. Поскольку получателей в сети существует огромное количество, для сокращения числа записей в таблице маршрутизации обычно прибегают к двум специальным приемам. Во-первых, числовые адреса топологически близко расположенных комплексов (например, комплексов, принадлежащих одной локальной вычислительной сети) стараются выбирать из последовательного диа- пазона адресов. В этом случае запись в таблице маршрутизации может содержать не адрес конкретного получателя, а диапазон адресов для некоторой сети (номер сети). Во-вторых, если для очень многих получателей в качестве очередного узла маршрута используется один и тот же компонент сети, а остальные маршруты выбираются для ограниченного числа получателей, то в таблицу явно заносятся только записи для этого небольшого количества получателей, а для маршрута, ведущего к большей части всей сети, делается одна запись – маршрутизация по умолчанию (default). Пример простой таблицы маршрутизации для некоторого комплекса некой абстрактной сети приведен ниже: Рис. 14.3. Простая таблица маршрутизации По способам формирования и использования таблиц маршрутизации алгоритмы одношаговой маршру- тизации можно разделить на три класса: • алгоритмы фиксированной маршрутизации; • алгоритмы простой маршрутизации; • алгоритмы динамической маршрутизации. При фиксированной маршрутизации таблица, как правило, создается в процессе загрузки операционной системы. Все записи в ней являются статическими. Линия связи, которая будет использоваться для дос- тавки информации от данного узла к некоторому узлу A в сети, выбирается раз и навсегда. Обычно ли- нии выбирают так, чтобы минимизировать полное время доставки данных. Преимуществом этой страте- гии является простота реализации. Основной же недостаток заключается в том, что при отказе выбран- ной линии связи данные не будут доставлены, даже если существует другой физический путь для их пе- редачи. Основы операционных систем 158 В алгоритмах простой маршрутизации таблица либо не используется совсем, либо строится на основе анализа адресов отправителей приходящих пакетов информации. Различают несколько видов простой маршрутизации – случайную, лавинную и маршрутизацию по прецедентам. При случайной маршру- тизации прибывший пакет отсылается в первом попавшемся направлении, кроме исходного. При лавин- ной маршрутизации один и тот же пакет рассылается по всем направлениям, кроме исходного. Случайная и лавинная маршрутизации, естественно, не используют таблиц маршрутов. При маршрутизации по пре- цедентам таблица маршрутизации строится по предыдущему опыту, исходя из анализа адресов отправи- телей приходящих пакетов. Если прибывший пакет адресован компоненту сети, от которого когда-либо приходили данные, то соответствующая запись об этом содержится в таблице маршрутов, и для даль- нейшей передачи пакета выбирается линия связи, указанная в таблице. Если такой записи нет, то пакет может быть отослан случайным или лавинным способом. Алгоритмы простой маршрутизации действи- тельно просты в реализации, но отнюдь не гарантируют доставку пакета указанному адресату за прием- лемое время и по рациональному маршруту без перегрузки сети. Наиболее гибкими являются алгоритмы динамической или адаптивной маршрутизации, которые умеют обновлять содержимое таблиц маршрутов на основе обработки специальных сообщений, прихо- дящих от других компонентов сети, занимающихся маршрутизацией, удовлетворяющих определенному протоколу. Такие алгоритмы принято делить на два подкласса: алгоритмы дистанционно-векторные и алгоритмы состояния связей. При дистанционно-векторной маршрутизации компоненты операционных систем на соседних вычисли- тельных комплексах сети, занимающиеся выбором маршрута (их принято называть маршрутизатор или router), периодически обмениваются векторами, которые представляют собой информацию о расстояни- ях от данного компонента до всех известных ему адресатов в сети. Под расстоянием обычно понимается количество переходов между компонентами сети (hops), которые необходимо сделать, чтобы достичь адресата, хотя возможно существование и других метрик, включающих скорость и/или стоимость пере- дачи пакета по линии связи. Каждый такой вектор формируется на основании таблицы маршрутов. При- шедшие от других комплексов векторы модернизируются с учетом расстояния, которое они прошли при последней передаче. Затем в таблицу маршрутизации вносятся изменения, так чтобы в ней содержались только маршруты с кратчайшими расстояниями. При достаточно длительной работе каждый маршрути- затор будет иметь таблицу маршрутизации с оптимальными маршрутами ко всем потенциальным адреса- там. Векторно-дистанционные протоколы обеспечивают достаточно разумную маршрутизацию пакетов, но не способны предотвратить возможность возникновения маршрутных петель при сбоях в работе сети. По- этому векторно-дистанционная маршрутизация может быть эффективна только в относительно неболь- ших сетях. Для больших сетей применяются алгоритмы состояния связей, на каждом маршрутизаторе строящие графы сети, в качестве узлов которого выступают ее компоненты, а в качестве ребер, обла- дающих стоимостью, существующие между ними линии связи. Маршрутизаторы периодически обмени- ваются графами и вносят в них изменения. Выбор маршрута связан с поиском оптимального по стоимо- сти пути по такому графу. Подробное описание протоколов динамической маршрутизации можно найти в [Олифер, 2002], [Таненбаум, 2003]. Обычно вычислительные сети используют смесь различных стратегий маршрутизации. Для одних адре- сов назначения может использоваться фиксированная маршрутизация, для других – простая, для третьих – динамическая. В локальных вычислительных сетях обычно используются алгоритмы фиксированной маршрутизации, в отличие от глобальных вычислительных сетей, в которых в основном применяют ал- горитмы адаптивной маршрутизации. Протоколы маршрутизации относятся к сетевому уровню эталон- ной модели. Связь с установлением логического соединения и передача данных с помощью сообще- ний Рассказывая об отличиях взаимодействия локальных и удаленных процессов, мы упомянули, что в осно- ве всех средств связи на автономном компьютере так или иначе лежит механизм совместного использо- Основы операционных систем 159 вания памяти, в то время как в основе всех средств связи между удаленными процессами лежит передача сообщений. Неудивительно, что количество категорий средств удаленной связи сокращается до одной – канальных средств связи. Обеспечивать интерфейс для сигнальных средств связи и разделяемой памяти, базируясь на передаче пакетов данных, становится слишком сложно и дорого. Рассматривая канальные средства связи для локальных процессов в лекции 4, мы говорили о существо- вании двух моделей передачи данных по каналам связи (теперь мы можем говорить о двух принципиаль- но разных видах протоколов организации канальной связи): поток ввода-вывода и сообщения. Для обще- ния удаленных процессов применяются обе модели, однако теперь уже более простой моделью становит- ся передача информации с помощью сообщений. Реализация различных моделей происходит на основе протоколов транспортного уровня OSI/ISO. Транспортные протоколы связи удаленных процессов, которые предназначены для обмена сообщениями, получили наименование протоколов без установления логического соединения (connectionless) или протоколов обмена датаграммами, поскольку само сообщение здесь принято называть датаграммой (datagramm) или дейтаграммой. Каждое сообщение адресуется и посылается процессом индивидуаль- но. С точки зрения операционных систем все датаграммы – это независимые единицы, не имеющие ниче- го общего с другими датаграммами, которыми обмениваются эти же процессы. Необходимо отметить, что с точки зрения процессов, обменивающихся информацией, датаграммы, ко- нечно, могут быть связаны по содержанию друг с другом, но ответственность за установление и поддер- жание этой семантической связи лежит не на сетевых частях операционных систем, а на самих пользова- тельских взаимодействующих процессах (вышележащие уровни эталонной модели). По-другому обстоит дело с транспортными протоколами, которые поддерживают потоковую модель. Они получили наименование протоколов, требующих установления логического соединения (connection-oriented). И в их основе лежит передача данных с помощью пакетов информации. Но опера- ционные системы сами нарезают эти пакеты из передаваемого потока данных, организовывают правиль- ную последовательность их получения и снова объединяют полученные пакеты в поток, так что с точки зрения взаимодействующих процессов после установления логического соединения они имеют дело с потоковым средством связи, напоминающим pipe или FIFO. Эти протоколы должны обеспечивать на- дежную связь. Синхронизация удаленных процессов Мы рассмотрели основные принципы логической организации сетевых средств связи, внешние по отно- шению к взаимодействующим процессам. Однако, как отмечалось в лекции 5, для корректной работы та- ких процессов необходимо обеспечить определенную их синхронизацию, которая устранила бы возник- новение race condition на соответствующих критических участках. Вопросы синхронизации удаленных процессов обычно рассматриваются в курсах, посвященных распределенным операционным системам. Интересующиеся этими вопросами могут обратиться к книгам [Silberschatz, 2002], [Таненбаум II, 2003]. Заключение Основными причинами объединения компьютеров в вычислительные сети являются потребности в раз- делении ресурсов, ускорении вычислений, повышении надежности и облегчении общения пользователей. Вычислительные комплексы в сети могут находиться под управлением сетевых или распределенных вы- числительных систем. Основой для объединения компьютеров в сеть служит взаимодействие удаленных процессов. При рассмотрении вопросов организации взаимодействия удаленных процессов нужно при- нимать во внимание основные отличия их кооперации от кооперации локальных процессов. Базой для взаимодействия локальных процессов служит организация общей памяти, в то время как для удаленных процессов – это обмен физическими пакетами данных. Организация взаимодействия удаленных процессов требует от сетевых частей операционных систем поддержки определенных протоколов. Сетевые средства связи обычно строятся по "слоеному" принципу. Основы операционных систем 160 Формальный перечень правил, определяющих последовательность и формат сообщений, которыми об- мениваются сетевые компоненты различных вычислительных систем, лежащие на одном уровне, называ- ется сетевым протоколом. Каждый уровень слоеной системы может взаимодействовать непосредственно только со своими вертикальными соседями, руководствуясь четко закрепленными соглашениями – вер- тикальными протоколами или интерфейсами. Вся совокупность интерфейсов и сетевых протоколов в се- тевых системах, построенных по слоеному принципу, достаточная для организации взаимодействия уда- ленных процессов, образует семейство протоколов или стек протоколов. Удаленные процессы, в отличие от локальных, при взаимодействии обычно требуют двухуровневой ад- ресации при своем общении. Полный адрес процесса состоит из двух частей: удаленной и локальной. Для удаленной адресации используются символьные и числовые имена узлов сети. Перевод имен из од- ной формы в другую (разрешение имен) может осуществляться с помощью централизованно обновляе- мых таблиц соответствия полностью на каждом узле или с использованием выделения зон ответственно- сти специальных серверов. Для локальной адресации процессов применяются порты. Упорядоченная па- ра из адреса узла в сети и порта получила название socket. Для доставки сообщения от одного узла к другому могут использоваться различные протоколы маршру- тизации. С точки зрения пользовательских процессов обмен информацией может осуществляться в виде дата- грамм или потока данных.',-1)]))}const l=t(c,[["render",i]]);export{D as __pageData,l as default};
