import{_ as a,c as i,o as n,ag as p}from"./chunks/framework.D4Vqf8I7.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/wi/altsp/43.isolate_app.md","filePath":"docs/wi/altsp/43.isolate_app.md","lastUpdated":1770026896000}'),e={name:"docs/wi/altsp/43.isolate_app.md"};function h(t,s,l,k,r,d){return n(),i("div",null,s[0]||(s[0]=[p(`<p>Операционная система должна включать ==автоматизированные средства изоляции приложений, чувствительных к сетевым атакам==.</p><hr><p>chroot показываем</p><p>Продемонстрировать наличие соответствующих возможностей</p><p>Демонстрация работы автоматизированного средства изоляции приложений, чувствительных к сетевым атакам (например ping от root).</p><p>strace -o ping.log ping -c 3 127.0.0.1</p><p>less ping.log | grep chroot</p><p>cat ping.log | grep chroot<br> chroot(&quot;/var/resolv&quot;)</p><p>Дополнительно выполнить следующую команду, чтобы показать пакеты, которые используют update_chrooted для подготовки своих чрутов. (или чрута /var/resolv)</p><p>apt-cache whatdepends chrooted</p><p><code>firejail</code> - Firejail представляет собой готовый для использования инструмент запуска приложений внутри изолированной среды. Для создания изолированных окружений firejail использует такие механизмы ядра Linux, как namespaces, cgroups и seccomp <a href="https://vaiti.io/utilita-firejail-gotovaya-pesochnicza-dlya-vashih-prilozhenij/" target="_blank" rel="noreferrer">https://vaiti.io/utilita-firejail-gotovaya-pesochnicza-dlya-vashih-prilozhenij/</a></p><p><code>bubblewrap</code> - Аналогично <strong>firejail</strong> для создания изолированных окружений. <strong>bubblewrap</strong> использует такие механизмы ядра Linux, как namespaces и seccomp <a href="https://vaiti.io/bubblewrap-gibkij-instrument-sozdaniya-pesochnicz/" target="_blank" rel="noreferrer">https://vaiti.io/bubblewrap-gibkij-instrument-sozdaniya-pesochnicz/</a></p><p><code>fail2ban</code> присутствует <a href="https://www.altlinux.org/Fail2ban" target="_blank" rel="noreferrer">https://www.altlinux.org/Fail2ban</a> , но это защита только от брутфорса</p><p>Также, в репозитории есть великие и ужасные <code>Docker</code> и <code>Podman (+ Podsec)</code> - это у нас более мощная изоляция, её ещё контейнеризацией называют)</p><p>![[Pasted image 20250606164004.png]]</p><p>Ну, чисто технически, есть фаерволл, но вот слово ИЗОЛЯЦИЯ меня смущает</p><h2 id="linux-namespaces" tabindex="-1">Linux namespaces <a class="header-anchor" href="#linux-namespaces" aria-label="Permalink to &quot;Linux namespaces&quot;">​</a></h2><p>==!!!На практике голые namespace использовать КРАЙНЕ сложно в связи с объемностью современных программ!!!==</p><p>Когда процессы в Linux имеют доступ ко всем системным ресурсам, это может создавать проблемы. Хорошо бы их отделить и друг от друга, и от тех частей системы, которые им все равно не нужны. Вот тут-то и пригодится инструмент namespace.</p><p>Он создает изолированные «песочницы» для процессов, каждая из которых функционирует независимо от других. В результате каждая группа процессов может иметь собственное представление о системных ресурсах.</p><p>В современных версиях ядра Linux, таких как 6.12.1, существует восемь типов «песочниц», каждая из которых играет свою роль в изоляции ресурсов и безопасности системы. Чтобы изолировать процессы с помощью Linux namespace, необходимо использовать команду unshare или другие утилиты, такие как ip для сетевой изоляции. Основная идея — это создание нового пространства для процессов, которые должны работать независимо друг от друга. Итак, перейдем к пошаговой инструкции.</p><h3 id="pid-namespace" tabindex="-1">PID namespace <a class="header-anchor" href="#pid-namespace" aria-label="Permalink to &quot;PID namespace&quot;">​</a></h3><p>Это пространство отвечает за изоляцию дерева процессов. Другими словами, каждый процесс видит только то, что происходит внутри его «песочницы». А вот доступа к происходящему на уровне хоста у него нет. Создадим такой процесс.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Создаем новый PID namespace и запускаем bash в нем</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> unshare</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --pid</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --fork</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --mount-proc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /bin/bash</span></span></code></pre></div><p>В этом случае процессы, запущенные внутри пространства, будут изолированы и не смогут вмешиваться в работу других процессов на хосте. Команды вроде ps aux покажут только процессы, запущенные в нем.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Проверяем список процессов в новом namespace</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> aux</span></span></code></pre></div><p>В результате увидим, что у процесса будет собственный список других процессов в новом пространстве, но не на хосте.</p><h3 id="net-namespace" tabindex="-1">NET namespace <a class="header-anchor" href="#net-namespace" aria-label="Permalink to &quot;NET namespace&quot;">​</a></h3><p>С помощью NET namespace можно создать изолированную сеть для процесса. Это полезно для создания контейнеров, каждый из которых будет иметь собственный сетевой интерфейс, IP-адреса и маршруты. Пример создания нового сетевого пространства:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Создаем новый сетевой namespace</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> netns</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mynetns</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Запускаем bash в новом namespace</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> netns</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> exec</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mynetns</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bash</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Проверяем сетевые интерфейсы в новом namespace</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> link</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> show</span></span></code></pre></div><p>В новом пространстве будет виден только локальный интерфейс. Сетевые интерфейсы, настроенные на хосте, не будут доступны.</p><p>Если у вас есть несколько приложений, которые должны работать с независимыми сетями, вы можете использовать NET namespace для создания изолированных сетевых пространств, например, для тестирования приложений с разными IP-адресами.</p><p>Пример: запускаем два приложения, каждое в своем сетевом пространстве, чтобы они не могли взаимодействовать друг с другом:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Создаем два разных сетевых namespace</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> netns</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app1_net</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> netns</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app2_net</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Запускаем приложение в первом namespace</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> netns</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> exec</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app1_net</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /bin/bash</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Запускаем приложение во втором namespace</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> netns</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> exec</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app2_net</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /bin/bash</span></span></code></pre></div><p>Каждое приложение будет работать в своей изолированной сети. Это предотвращает конфликт между сетевыми интерфейсами.</p><h3 id="mnt-namespace" tabindex="-1">MNT namespace <a class="header-anchor" href="#mnt-namespace" aria-label="Permalink to &quot;MNT namespace&quot;">​</a></h3><p>MNT namespace позволяет изолировать друг от друга файловые системы, создавая уникальные точки монтирования для каждого процесса. Пример:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Создаем новый MNT namespace</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> unshare</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --mount</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /bin/bash</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Монтируем файловую систему в новом namespace</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mount</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tmpfs</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tmpfs</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /mnt</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Проверяем точки монтирования</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /mnt</span></span></code></pre></div><p>После выполнения этих команд появится отдельная точка монтирования, которая не будет видна процессам на уровне хоста.</p><h3 id="uts-namespace" tabindex="-1">UTS namespace <a class="header-anchor" href="#uts-namespace" aria-label="Permalink to &quot;UTS namespace&quot;">​</a></h3><p>UTS namespace позволяет изолировать имя хоста и домен. Это полезно, когда нужно, чтобы процессы в изолированном пространстве имели разные имена хоста. Пример:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Создаем новый UTS namespace</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> unshare</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -u</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /bin/bash</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Меняем имя хоста</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hostname</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> newname</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Проверяем имя хоста</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hostname</span></span></code></pre></div><p>В этом случае имя хоста будет изменено только в пределах пространства, не затрагивая имя хоста на уровне всей системы.</p><h3 id="ipc-namespace" tabindex="-1">IPC namespace <a class="header-anchor" href="#ipc-namespace" aria-label="Permalink to &quot;IPC namespace&quot;">​</a></h3><p>Используется для изоляции механизмов межпроцессного взаимодействия, таких как очереди сообщений, семафоры и общая память. Процессы внутри одного IPC namespace не могут взаимодействовать с процессами в других пространствах.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Создаем новый IPC namespace</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> unshare</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --ipc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /bin/bash</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Проверяем текущие IPC-ресурсы</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ipcs</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Попробуем создать очереди сообщений (это будет ограничено только для процессов в новом IPC namespace)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">msgctl(IPC_PRIVATE,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> IPC_CREAT,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0666</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Это помогает изолировать различные компоненты системы или контейнеров, ограничивая их доступ к общим ресурсам.</p><h3 id="user-namespace" tabindex="-1">USER namespace <a class="header-anchor" href="#user-namespace" aria-label="Permalink to &quot;USER namespace&quot;">​</a></h3><p>Позволяет изолировать идентификаторы пользователей и групп (UID/GID). Это дает возможность создавать контейнеры, где процессы работают с различными правами, не затрагивая хост-систему. Такой подход полезен для повышения безопасности, так как контейнеры могут иметь собственные UID и GID, даже если они принадлежат той же системе. Создадим новый USER namespace:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Создаем новый USER namespace с маппингом UID и GID</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> unshare</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --user</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --map-root-user</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /bin/bash</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Проверяем UID и GID в новом namespace</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">id</span></span></code></pre></div><h3 id="cgroup-namespace" tabindex="-1">CGROUP namespace <a class="header-anchor" href="#cgroup-namespace" aria-label="Permalink to &quot;CGROUP namespace&quot;">​</a></h3><p>Используется для изоляции виртуальной файловой системы cgroup, которая управляет выделением ресурсов (например, CPU, память и сеть) для групп процессов. Это важно для контроля над ресурсами, особенно в контейнерных средах или для разделения нагрузки междеу различными процессами.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Создаем новый cgroup для ограничения памяти</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cgcreate</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> memory:/mygroup</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Ограничиваем память для группы процессов</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 100M</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /sys/fs/cgroup/memory/mygroup/memory.limit_in_bytes</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Запускаем процесс в этом cgroup</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cgexec</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> memory:mygroup</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /bin/bash</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Проверяем, что ограничения памяти применяются</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /sys/fs/cgroup/memory/mygroup/memory.limit_in_bytes</span></span></code></pre></div><p>Этот пример показывает, как ограничить память для группы процессов с использованием cgroup.</p><h3 id="time-namespace" tabindex="-1">Time namespace <a class="header-anchor" href="#time-namespace" aria-label="Permalink to &quot;Time namespace&quot;">​</a></h3><p>Time namespace используется для изоляции временных параметров, таких как системное время или настройки временной зоны. Процессы внутри одного Time namespace могут иметь собственное время, не влияя на время хостовой системы. Это особенно полезно для тестирования приложений или работы с контейнерами, требующими отдельного временного окружения.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Создаем новый Time namespace  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> unshare</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --time</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /bin/bash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Проверяем текущее время  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Изменяем время в новом namespace  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">date</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --set=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2025-01-01 00:00:00&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Убедимся, что изменения касаются только текущего namespace  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">date</span></span></code></pre></div><p>Time namespace помогает в следующих сценариях:</p><ul><li>Эмулирование будущих или прошлых дат для тестирования приложений.</li><li>Настройка временных зон для различных контейнеров.</li><li>Предотвращение влияния изменений системного времени на хостовую систему.</li></ul><p>Изоляция процессов позволяет не только минимизировать риски, связанные с эскалацией привилегий. Благодаря ей также можно повысить эффективность управления ресурсами, выделяя их конкретным процессам или приложениям, не влияя на систему в целом. Изоляция, как правило, получается достаточно гибкой, поэтому ее удобно применять в контейнерных средах и приложениях с микросервисной архитектурой.</p>`,60)]))}const o=a(e,[["render",h]]);export{F as __pageData,o as default};
