import{_ as n,c as t,o as r,ag as o}from"./chunks/framework.D4Vqf8I7.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/disciplines/osis/l1.md","filePath":"docs/disciplines/osis/l1.md","lastUpdated":1756218475000}'),s={name:"docs/disciplines/osis/l1.md"};function g(i,p,e,l,a,u){return r(),t("div",null,p[0]||(p[0]=[o('<h3 id="_1-лекция-1-понятие-ос-краткая-история-эволюции-выч-сист-функции-ос-концепции-ос-архитектурные-особ-и-классифик-ос" tabindex="-1">1. Лекция 1. Понятие ос,Краткая история эволюции выч сист, функции ос, концепции ос, архитектурные особ и классифик ос. <a class="header-anchor" href="#_1-лекция-1-понятие-ос-краткая-история-эволюции-выч-сист-функции-ос-концепции-ос-архитектурные-особ-и-классифик-ос" aria-label="Permalink to &quot;1. Лекция 1. Понятие ос,Краткая история эволюции выч сист, функции ос, концепции ос, архитектурные особ и классифик ос.&quot;">​</a></h3><p><strong>Введение</strong></p><p>На сегодняшней лекции мы рассмотрим различные взгляды на то, что такое операционная система; изучим историю развития операционных систем; выясним, какие функции обычно выполняют операционные системы; наконец, разберемся в том, какие существуют подходы к построению операционных систем.</p><p><strong>Архитектура вычислительной системы и основы работы процессора</strong></p><p>Из чего состоит любая вычислительная система? Во-первых, из того, что в англоязычных странах принято называть словом hardware, или техническое обеспечение: процессор, память, монитор, дисковые устройства и т.д., объединенные магистральным соединением, которое называется шиной.</p><p>Выполнение различных операций с данными осуществляется изолированной частью компьютера, называемой центральным процессором (ЦП). ЦП также имеет ячейки для запоминания информации, называемые регистрами. Их разделяют на регистры общего назначения и специализированные регистры. В современных компьютерах емкость регистра обычно составляет 4-8 байт. Регистры общего назначения используются для временного хранения данных и результатов операций. Для обработки информации обычно организовывается передача данных из ячеек памяти в регистры общего назначения, выполнение операции центральным процессором и передача результатов операции в основную память.</p><p>Специализированные регистры используются для контроля работы процессора. Наиболее важными являются: программный счетчик, регистр команд и регистр, содержащий информацию о состоянии программы.</p><p>Программы хранятся в виде последовательности машинных команд, которые должен выполнять центральный процессор. Каждая команда состоит из поля операции и полей операндов, то есть тех данных, над которыми выполняется данная операция. Весь набор машинных команд называется машинным языком.</p><p><strong>Выполнение программы осуществляется за несколько циклов процессора:</strong></p><p>Цикл процессора - период времени, за который осуществляется выполнение команды исходной программы в машинном виде; состоит из нескольких тактов.</p><p>Такт работы процессора - промежуток времени между соседними импульсами генератора тактовых импульсов, частота которых есть тактовая частота процессора. Эта частота является одной из основных характеристик компьютера и во многом определяет скорость его работы, поскольку каждая операция в вычислительной машине выполняется за определенное количество тактов.</p><p>Выполнение короткой команды (арифметика с фиксированной точкой, логические операции), о которых речь здесь и пойдет, обычно занимает пять тактов:</p><ul><li>выборка команды;</li><li>расшифровка кода операции (декодирование);</li><li>генерация адреса и выборка данных из памяти;</li><li>выполнение операции;</li><li>запись результата в память.</li></ul><p><strong>Взаимодействие с периферийными устройствами</strong></p><p><strong>Периферийные устройства</strong> предназначены для ввода и вывода информации. Каждое устройство обычно имеет в своем составе специализированный компьютер, называемый контроллером или адаптером. Когда контроллер вставляется в разъем на материнской плате, он подключается к шине и получает уникальный номер (адрес). После этого контроллер осуществляет наблюдение за сигналами, идущими по шине, и отвечает на сигналы, адресованные ему.</p><p>Любая операция ввода-вывода предполагает диалог между ЦП и контроллером устройства. Когда процессору встречается команда, связанная с вводом-выводом, входящая в состав какой-либо программы, он выполняет ее, посылая сигналы контроллеру устройства. Это так называемый программируемый ввод-вывод.</p><p><strong>Программное обеспечение</strong></p><p>Вычислительная система состоит из программного обеспечения (software). Все программное обеспечение принято делить на две части: прикладное и системное. К прикладному: разнообразные банковские и прочие бизнес-программы, игры, текстовые процессоры. Системное программным обеспечением: программы, способствующие функционированию и разработке прикладных программ. Надо сказать, что деление на прикладное и системное программное обеспечение является отчасти условным и зависит от того, кто осуществляет такое деление.</p><p><strong>Краткая история эволюции вычислительных систем</strong></p><p>Так как операционные системы появились и развивались в процессе конструирования компьютеров, эти события исторически тесно связаны. Поэтому чтобы представить, как выглядели операционные системы, мы рассмотрим несколько следующих друг за другом поколений компьютеров. Такая схема взаимосвязи поколений операционных систем и компьютеров носит довольно приблизительный характер, но она обеспечивает некоторую структуру, без которой невозможно было бы что-то понять. Первый настоящий цифровой компьютер был изобретен английским математиком Чарльзом Бэббиджем (Charles Babbage, 1792-1871).</p><p><strong>Первый период (1945-1955 гг.). Ламповые машины. Операционных систем нет</strong></p><p>Мы начнем исследование развития компьютерных комплексов с появления электронных вычислительных систем (опуская историю механических и электромеханических устройств).</p><p>Первые шаги в области разработки электронных вычислительных машин были предприняты в конце Второй мировой войны. В середине 40-х были созданы первые ламповые вычислительные устройства и появился принцип программы, хранящейся в памяти машины (John Von Neumann, июнь 1945 г.). Джон Фон Нейман разработал архитектуру, при которой программы хранятся в памяти машины.</p><p>В то время одна и та же группа людей участвовала и в проектировании, и в эксплуатации, и в программировании вычислительной машины. Программирование осуществлялось исключительно на машинном языке. Об операционных системах не было и речи, все задачи организации вычислительного процесса решались вручную каждым программистом с пульта управления.</p><p>За пультом мог находиться только один пользователь. Программа загружалась в память машины в лучшем случае с колоды перфокарт, а обычно с помощью панели переключателей.</p><p>Вычислительная система выполняла одновременно только одну операцию (ввод-вывод или собственно вычисления). Отладка программ велась с пульта управления с помощью изучения состояния памяти и регистров машины. В конце этого периода появляется первое системное программное обеспечение: в 1951-1952 гг. возникают прообразы первых компиляторов с символических языков (Fortran и др.), а в 1954 г. Nat Rochester разрабатывает Ассемблер для IBM-701.</p><p>Существенная часть времени уходила на подготовку запуска программы, а сами программы выполнялись строго последовательно. Такой режим работы называется <strong>последовательной обработкой данных</strong>.</p><p><strong>Второй период (1955 г.-начало 60-х). Компьютеры на основе транзисторов. Пакетные операционные системы</strong></p><p>С середины 50-х годов появлялись полупроводниковые элементы. Применение транзисторов вместо часто перегоравших электронных ламп привело к повышению надежности компьютеров. Теперь машины могут непрерывно работать достаточно долго, чтобы на них можно было возложить выполнение практически важных задач. Размеры компьютеров уменьшились. Началось использование ЭВМ коммерческими фирмами. Одновременно наблюдается бурное развитие алгоритмических языков.</p><p>Именно в этот период происходит разделение персонала на программистов и операторов, специалистов по эксплуатации и разработчиков вычислительных машин.</p><p>Изменяется сам процесс прогона программ. Теперь пользователь приносит программу с входными данными в виде колоды перфокарт и указывает необходимые ресурсы. Такая колода получает название <strong>задания</strong>.</p><p>Оператор загружает задание в память машины и запускает его на исполнение. Полученные выходные данные печатаются на принтере, и пользователь получает их обратно через некоторое время.</p><p>Смена запрошенных ресурсов вызывает приостановку выполнения программ, в результате процессор часто простаивает. Для повышения эффективности использования компьютера задания с похожими ресурсами начинают собирать вместе, создавая <strong>пакет заданий.</strong></p><p>Появляются первые <strong>системы пакетной обработки</strong>, которые просто автоматизируют запуск одной программы из пакета за другой и тем самым увеличивают коэффициент загрузки процессора. Системы пакетной обработки стали прообразом современных операционных систем, они были первыми системными программами, предназначенными для управления вычислительным процессом.</p><p><strong>Третий период (начало 60-х - 1980 г.). Компьютеры на основе интегральных микросхем. Первые многозадачные ОС. Рождение UNIX и концепции POSIX</strong></p><p>Следующий важный период развития вычислительных машин относится к началу 60-х - 1980 г. В это время в технической базе произошел переход от отдельных полупроводниковых элементов типа транзисторов к <strong>интегральным микросхемам</strong>. Вычислительная техника становится еще надежнее и дешевле.</p><p>Растет сложность и количество задач, решаемых компьютерами. Повышается производительность процессоров.</p><p>Повышению эффективности использования процессорного времени мешает низкая скорость работы механических устройств ввода-вывода (быстрый считыватель перфокарт мог обработать 1200 перфокарт в минуту, принтеры печатали до 600 строк в минуту). Вместо непосредственного чтения пакета заданий с перфокарт в память начинают использовать его предварительную запись, сначала на магнитную ленту, а затем и на диск. Когда в процессе выполнения задания требуется ввод данных, они читаются с диска.</p><p>Точно так же выходная информация сначала копируется в <strong>системный буфер</strong> и записывается на ленту или диск, а печатается только после завершения задания. Вначале действительные операции ввода-вывода осуществлялись в режиме offline, то есть с использованием других, более простых, отдельно стоящих компьютеров. В дальнейшем они начинают выполняться на том же компьютере, который производит вычисления, то есть в режиме online. Такой прием получает название <strong>spooling</strong> (сокращение от Simultaneous Peripheral Operation On Line) или подкачки-откачки данных. Введение техники подкачки-откачки в пакетные системы позволило совместить реальные операции ввода-вывода одного задания с выполнением другого задания, но потребовало разработки <strong>аппарата прерываний</strong> для извещения процессора об окончании этих операций.</p><p>Магнитные ленты были устройствами <strong>последовательного доступа</strong>, то есть информация считывалась с них в том порядке, в каком была записана. Появление магнитного диска, для которого не важен порядок чтения информации, то есть устройства <strong>прямого доступа</strong>, привело к дальнейшему развитию вычислительных систем. При обработке пакета заданий на магнитной ленте очередность запуска заданий определялась порядком их ввода. При обработке пакета заданий на <strong>магнитном диске</strong> появилась возможность выбора очередного выполняемого задания. Пакетные системы начинают заниматься планированием заданий: в зависимости от наличия запрошенных ресурсов, срочности вычислений и т.д. на счет выбирается то или иное задание.</p><p>Дальнейшее повышение эффективности использования процессора было достигнуто с помощью <strong>мультипрограммирования</strong>. Идея мультипрограммирования напоминает поведение преподавателя и студентов на экзамене. Пока один студент (программа) обдумывает ответ на вопрос (операция ввода-вывода), преподаватель (процессор) выслушивает ответ другого студента (вычисления). Естественно, такая ситуация требует наличия в комнате нескольких студентов. Точно так же мультипрограммирование требует наличия в памяти нескольких программ одновременно. При этом каждая программа загружается в свой участок оперативной памяти, называемый <strong>разделом</strong>, и не должна влиять на выполнение другой программы. (Студенты сидят за отдельными столами и не подсказывают друг другу.)</p><p>Появление мультипрограммирования требует настоящей революции в строении вычислительной системы. Особую роль здесь играет аппаратная поддержка наиболее существенные особенности которой перечислены ниже.</p><ul><li><p>Реализация <strong>защитных механизмов</strong>. Программы не должны иметь самостоятельного доступа к распределению ресурсов, что приводит к появлению привилегированных и непривилегированных команд. Привилегированные команды, например команды ввода-вывода, могут исполняться только операционной системой. Говорят, что она работает в привилегированном режиме. Переход управления от прикладной программы к ОС сопровождается контролируемой сменой режима. Кроме того, это защита памяти, позволяющая изолировать конкурирующие пользовательские программы друг от друга, а ОС - от программ пользователей.</p></li><li><p>Наличие <strong>прерываний</strong>. Внешние прерывания оповещают ОС о том, что произошло асинхронное событие, например завершилась операция ввода-вывода. Внутренние прерывания (ситуации) возникают, когда выполнение программы привело к ситуации, требующей вмешательства ОС, например деление на ноль или попытка нарушения защиты.</p></li><li><p>Развитие параллелизма в архитектуре. Прямой доступ к памяти и организация каналов ввода-вывода позволили освободить центральный процессор от рутинных операций.</p></li></ul><p>Не менее важна в организации мультипрограммирования роль операционной системы. Она отвечает за следующие операции.</p><ul><li><p>Организация интерфейса между прикладной программой и ОС при помощи <strong>системных вызовов</strong>.</p></li><li><p>Организация очереди из заданий в памяти и выделение процессора одному из заданий потребовало планирования использования процессора.</p></li><li><p>Переключение с одного задания на другое требует сохранения содержимого <strong>регистров</strong> (сверхбыстрая память, находится в процессоре) и <strong>структур данных</strong> (массивы, строки, хэш-таблицы...), необходимых для выполнения задания, иначе говоря, <strong>контекста</strong> для обеспечения правильного продолжения вычислений.</p></li><li><p>Поскольку память является ограниченным ресурсом, нужны <strong>стратегии управления памятью</strong>, то есть требуется упорядочить процессы размещения, замещения и выборки информации из памяти.</p></li><li><p>Организация хранения информации на внешних носителях в виде <strong>файлов</strong> и обеспечение доступ к конкретному файлу только определенным категориям пользователей.</p></li><li><p>Поскольку программам может потребоваться произвести санкционированный обмен данными, необходимо их обеспечить <strong>средствами коммуникации</strong>.</p></li><li><p>Для корректного обмена данными необходимо разрешать конфликтные ситуации, возникающие при работе с различным ресурсами и предусмотреть координацию программами своих действий, т.е. снабдить систему <strong>средствами синхронизации</strong>.</p></li></ul><p>Мультипрограммные системы обеспечили возможность более эффективного использования системных ресурсов (например, процессора, памяти, периферийных устройств), но они еще долго оставались пакетными. Пользователь не мог непосредственно взаимодействовать с заданием и должен был предусмотреть с помощью управляющих карт все возможные ситуации. Отладка программ по-прежнему занимала много времени и требовала изучения многостраничных распечаток содержимого памяти и регистров или использования отладочной печати.</p><p>Появление электронно-лучевых дисплеев и переосмысление возможностей применения клавиатур поставили на очередь решение этой проблемы. Логическим расширением систем мультипрограммирования стали <strong>time-sharing</strong> системы, или системы разделения времени. В них процессор переключается между задачами не только на время операций ввода-вывода, но и просто по прошествии определенного времени. Эти переключения происходят так часто, что пользователи могут взаимодействовать со своими программами во время их выполнения, то есть интерактивно. В результате появляется возможность одновременной работы нескольких пользователей на одной компьютерной системе. Чтобы уменьшить ограничения на количество работающих пользователей, была внедрена идея неполного нахождения исполняемой программы в оперативной памяти. Основная часть программы находится на диске, и фрагмент, который необходимо в данный момент выполнять, может быть загружен в оперативную память, а ненужный - выкачан обратно на диск. Это реализуется с помощью <strong>механизма виртуальной памяти</strong>. Основным достоинством такого механизма является создание иллюзии неограниченной оперативной памяти ЭВМ.</p><p>В системах разделения времени пользователь получил возможность эффективно производить отладку программы в интерактивном режиме и записывать информацию на диск, не используя перфокарты, а непосредственно с клавиатуры. Появление online-файлов привело к необходимости разработки развитых файловых систем.</p><p><strong>Важнейшим событием этого периода стало создание в 1969 году в Bell Labs операционной системы UNIX.</strong> Ее ключевыми особенностями были:</p><ul><li>Написание на языке высокого уровня (С), что обеспечило невиданную ранее портируемость между разным оборудованием.</li><li>Простая, но мощная философия: система состоит из небольших утилит, каждая из которых выполняет одну функцию хорошо, а их можно комбинировать для решения сложных задач.</li><li>Иерархическая файловая система, единообразно представляющая устройства и объекты.</li></ul><p>Успех UNIX привел к появлению множества ее вариантов от разных производителей (BSD, System V, HP-UX, AIX), что создало проблему совместимости. Для ее решения был разработан стандарт <strong>POSIX (Portable Operating System Interface)</strong>. POSIX — это набор стандартов, описывающих интерфейсы между операционной системой и прикладной программой (системные вызовы, утилиты командной строки). ОС, соответствующая этим стандартам, называется <strong>POSIX-совместимой</strong>.</p><p>Термин <strong>UNIX-like</strong> (UNIX-подобная ОС) шире. Он описывает ОС, которые поведенчески и функционально похожи на оригинальную UNIX System V или BSD, даже если они не прошли формальную сертификацию на совместимость с POSIX. Ярчайшие примеры — Linux и современные BSD-системы (FreeBSD, OpenBSD). Их архитектура, системные вызовы и принципы организации следуют духу UNIX, что делает их практически POSIX-совместимыми.</p><p>В начале третьего периода появилась идея создания семейств программно совместимых машин, работающих под управлением одной и той же операционной системы.</p><p><strong>Четвертый период (с 1980 г. по настоящее время). Персональные компьютеры. Классические, сетевые и распределенные системы. Эра Linux и BSD</strong></p><p>Следующий период в эволюции вычислительных систем связан с появлением больших интегральных схем (БИС). Наступила эра персональных компьютеров. Первоначально персональные компьютеры предназначались для использования одним пользователем в однопрограммном режиме, что повлекло за собой деградацию архитектуры этих ЭВМ и их операционных систем (в частности, пропала необходимость защиты файлов и памяти, планирования заданий и т. п.).</p><p>Компьютеры стали использоваться не только специалистами, что потребовало разработки &quot;дружественного&quot; программного обеспечения.</p><p>В середине 80-х стали бурно развиваться сети компьютеров, в том числе персональных, работающих под управлением сетевых или распределенных операционных систем.</p><p>В сетевых операционных системах пользователи могут получить доступ к ресурсам другого сетевого компьютера, с помощью различных протоколов передачи данных. (сейчас все операционки)</p><p>Распределенная система, напротив, внешне выглядит как обычная автономная система. Пользователь не знает и не должен знать, где его файлы хранятся - на локальной или удаленной машине - и где его программы выполняются. Он может вообще не знать, подключен ли его компьютер к сети. (с помощью <strong>тонких клиентов</strong> (маленький комп, который может только передавать данные))</p><p><strong>Почему существует так много дистрибутивов Linux?</strong> Linux — это не операционная система в законченном виде, а лишь <strong>ядро</strong>. Для создания полноценной ОС требуется собрать вокруг ядра множество компонентов: компилятор, библиотеки (в т.ч. самая важная — glibc), системные утилиты (часто из проекта GNU), графический сервер, среды рабочего стола и приложения. Этот процесс сборки и называется созданием дистрибутива.</p><p>Разнообразие дистрибутивов Linux (Ubuntu, Debian, Arch Linux, Fedora и сотни других) возникает по нескольким причинам:</p><ol><li><strong>Различные философии и цели:</strong> одни дистрибутивы ориентированы на стабильность и надежность (Debian, RHEL), другие — на предоставление самых свежих версий ПО (Arch Linux, Fedora), третьи — на простоту использования (Ubuntu, Linux Mint), четвертые — на минимализм и безопасность.</li><li><strong>Разные системы управления пакетами:</strong> форматы пакетов и инструменты для их установки (.deb и .apt, .rpm и dnf/yum) создают основные ветви дистрибутивов.</li><li><strong>Различная аудитория:</strong> существуют дистрибутивы для серверов, для настольных ПК, для встраиваемых систем, для научных вычислений, для пентеста и т.д.</li><li><strong>Открытая лицензия:</strong> модель открытого исходного кода (Open Source) позволяет взять за основу существующий дистрибутив и создать собственную сборку под конкретные нужды.</li></ol><p><strong>Семейство BSD (Berkeley Software Distribution)</strong> BSD — это другая ветвь UNIX-подобных операционных систем, ведущая свою историю непосредственно от исходного кода UNIX, разработанного в Калифорнийском университете в Беркли. В отличие от Linux, который является лишь ядром, каждая BSD-система (FreeBSD, OpenBSD, NetBSD) — это целостная операционная система, разрабатываемая единой командой. Ядро, системные утилиты и документация поставляются вместе как один проект.</p><ul><li><strong>FreeBSD</strong> ориентирована на производительность и удобство использования на платформах x86 и ARM.</li><li><strong>OpenBSD</strong> делает акцент на безопасности, коррекности кода и криптографии.</li><li><strong>NetBSD</strong> славится своей портируемостью на огромное количество аппаратных архитектур. Разнообразие здесь возникает не из-за дистрибутивов, а из-за разных проектов, каждый из которых следует своим четким техническим целям и принципам.</li></ul><p>В дальнейшем автономные операционные системы мы будем называть классическими операционными системами.</p><p><strong>Основные функции и ключевые концепции ОС</strong></p><p>Просмотрев этапы развития вычислительных систем, мы можем выделить шесть основных функций, которые выполняли классические операционные системы в процессе эволюции:</p><p>• Планирование заданий и использования процессора. • Обеспечение программ средствами коммуникации и синхронизации. • Управление памятью. • Управление файловой системой. • Управление вводом-выводом. • Обеспечение безопасности</p><p>Каждая из приведенных функций обычно реализована в виде подсистемы, являющейся структурным компонентом ОС.</p><p>В процессе эволюции возникло несколько важных концепций, которые стали неотъемлемой частью теории и практики ОС. Рассматриваемые в данном разделе понятия будут встречаться и разъясняться на протяжении всего курса. Здесь дается их краткое описание.</p><p><strong>Прерывания</strong></p><p>Прерывание (hardware interrupt) - это событие, генерируемое внешним (по отношению к процессору) устройством. Посредством аппаратных прерываний аппаратура либо информирует центральный процессор о том, что произошло какое-либо событие, требующее немедленной реакции (например, пользователь нажал клавишу), либо сообщает о завершении асинхронной операции ввода-вывода (например, закончено чтение данных с диска в основную память). Важный тип аппаратных прерываний - прерывания таймера, которые генерируются периодически через фиксированный промежуток времени. Прерывания таймера используются операционной системой при планировании процессов. Каждый тип аппаратных прерываний имеет собственный номер, однозначно определяющий источник прерывания. Аппаратное прерывание - это асинхронное событие, то есть оно возникает вне зависимости от того, какой код исполняется процессором в данный момент. Обработка аппаратного прерывания не должна учитывать, какой процесс является текущим.</p><p><strong>Системные вызовы</strong></p><p>В ОС Unix такие средства называют системными вызовами.</p><p><strong>Системные вызовы (system calls)</strong> - это интерфейс между операционной системой и пользовательской программой. Они создают, удаляют и используют различные объекты, главные из которых - процессы и файлы. Пользовательская программа запрашивает сервис у операционной системы, осуществляя системный вызов. Имеются библиотеки <strong>процедур</strong>, которые загружают машинные регистры определенными параметрами и осуществляют прерывание процессора, после чего управление передается обработчику данного вызова, входящему в ядро операционной системы. Цель таких библиотек - сделать системный вызов похожим на обычный вызов подпрограммы.</p><p>Программа делает запрос ресурса(оперативная память, жд, все что угодно), процедуры останавливают выполнение других программ процессором, потом все обработалось ядре и вернулось обратно в программу.</p><p>Основное отличие состоит в том, что при системном вызове задача переходит в привилегированный режим или <strong>режим ядра</strong> (kernel mode). Поэтому системные вызовы иногда еще называют программными прерываниями, в отличие от аппаратных прерываний, которые чаще называют просто прерываниями.</p><p>В этом режиме работает код ядра операционной системы, причем исполняется он в <strong>адресном пространстве</strong> (выделенные адреса в оперативке) и в <strong>контексте</strong> (адресное пространство и все что необходимо для выполнения процесса) вызвавшей его задачи. Таким образом, ядро операционной системы имеет полный доступ к памяти пользовательской программы, и при системном вызове достаточно передать адреса одной или нескольких областей памяти с параметрами вызова и адреса одной или нескольких областей памяти для результатов вызова.</p><p>В большинстве операционных систем системный вызов осуществляется командой программного прерывания (INT). Программное прерывание - это <strong>синхронное событие</strong> (может произойти только в определенный такт процессора), которое может быть повторено при выполнении одного и того же программного кода.</p><p><strong>Исключительные ситуации</strong></p><p>Исключительная ситуация (exception) - событие, возникающее в результате попытки выполнения программой команды, которая по каким-то причинам не может быть выполнена до конца. Примерами таких команд могут быть попытки доступа к ресурсу при отсутствии достаточных привилегий или обращения к отсутствующей странице памяти. Исключительные ситуации, как и системные вызовы, являются синхронными событиями, возникающими в контексте текущей задачи. Исключительные ситуации можно разделить на исправимые и неисправимые. К исправимым относятся такие исключительные ситуации, как отсутствие нужной информации в оперативной памяти. После устранения причины исправимой исключительной ситуации программа может выполняться дальше. Возникновение в процессе работы операционной системы исправимых исключительных ситуаций считается нормальным явлением. Неисправимые исключительные ситуации чаще всего возникают в результате ошибок в программах (например, деление на ноль). Обычно в таких случаях операционная система реагирует завершением программы, вызвавшей исключительную ситуацию.</p><p><strong>Файлы</strong></p><p>Файлы предназначены для хранения информации на внешних носителях, то есть принято, что информация, записанная, например, на диске, должна находиться внутри файла. Обычно под файлом понимают именованную часть пространства на носителе информации.</p><p>Главная задача файловой системы (file system) - скрыть особенности ввода-вывода и дать программисту простую абстрактную модель файлов, независимых от устройств. Для чтения, создания, удаления, записи, открытия и закрытия файлов также имеется обширная категория системных вызовов (создание, удаление, открытие, закрытие, чтение и т.д.). Пользователям хорошо знакомы такие связанные с организация файловой системы понятия, как каталог, текущий каталог, корневой каталог, путь. Для манипулирования этими объектами в операционной системе имеются системные вызовы.</p><p><strong>Процессы, нити</strong></p><p>Концепция процесса в ОС одна из наиболее фундаментальных. Процессы подробно рассмотрены в лекциях 2-7. Там же описаны нити, или легковесные процессы.</p><p><strong>Архитектурные особенности ОС</strong></p><p>До сих пор мы говорили о взгляде на операционные системы извне, о том, что делают операционные системы. Дальнейший наш курс будет посвящен тому, как они это делают. Но мы пока ничего не сказали о том, что они представляют собой изнутри, какие подходы существуют к их построению.</p><p><strong>Монолитное ядро</strong></p><p>По сути дела, операционная система - это обычная программа, поэтому было бы логично и организовать ее так же, как устроено большинство программ, то есть составить из процедур и функций. В этом случае компоненты операционной системы являются не самостоятельными модулями, а составными частями одной большой программы. Такая структура операционной системы называется монолитным ядром (monolithic kernel). Монолитное ядро представляет собой набор процедур, каждая из которых может вызвать каждую. Все процедуры работают в привилегированном режиме. Таким образом, монолитное ядро - это такая схема операционной системы, при которой все ее компоненты являются составными частями одной программы, используют общие структуры данных и взаимодействуют друг с другом путем непосредственного вызова процедур. Для монолитной операционной системы ядро совпадает со всей системой.</p><p>Монолитное ядро - старейший способ организации операционных систем. Примером систем с монолитным ядром является большинство Unix-систем, включая Linux.</p><p>Даже в монолитных системах можно выделить некоторую структуру. Как в бетонной глыбе можно различить вкрапления щебенки, так и в монолитном ядре выделяются вкрапления сервисных процедур, соответствующих системным вызовам. Сервисные процедуры выполняются в привилегированном режиме, тогда как пользовательские программы - в непривилегированном. Для перехода с одного уровня привилегий на другой иногда может использоваться главная сервисная программа, определяющая, какой именно системный вызов был сделан, корректность входных данных для этого вызова и передающая управление соответствующей сервисной процедуре с переходом в привилегированный режим работы. Иногда выделяют также набор программных утилит, которые помогают выполнять сервисные процедуры.</p><p><strong>Многоуровневые системы (Layered systems)</strong></p><p>Продолжая структуризацию, можно разбить всю вычислительную систему на ряд более мелких уровней с хорошо определенными связями между ними, так чтобы объекты уровня N могли вызывать только объекты уровня N-1. Нижним уровнем в таких системах обычно является hardware, верхним уровнем - интерфейс пользователя. Чем ниже уровень, тем более привилегированные команды и действия может выполнять модуль, находящийся на этом уровня. Впервые такой подход был применен при создании системы THE (Technishe Hogeschool Eindhoven) Дейкстрой (Dijkstra) и его студентами в 1968 г. Эта система имела следующие уровни:</p><p>Слоеные системы хорошо реализуются. При использовании операций нижнего слоя не нужно знать, как они реализованы, нужно лишь понимать, что они делают. Слоеные системы хорошо тестируются. Отладка начинается с нижнего слоя и проводится послойно. При возникновении ошибки мы можем быть уверены, что она находится в тестируемом слое. Слоеные системы хорошо модифицируются. При необходимости можно заменить лишь один слой, не трогая остальные. Но слоеные системы сложны для разработки: тяжело правильно определить порядок слоев и что к какому слою относится. Слоеные системы менее эффективны, чем монолитные. Так, например, для выполнения операций ввода-вывода программе пользователя придется последовательно проходить все слои от верхнего до нижнего.</p><p><strong>Микроядерная архитектура</strong></p><p>Современная тенденция в разработке операционных систем состоит в перенесении значительной части системного кода на уровень пользователя и одновременной минимизации ядра. Речь идет о подходе к построению ядра, называемом микроядерной архитектурой (microkernel architecture) операционной системы, когда большинство ее составляющих являются самостоятельными программами. В этом случае взаимодействие между ними обеспечивает специальный модуль ядра, называемый микроядром. Микроядро работает в привилегированном режиме и обеспечивает взаимодействие между программами, планирование использования процессора, первичную обработку прерываний, операции ввода-вывода и базовое управление памятью.</p><p>Остальные компоненты системы взаимодействуют друг с другом путем передачи сообщений через микроядро.</p><p>Основное достоинство микроядерной архитектуры -- высокая степень модульности ядра операционной системы. Это существенно упрощает добавление в него новых компонентов. В микроядерной операционной системе можно, не прерывая ее работы, загружать и выгружать новые драйверы, файловые системы и т. д. Компоненты ядра операционной системы ничем принципиально не отличаются от пользовательских программы. Микроядерная архитектура повышает надежность системы, поскольку ошибка на уровне непривилегированной программы менее опасна, чем отказ на уровне режима ядра.</p><p>В то же время микроядерная архитектура операционной системы вносит дополнительные накладные расходы, связанные с передачей сообщений, что существенно влияет на производительность. Для того чтобы микроядерная операционная система по скорости не уступала операционным системам на базе монолитного ядра, требуется очень аккуратно проектировать разбиение системы на компоненты, стараясь минимизировать взаимодействие между ними. Яркими примерами ОС с микроядерной архитектурой являются QNX и Minix.</p><p><strong>Смешанные системы</strong></p><p>Все рассмотренные подходы к построению операционных систем имеют свои достоинства и недостатки. Поэтому реальные ос объединяют в себе подходы различных архитектур. Например, современные версии Windows, macOS и Linux используют монолитное ядро (или гибридное, как в случае Windows NT), но активно выносят многие драйверы и подсистемы в пользовательское пространство, заимствуя тем самым преимущества микроядерного подхода.</p><p><strong>Виртуальные машины</strong></p><p>Каждая виртуальная машина предстает перед пользователем как голое железо - копия всего hardware в вычислительной системе, включая процессор, привилегированные и непривилегированные команды, устройства ввода-вывода, прерывания и т.д. И он остается с этим железом один на один. При попытке обратиться к такому виртуальному железу на уровне привилегированных команд в действительности происходит системный вызов реальной операционной системы, которая и производит все необходимые действия. Такой подход позволяет каждому пользователю загрузить свою операционную систему на виртуальную машину и делать с ней все, что душа пожелает.</p><p><strong>Классификация ОС</strong></p><p>Существует несколько схем классификации операционных систем. Ниже приведена классификация по некоторым признакам с точки зрения пользователя.</p><p><strong>Реализация многозадачности</strong></p><p>По числу одновременно выполняемых задач операционные системы можно разделить на два класса:</p><p>• многозадачные (Unix, OS/2, Windows); • однозадачные (например, MS-DOS).</p><p>Многозадачная ОС, решая проблемы распределения ресурсов и конкуренции, полностью реализует мультипрограммный режим.</p><p>Многозадачный режим, который воплощает в себе идею разделения времени, называется <strong>вытесняющим (preemptive)</strong>. Каждой программе выделяется квант процессорного времени, по истечении которого управление передается другой программе. Говорят, что первая программа будет вытеснена. В вытесняющем режиме работают пользовательские программы большинства коммерческих ОС.</p><p>В некоторых ОС (Windows 3.11, например) пользовательская программа может монополизировать процессор, то есть работать в <strong>невытесняющем</strong> режиме. Как правило, в большинстве систем не подлежит вытеснению код собственно ОС. Ответственные программы, в частности задачи реального времени, также не вытесняются. Более подробно об этом рассказано в лекции, посвященной планированию работы процессора.</p><p><strong>Поддержка многопользовательского режима</strong></p><p>По числу одновременно работающих пользователей ОС можно разделить на:</p><p>• однопользовательские (MS-DOS, Windows 3.x); • многопользовательские (Windows NT, Unix, Linux, BSD).</p><p>Наиболее существенное отличие между этими ОС заключается в наличии у многопользовательских систем механизмов защиты персональных данных каждого пользователя.</p><p><strong>Многопроцессорная обработка</strong></p><p>Примерно до 2005-2006 гг вычислительные системы имели один центральный процессор. В результате требований к повышению производительности появились многопроцессорные системы, состоящие из двух и более процессоров общего назначения, осуществляющих параллельное выполнение команд. Поддержка мультипроцессирования является важным свойством ОС и приводит к усложнению всех алгоритмов управления ресурсами. Многопроцессорная обработка реализована в таких ОС, как Linux, Solaris, Windows NT, и ряде других.</p><p>Многопроцессорные ОС разделяют на <strong>симметричные</strong> и <strong>асимметричные</strong>. В симметричных ОС на каждом процессоре функционирует одно и то же ядро, и задача может быть выполнена на любом процессор, то есть обработка полностью децентрализована. При этом каждому из процессоров доступна вся память.</p><p>В асимметричных ОС процессоры неравноправны. Обычно существует главный процессор (master) и подчиненные (slave), загрузку и характер работы которых определяет главный процессор.</p><p><strong>Системы реального времени</strong></p><p>В разряд многозадачных ОС, наряду с пакетными системами и системами разделения времени, включаются также <strong>системы реального времени</strong>, например <strong>FreeRTOS</strong>.</p><p>Они используются для управления различными техническими объектами или технологическими процессами. Такие системы характеризуются предельно допустимым временем реакции на внешнее событие, в течение которого должна быть выполнена программа, управляющая объектом. Система должна обрабатывать поступающие данные быстрее, чем они могут поступать, причем от нескольких источников одновременно.</p><p>Столь жесткие ограничения сказываются на архитектуре систем реального времени, например, в них может отсутствовать виртуальная память, поддержка которой дает непредсказуемые задержки в выполнении программ.</p><p><strong>Заключение</strong></p><p>Мы рассмотрели различные взгляды на то, что такое операционная система; изучили историю развития операционных систем; выяснили, какие функции обычно выполняют операционные системы; наконец, разобрались в том, какие существуют подходы к построению операционных систем. Мы также дополнили наше понимание, узнав о стандарте POSIX и UNIX-подобных системах, а также о причинах разнообразия дистрибутивов Linux и вариантов BSD. Следующую лекцию мы посвятим выяснению понятия &quot;процесс&quot; и вопросам планирования процессов.</p>',126)]))}const c=n(s,[["render",g]]);export{d as __pageData,c as default};
