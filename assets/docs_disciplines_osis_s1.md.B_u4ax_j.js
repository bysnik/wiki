import{_ as s,c as a,o as e,ag as l}from"./chunks/framework.D4Vqf8I7.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"docs/disciplines/osis/s1.md","filePath":"docs/disciplines/osis/s1.md","lastUpdated":1757061688000}'),t={name:"docs/disciplines/osis/s1.md"};function o(n,i,d,c,h,p){return e(),a("div",null,i[0]||(i[0]=[l(`<h3 id="_1-установка-arch-linux" tabindex="-1">1. Установка Arch Linux <a class="header-anchor" href="#_1-установка-arch-linux" aria-label="Permalink to &quot;1. Установка Arch Linux&quot;">​</a></h3><p>Раздел:<br> Тема:<br> Количество часов: 2<br> Задачи:<br> Порядок выполнения работы:</p><h2 id="revolution-os" tabindex="-1">Revolution OS <a class="header-anchor" href="#revolution-os" aria-label="Permalink to &quot;Revolution OS&quot;">​</a></h2><p>Сетевой и системный администратор в своей работе должен опираться не только на технические знания и практические навыки, но и понимать контекст — зачем была создана та или иная технология, кто её разработал и с какой целью. Важно видеть не только «как», но и «почему». Особенно это актуально в отношении масштабных явлений, таких как движение Open Source. Рекомендую посмотреть документальный фильм Revolution OS — в нём участники движения, создатели Linux, GNU и других ключевых компонентов свободного ПО, рассказывают о своих идеях, мотивации и борьбе за открытость кода. Этот фильм позволяет понять, как личные убеждения и стремление к свободе обмена знаниями привели к созданию технологий, ставших сегодня глобальным достоянием и основой современной цифровой инфраструктуры.</p><p><a href="https://rutube.ru/video/4d6aa787f23b8a59777d59248cd82e7f/" target="_blank" rel="noreferrer">https://rutube.ru/video/4d6aa787f23b8a59777d59248cd82e7f/</a></p><h2 id="предисловние" tabindex="-1">Предисловние <a class="header-anchor" href="#предисловние" aria-label="Permalink to &quot;Предисловние&quot;">​</a></h2><p>Данная самостаятельная работа является руководством по установке Arch Linux с помощью системы, загруженной с официальным установочным образом.</p><p>Более подробные инструкции приведены в соответствующих статьях ArchWiki и на страницах справочных руководств (man) различных программ. Также вы можете получить помощь в IRC-канале и на англоязычном и русскоязычном форумах Arch Linux.</p><p>Arch Linux способен работать на любой x86_64-совместимой машине, имеющей хотя бы 512 МиБ ОЗУ, однако понадобится больше памяти для загрузки live-системы. Базовая установка занимает меньше 2 ГиБ дискового пространства. Поскольку для процесса установки требуется получать пакеты из удалённого репозитория, необходимо работающее интернет-соединение.</p><div class="info custom-block"><p class="custom-block-title">Архитектурный контекст</p><p>Arch Linux следует философии KISS (Keep It Simple, Stupid), что отражает основной принцип Unix-подобных систем: каждая утилита должна решать одну задачу, но делать это качественно. Обратите внимание, что:</p><ul><li>Ядро Linux управляет взаимодействием с железом</li><li>GNU-утилиты (<code>bash</code>, <code>coreutils</code>, <code>grep</code> и др.) предоставляют пользовательский интерфейс</li><li>Пакетный менеджер pacman — &quot;клеевой компонент&quot;, соединяющий эти слои.</li></ul><p>Это разделение ответственности между ядром, утилитами и пакетами — ключевая особенность архитектуры GNU/Linux.</p></div><h2 id="разметка-дисков" tabindex="-1">Разметка дисков <a class="header-anchor" href="#разметка-дисков" aria-label="Permalink to &quot;Разметка дисков&quot;">​</a></h2><p>Когда запущенная система распознает накопители, они становятся доступны как блочные устройства, например, <code>/dev/sda</code>, <code>/dev/nvme0n1</code> или <code>/dev/mmcblk0</code>. Чтобы посмотреть их список, используйте <code>lsblk</code> или <code>fdisk</code>:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fdisk</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -l</span></span></code></pre></div><p>Результаты, оканчивающиеся на <code>rom</code>, <code>loop</code> и <code>airoot</code>, можно игнорировать.</p><div class="info custom-block"><p class="custom-block-title">Блочные устройства и ядро</p><p>Блочные устройства (<code>/dev/sdX</code>, <code>/dev/nvmeX</code>) — это абстракция ядра Linux для работы с дисками. Важно понимать:</p><ul><li><code>sda</code> — интерфейс SATA/SCSI, <code>nvme0n1</code> — интерфейс NVMe, <code>mmcblk0</code> — карта памяти</li><li>Ядро динамически создает эти узлы через подсистему <strong>udev</strong></li><li>Разделы (например, <code>/dev/sda1</code>) — логические части физического устройства</li></ul><p>Это демонстрирует принцип &quot;всё в Linux — файлы&quot;, даже аппаратные устройства представлены в файловой системе.</p></div><p>Необходимо выбрать блочное устройство на которое планируется установка системы.</p><p>Используйте <code>fdisk</code> чтобы разметить диск:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fdisk</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/диск_для_разметки</span></span></code></pre></div><p>Создайте два раздела: основной раздел системы и SWAP раздел.</p><div class="warning custom-block"><p class="custom-block-title">SWAP и виртуальная память</p><p>SWAP — не просто &quot;резервная память&quot;. Это ключевой компонент <strong>виртуальной памяти</strong>:</p><ul><li>Позволяет ядру выгружать неактивные страницы RAM на диск</li><li>Критичен для систем с малым объемом ОЗУ</li><li>Современные ядра используют SWAP даже при наличии свободной RAM (для оптимизации)</li></ul><p>В Linux управление памятью — часть ядра (subsystem mm), а не отдельный сервис.</p></div><h2 id="форматирование-разделов" tabindex="-1">Форматирование разделов <a class="header-anchor" href="#форматирование-разделов" aria-label="Permalink to &quot;Форматирование разделов&quot;">​</a></h2><p>Когда новые разделы созданы, каждый из них необходимо отформатировать в подходящую файловую систему.</p><p>Например, чтобы отформатировать <code>/dev/корневой_раздел</code> в Ext4, выполните следующую команду:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkfs.ext4</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/корневой_раздел</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">Файловые системы и VFS</p><p>Ext4 — это <strong><em>journaling</em> файловая система</strong>, но важно понять:</p><ul><li>VFS (Virtual Filesystem Switch) — абстрактный слой ядра, через который взаимодействуют все FS</li><li>Файловая система — не часть ядра, а <strong>модуль</strong>, подключаемый динамически</li><li>Характеристики FS (ext4, btrfs, xfs) определяют: <ul><li>Алгоритмы хранения данных</li><li>Поддержку ACL/SELinux</li><li>Механизмы восстановления после сбоев</li></ul></li></ul><p>Это пример разделения ядра и пользовательского пространства.</p></div><p>Если вы создали раздел для подкачки (swap), инициализируйте его с помощью утилиты <code>mkswap</code>:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkswap</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/раздел_подкачки</span></span></code></pre></div><h2 id="монтирование-разделов" tabindex="-1">Монтирование разделов <a class="header-anchor" href="#монтирование-разделов" aria-label="Permalink to &quot;Монтирование разделов&quot;">​</a></h2><p>Смонтируйте корневой раздел в каталог <code>/mnt</code>. Например, если корневой раздел — <code>/dev/корневой_раздел</code>, выполните следующую команду:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mount</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/корневой_раздел</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /mnt</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">Иерархия файловых систем</p><p>Обратите внимание на принцип <strong>единой иерархии каталогов</strong>:</p><ul><li>В отличие от Windows (C:, D:), в Linux все разделы монтируются в единую дерево начиная с <code>/</code></li><li>Точка монтирования — обычный каталог, не имеющий специальных прав</li><li><code>/proc</code>, <code>/sys</code> — псевдо-файловые системы ядра (procfs, sysfs), предоставляющие интерфейс к параметрам ядра</li></ul><p>Это фундаментальное отличие архитектуры Unix-систем от других ОС.</p></div><p>Создайте точки монтирования для всех остальных разделов (например, <code>/mnt/efi</code>) и примонтируйте соответствующие разделы.</p><div class="tip custom-block"><p class="custom-block-title">Совет</p><p>Команда <code>mount</code>, запущенная с опцией <code>--mkdir</code>, автоматически создаст требуемую точку монтирования. Можно создать их и вручную с помощью <code>mkdir</code>.</p></div><p>Если вы ранее создали раздел подкачки (swap), активируйте его с помощью <code>swapon</code>:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">swapon</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/раздел_подкачки</span></span></code></pre></div><p>В дальнейшем <code>genfstab</code> обнаружит смонтированные файловые системы и пространство подкачки.</p><h2 id="установка" tabindex="-1">Установка <a class="header-anchor" href="#установка" aria-label="Permalink to &quot;Установка&quot;">​</a></h2><h3 id="выбор-зеркал" tabindex="-1">Выбор зеркал <a class="header-anchor" href="#выбор-зеркал" aria-label="Permalink to &quot;Выбор зеркал&quot;">​</a></h3><p>Пакеты для установки должны скачиваться с серверов-зеркал, прописанных в файле <code>/etc/pacman.d/mirrorlist</code>. В установочном образе, после подключения к сети, <code>reflector</code> обновит список зеркал (выбрав 20 наиболее актуальных HTTPS-зеркал) и отсортирует их по скорости загрузки.</p><div class="info custom-block"><p class="custom-block-title">Репозитории и пакетный менеджер</p><p>Pacman использует <strong>двухуровневую модель</strong>:</p><ol><li><strong>Репозитории</strong> (mirrorlist) — статические архивы пакетов</li><li><strong>Локальная БД</strong> (<code>/var/lib/pacman/local</code>) — отслеживает установленные пакеты Ключевые концепции:</li></ol><ul><li>Пакет — не просто набор файлов, а <strong>метаданные + скрипты установки</strong></li><li>Зависимости разрешаются на уровне пакетного менеджера, а не через LD_LIBRARY_PATH</li><li>Arch использует rolling release — обновления поступают сразу после тестирования</li></ul></div><p>Чем выше зеркало расположено в списке, тем больший приоритет оно имеет при скачивании пакета. Вы можете проверить этот файл и, при необходимости, отредактировать его вручную, переместив наверх наиболее географически близкие зеркала. При этом также учитывайте и другие критерии.</p><p>Позже <code>pacstrap</code> скопирует этот файл в новую систему, так что это действительно стоит сделать. Установка основных пакетов</p><h2 id="установка-пакетов" tabindex="-1">Установка пакетов <a class="header-anchor" href="#установка-пакетов" aria-label="Permalink to &quot;Установка пакетов&quot;">​</a></h2><p>Используйте скрипт <code>pacstrap</code>, чтобы установить пакет <code>base</code>, ядро <code>Linux</code> и прошивки часто встречающихся устройств:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pacstrap</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -K</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /mnt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> base</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> linux</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> linux-firmware</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dhcpcd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nano</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> openssh</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">Совет</p><p>В случае проблем с pgp key используйте:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pacman</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Sy</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> archlinux-keyring</span></span></code></pre></div></div><div class="tip custom-block"><p class="custom-block-title">Совет</p><p><code>linux</code> можно заменить на другой желаемый пакет ядра. Можно вообще не устанавливать ядро, если установка происходит в контейнере.</p><p>Можно пропустить установку пакета прошивок, если установка происходит в контейнере или виртуальной машине.</p><p>Пакет <code>base</code> содержит не все инструменты, имеющиеся на установочном носителе, из-за чего может потребоваться установка дополнительных пакетов для получения полностью функциональной базовой системы. В частности, вам могут пригодиться следующие программы:</p><ul><li>утилиты для управления файловыми системами в пользовательском пространстве, которые будут использоваться в системе,</li><li>утилиты для доступа к RAID- или LVM-разделам,</li><li>специфические прошивки других устройств, не включённые в <code>linux-firmware</code> (например, <code>sof-firmware</code> для некоторых звуковых карт),</li><li>ПО, необходимое для организации сети (например, менеджер сети или DHCP-клиент),</li><li>текстовый редактор,</li><li>пакеты для доступа к документации в <code>man</code> и <code>info</code>: <code>man-db</code>, <code>man-pages</code> и <code>texinfo</code>.</li></ul><p>Чтобы установить другие пакеты или группы, добавьте их названия к команде pacstrap (разделяя их пробелом) или используйте pacman во время этапа #Chroot. Список пакетов, присутствующих в установочном образе, доступен на странице <code>pkglist.x86_64.txt</code>.</p></div><div class="info custom-block"><p class="custom-block-title">Состав базовой системы</p><p>Пакет <code>base</code> включает:</p><ul><li><strong>GNU Coreutils</strong> (ls, cp, rm и др.)</li><li><strong>Bash</strong> (но не единственный shell)</li><li><strong>systemd</strong> (менеджер служб)</li><li><strong>pacman</strong> (сам пакетный менеджер!)</li></ul><p>Важно: ядро Linux (<code>linux</code>) и прошивки (<code>linux-firmware</code>) — отдельные компоненты, так как:</p><ul><li>Ядро работает в <strong>привилегированном режиме (kernel space)</strong></li><li>Прошивки — двоичные blob&#39;ы для оборудования (часто закрытые) Это демонстрирует разделение на open-source ядро и проприетарные компоненты.</li></ul></div><h2 id="настроика-системы" tabindex="-1">Настройка системы <a class="header-anchor" href="#настроика-системы" aria-label="Permalink to &quot;Настройка системы&quot;">​</a></h2><h3 id="fstab" tabindex="-1">Fstab <a class="header-anchor" href="#fstab" aria-label="Permalink to &quot;Fstab&quot;">​</a></h3><p>Сгенерируйте файл <code>fstab</code> (используйте ключ <code>-U</code> или <code>-L</code>, чтобы для идентификации разделов использовались UUID или метки, соответственно):</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">genfstab</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -U</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /mnt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /mnt/etc/fstab</span></span></code></pre></div><p>После этого проверьте файл <code>/mnt/etc/fstab</code> и отредактируйте его в случае необходимости.</p><div class="info custom-block"><p class="custom-block-title">fstab и процесс загрузки</p><p>Файл <code>/etc/fstab</code> — часть <strong>системы инициализации</strong>:</p><ul><li>Читается на ранней стадии загрузки (до запуска systemd)</li><li>Определяет порядок монтирования разделов</li><li>UUID предпочтительнее <code>/dev/sdX</code>, так как: <ul><li>Не зависит от порядка обнаружения устройств</li><li>Гарантирует стабильность при изменении конфигурации</li></ul></li></ul><p>Это пример связи между низкоуровневыми операциями (монтирование) и высокоуровневой системой (systemd).</p></div><h3 id="chroot" tabindex="-1">Chroot <a class="header-anchor" href="#chroot" aria-label="Permalink to &quot;Chroot&quot;">​</a></h3><p>Перейдите к корневому каталогу новой системы:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">arch-chroot</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /mnt</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">Chroot и изоляция</p><p>Команда <code>arch-chroot</code> делает два ключевых действия:</p><ol><li>Меняет <strong>корневую файловую систему</strong> на <code>/mnt</code></li><li>Корректирует <strong>пространство процессов</strong> (PID namespace) Это базовый механизм изоляции, на котором строятся:</li></ol><ul><li>Контейнеры (LXC, Docker)</li><li>Системы восстановления</li><li>Безопасное выполнение программ</li></ul><p>Понимание chroot критично для работы с современными Linux-системами.</p></div><h3 id="часовои-пояс" tabindex="-1">Часовой пояс <a class="header-anchor" href="#часовои-пояс" aria-label="Permalink to &quot;Часовой пояс&quot;">​</a></h3><p>Задайте часовой пояс:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ln</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -sf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /usr/share/zoneinfo/Регион/Город</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/localtime</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">Время в Linux</p><p>Два ключевых аспекта:</p><ol><li><strong>Аппаратные часы (RTC)</strong> — хранят время в UTC (не в локальном!)</li><li><strong>Системные часы</strong> — управляются ядром, используют локальную зону через <code>/etc/localtime</code></li></ol><p>Почему UTC?</p><ul><li>Позволяет корректно работать с несколькими временными зонами</li><li>Избегает проблем с летним/зимним временем</li><li>Стандарт для серверных систем</li></ul><p>Это пример компромисса между технической простотой и пользовательским удобством.</p></div><p>Запустите <code>hwclock</code>, чтобы сгенерировать <code>/etc/adjtime</code>:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hwclock</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --systohc</span></span></code></pre></div><p>Эта команда предполагает, что аппаратные часы настроены в формате UTC.</p><h3 id="пароль-суперпользователя" tabindex="-1">Пароль суперпользователя <a class="header-anchor" href="#пароль-суперпользователя" aria-label="Permalink to &quot;Пароль суперпользователя&quot;">​</a></h3><p>Установите пароль суперпользователя:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">passwd</span></span></code></pre></div><h2 id="загрузчик-grub2" tabindex="-1">Загрузчик GRUB2 <a class="header-anchor" href="#загрузчик-grub2" aria-label="Permalink to &quot;Загрузчик GRUB2&quot;">​</a></h2><h3 id="установка-пакета" tabindex="-1">Установка пакета <a class="header-anchor" href="#установка-пакета" aria-label="Permalink to &quot;Установка пакета&quot;">​</a></h3><p>Файлы и утилиты для установки GRUB2 содержатся в пакете <code>grub</code>, и устанавливаются командой:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pacman</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -S</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> grub</span></span></code></pre></div><h3 id="установка-загрузчика" tabindex="-1">Установка загрузчика <a class="header-anchor" href="#установка-загрузчика" aria-label="Permalink to &quot;Установка загрузчика&quot;">​</a></h3><h4 id="установка-bios-версии-загрузчика" tabindex="-1">Установка BIOS-версии загрузчика <a class="header-anchor" href="#установка-bios-версии-загрузчика" aria-label="Permalink to &quot;Установка BIOS-версии загрузчика&quot;">​</a></h4><p>Для установки GRUB2 нужно выполнить команду от root:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">grub-install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/sda</span></span></code></pre></div><ul><li>где <code>/dev/sda</code> это устройство <em><strong>(не раздел!)</strong></em> для установки загрузочных образов GRUB. Файлы загрузчика будут установлены в каталог <code>/boot</code>. Код GRUB (<code>boot.img</code>) будет встроен в начальный сектор, а загрузочный образ <code>core.img</code> – в просвет перед первым разделом MBR, или BIOS boot partition для GPT.</li></ul><p>Если при выполнении команды происходит ошибка, попробуйте добавить <code>--recheck</code> в аргументы как показано ниже:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">grub-install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --recheck</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /dev/sda</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">Загрузчики и этапы загрузки</p><p>Процесс загрузки Linux:</p><ol><li><strong>BIOS/UEFI</strong> — инициализация железа</li><li><strong>Загрузчик (GRUB)</strong> — загружает ядро и initramfs</li><li><strong>Ядро</strong> — монтирует корневую ФС</li><li><strong>systemd</strong> — запускает службы GRUB работает в <strong>режиме реальных адресов</strong> (как DOS!), поэтому:</li></ol><ul><li>Нужен отдельный раздел <code>/boot</code> (обычно ext4)</li><li>Не может напрямую работать с LVM/Btrfs на ранних этапах Это историческое наследие влияет на современную архитектуру систем.</li></ul></div><h3 id="после-установки" tabindex="-1">После установки <a class="header-anchor" href="#после-установки" aria-label="Permalink to &quot;После установки&quot;">​</a></h3><p>В настоящее время GRUB2, сразу после установки, готов к работе только в режиме консоли. (Это будет продолжаться до тех пор, пока мейнтейнеры пакета &quot;grub&quot; не заменят бессмысленный дефолтный файл конфигурации загрузчика на рабочую статическую или автоматически генерируемую версию.)</p><p>Чтобы получить при загрузке действующее меню GRUB2, требуется заменить файл <code>grub.cfg</code> самостоятельно.</p><h3 id="генерация-конфига" tabindex="-1">Генерация конфига <a class="header-anchor" href="#генерация-конфига" aria-label="Permalink to &quot;Генерация конфига&quot;">​</a></h3><p>Команда <code>grub-mkconfig</code> может быть использована для генерации файла <code>grub.cfg</code>.</p><p>Для автоматического обнаружения ОС отличных от Linux установите пакет <code>os-prober</code>. Если после установки пакета <code>os-prober</code> автоматическое обнаружение не работает должным образом, то может потребоваться установка пакета <code>hwinfo</code>. Чтобы применить изменения, запустите команду:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">grub-mkconfig</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /boot/grub/grub.cfg</span></span></code></pre></div><p>Она не только создаст файл <code>/boot/grub/grub.cfg</code>, но и проверит конфигурацию на наличие ошибок.</p><div class="warning custom-block"><p class="custom-block-title">Важно</p><p>Если вы запускаете конфигуратор при установке Arch Linux, убедитесь, что вы делаете это внутри <code>arch-chroot</code>, иначе программа будет читать и записывать файлы конфигурации текущей, а не устанавливаемой системы.</p></div><h2 id="перезагрузка" tabindex="-1">Перезагрузка <a class="header-anchor" href="#перезагрузка" aria-label="Permalink to &quot;Перезагрузка&quot;">​</a></h2><p>Выйдите из окружения chroot, набрав <code>exit</code> или нажав <code>Ctrl+d</code>.</p><p>Вы можете размонтировать все разделы с помощью команды:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">umount</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -R</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /mnt</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">Фаза выгрузки системы</p><p>Команда <code>umount -R</code> критична, потому что:</p><ul><li>Ядро блокирует доступ к файлам при монтировании</li><li>Неотмонтированные разделы могут повредить данные</li><li><code>systemd</code> автоматически размонтирует при перезагрузке, но лучше делать это вручную</li></ul><p>Это демонстрирует <strong>принцип синхронизации состояния</strong> в Unix-системах: все операции с диском должны быть завершены перед выключением.</p></div><p>Теперь перезагрузите компьютер, набрав <code>reboot</code>: если какие-нибудь разделы остались смонтированными, <code>systemd</code> их размонтирует. Не забудьте извлечь установочный носитель. После загрузки войдите в систему в качестве суперпользователя.</p><h2 id="контрольные-вопросы-по-теме-установка-arch-linux" tabindex="-1"><strong>Контрольные вопросы по теме: Установка Arch Linux</strong> <a class="header-anchor" href="#контрольные-вопросы-по-теме-установка-arch-linux" aria-label="Permalink to &quot;**Контрольные вопросы по теме: Установка Arch Linux**&quot;">​</a></h2><h3 id="_1-общие-сведения" tabindex="-1"><strong>1. Общие сведения</strong> <a class="header-anchor" href="#_1-общие-сведения" aria-label="Permalink to &quot;**1. Общие сведения**&quot;">​</a></h3><ol><li>Какие минимальные системные требования для установки Arch Linux?</li><li>Зачем нужен работающий интернет-доступ при установке Arch Linux?</li><li>Что представляет собой live-система при установке Arch Linux?</li><li>Где можно найти официальную документацию по установке Arch Linux?</li></ol><h3 id="_2-разметка-дисков" tabindex="-1"><strong>2. Разметка дисков</strong> <a class="header-anchor" href="#_2-разметка-дисков" aria-label="Permalink to &quot;**2. Разметка дисков**&quot;">​</a></h3><ol start="5"><li>Какие команды можно использовать для просмотра списка доступных блочных устройств?</li><li>Как определить, какой диск использовать для установки системы?</li><li>Какие типы разделов необходимо создать при установке Arch Linux (минимальный набор)?</li><li>Какая команда используется для разметки диска в интерактивном режиме?</li><li>Почему при установке GRUB в режиме BIOS важно указывать не раздел, а само устройство (например, <code>/dev/sda</code>, а не <code>/dev/sda1</code>)?</li></ol><h3 id="_3-форматирование-и-монтирование" tabindex="-1"><strong>3. Форматирование и монтирование</strong> <a class="header-anchor" href="#_3-форматирование-и-монтирование" aria-label="Permalink to &quot;**3. Форматирование и монтирование**&quot;">​</a></h3><ol start="10"><li>Какая команда используется для форматирования раздела в файловую систему ext4?</li><li>Что делает команда <code>mkswap</code> и для какого раздела она применяется?</li><li>Как активировать swap-раздел после его создания?</li><li>В какую директорию монтируется корневой раздел при установке?</li><li>Какая опция команды <code>mount</code> позволяет автоматически создать точку монтирования?</li></ol><h3 id="_4-установка-пакетов" tabindex="-1"><strong>4. Установка пакетов</strong> <a class="header-anchor" href="#_4-установка-пакетов" aria-label="Permalink to &quot;**4. Установка пакетов**&quot;">​</a></h3><ol start="15"><li>Что делает утилита <code>pacstrap</code>?</li><li>Какие пакеты устанавливаются командой:</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pacstrap</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -K</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /mnt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> base</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> linux</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> linux-firmware</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dhcpcd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nano</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> openssh</span></span></code></pre></div><ol start="17"><li>Зачем нужно обновлять <code>archlinux-keyring</code> при возникновении ошибок с PGP-ключами?</li><li>Можно ли установить Arch Linux без ядра? В каком случае это допустимо?</li><li>Какие дополнительные пакеты могут понадобиться для полноценной базовой системы?</li></ol><h3 id="_5-настроика-системы" tabindex="-1"><strong>5. Настройка системы</strong> <a class="header-anchor" href="#_5-настроика-системы" aria-label="Permalink to &quot;**5. Настройка системы**&quot;">​</a></h3><ol start="20"><li>Как сгенерировать файл <code>/etc/fstab</code>? Какой ключ рекомендуется использовать и почему?</li><li>Для чего используется команда <code>arch-chroot</code> и когда она применяется?</li><li>Как установить часовой пояс в Arch Linux? Приведите пример команды.</li><li>Какая команда синхронизирует системные часы с аппаратными?</li><li>В каком формате предполагается, что работают аппаратные часы при выполнении <code>hwclock --systohc</code>?</li><li>Как установить пароль для пользователя root?</li></ol><h3 id="_6-загрузчик-grub" tabindex="-1"><strong>6. Загрузчик GRUB</strong> <a class="header-anchor" href="#_6-загрузчик-grub" aria-label="Permalink to &quot;**6. Загрузчик GRUB**&quot;">​</a></h3><ol start="26"><li>Какой пакет необходимо установить для работы с GRUB2?</li><li>Какая команда устанавливает загрузчик GRUB2 на диск в режиме BIOS?</li><li>Что делает опция <code>--recheck</code> в команде <code>grub-install</code>?</li><li>Почему после установки GRUB2 требуется вручную генерировать <code>grub.cfg</code>?</li><li>Какая команда генерирует конфигурационный файл GRUB?</li><li>Какой пакет нужен для обнаружения других операционных систем при генерации <code>grub.cfg</code>?</li><li>Почему важно запускать <code>grub-mkconfig</code> внутри <code>arch-chroot</code>?</li></ol><h3 id="_7-завершение-установки" tabindex="-1"><strong>7. Завершение установки</strong> <a class="header-anchor" href="#_7-завершение-установки" aria-label="Permalink to &quot;**7. Завершение установки**&quot;">​</a></h3><ol start="33"><li>Как выйти из окружения <code>chroot</code>?</li><li>Как размонтировать все разделы перед перезагрузкой?</li><li>Что произойдёт, если не извлечь установочный носитель после перезагрузки?</li></ol><h2 id="отчет" tabindex="-1">Отчёт <a class="header-anchor" href="#отчет" aria-label="Permalink to &quot;Отчёт&quot;">​</a></h2><h3 id="требования-к-отчету" tabindex="-1">Требования к отчету <a class="header-anchor" href="#требования-к-отчету" aria-label="Permalink to &quot;Требования к отчету&quot;">​</a></h3><h4 id="_1-формат-и-структура" tabindex="-1">1. Формат и структура <a class="header-anchor" href="#_1-формат-и-структура" aria-label="Permalink to &quot;1. Формат и структура&quot;">​</a></h4><ul><li>Файл должен называться <code>Group_Lastname_Firstname_HW1.md</code></li><li>Использовать синтаксис Markdown (заголовки, списки, код, цитаты)</li><li>Обязательные разделы:<div class="language-markdown vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;"># Введение</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;"># Анализ этапов установки</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;"># Выводы</span></span></code></pre></div></li></ul><h4 id="_2-содержание-разделов" tabindex="-1">2. Содержание разделов <a class="header-anchor" href="#_2-содержание-разделов" aria-label="Permalink to &quot;2. Содержание разделов&quot;">​</a></h4><p><strong>Введение (200-300 слов)</strong></p><ul><li>Кратко опишите философию Arch Linux (KISS, DIY)</li><li>Объясните разницу между <strong>ядром Linux</strong> и <strong>GNU-утилитами</strong></li><li>Упомяните, почему Arch подходит для изучения архитектуры ОС</li><li><em>Пример:</em><blockquote><p>&quot;Arch Linux реализует принцип «не навязывать предустановленные решения», что позволяет увидеть «костяк» GNU/Linux-системы. В отличие от Ubuntu, где скрыты этапы инициализации, Arch требует ручной настройки каждого компонента...&quot;</p></blockquote></li></ul><p><strong>Анализ этапов установки (основная часть)</strong> Для <strong>каждого</strong> из этапов установки:</p><ol><li><p>Вставьте скриншот терминала с выполненной командой</p></li><li><p>Добавьте подпись с пояснением:</p><div class="language-markdown vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">![</span><span style="--shiki-light:#032F62;--shiki-light-text-decoration:underline;--shiki-dark:#DBEDFF;--shiki-dark-text-decoration:underline;">Разметка диска</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">](</span><span style="--shiki-light:#24292E;--shiki-light-text-decoration:underline;--shiki-dark:#E1E4E8;--shiki-dark-text-decoration:underline;">скриншот.png</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-light-font-style:italic;--shiki-dark:#E1E4E8;--shiki-dark-font-style:italic;">*Рис. 1. Создание разделов через fdisk. Обратите внимание, что /dev/sda — абстракция ядра для SATA-диска, а не физическое устройство.*</span></span></code></pre></div></li><li><p>Напишите краткое описание (80-100 слов), отвечая на простые вопросы:</p><ul><li>Какую команду вы выполняли?</li><li>Что эта команда делает в контексте установки?</li><li>Какие параметры вы использовали и почему?</li><li>Что произошло после выполнения команды?</li></ul><p><em>Пример для этапа разметки:</em></p><blockquote><p>&quot;Команда <code>fdisk /dev/sda</code> запустила утилиту для разметки диска. Я создал два раздела: основной и swap. Параметр <code>/dev/sda</code> указывает на первый жесткий диск. После создания разделов команда <code>lsblk</code> показала новые разделы sda1 и sda2. Это важно, потому что без разделов нельзя установить систему.&quot;</p></blockquote></li></ol><p><strong>Что я узнал(а) (200-250 слов)</strong></p><ul><li>Какие 3 момента процесса установки оказались для вас неожиданными</li><li>Какие команды/этапы были самыми сложными и почему</li><li>Что нового вы поняли о работе операционных систем</li></ul><h4 id="_3-требования-к-скриншотам" tabindex="-1">3. Требования к скриншотам <a class="header-anchor" href="#_3-требования-к-скриншотам" aria-label="Permalink to &quot;3. Требования к скриншотам&quot;">​</a></h4><ul><li>Минимум 5 скриншотов</li><li>В скриншотах должны быть видны: <ul><li>Команды в терминале</li><li>Вывод системных утилит (lsblk, fdisk -l и т.д.)</li><li>Ваш username в приглашении терминала (для подтверждения авторства)</li></ul></li><li>Каждый скриншот должен иметь подпись и пояснение</li></ul><h3 id="важно" tabindex="-1">Важно! <a class="header-anchor" href="#важно" aria-label="Permalink to &quot;Важно!&quot;">​</a></h3><ol><li>Не копируйте текст руководства — пишите своими словами</li><li>Избегайте общих фраз вроде &quot;Linux хорош&quot;</li><li>Ссылайтесь на конкретные компоненты (VFS, udev, initramfs)</li><li>Проверяйте корректность терминов (например, не &quot;ядро GNU&quot;, а &quot;ядро Linux&quot;)</li></ol>`,127)]))}const u=s(t,[["render",o]]);export{k as __pageData,u as default};
