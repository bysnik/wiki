import{_ as e,c as n,o as l,ag as d}from"./chunks/framework.D4Vqf8I7.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/disciplines/osis/s2.md","filePath":"docs/disciplines/osis/s2.md","lastUpdated":1756131983000}'),s={name:"docs/disciplines/osis/s2.md"};function a(r,t,i,c,g,y){return l(),n("div",null,t[0]||(t[0]=[d(`<h3 id="_2-изучить-алгоритмы-планирования-кроме-fcfs-rr" tabindex="-1">2. Изучить алгоритмы планирования (кроме FCFS, RR) <a class="header-anchor" href="#_2-изучить-алгоритмы-планирования-кроме-fcfs-rr" aria-label="Permalink to &quot;2. Изучить алгоритмы планирования (кроме FCFS, RR)&quot;">​</a></h3><p>Раздел:<br> Тема:<br> Количество часов:<br> Задачи:<br> Порядок выполнения работы:</p><p><strong>Shortest-Job-First (SJF)</strong></p><p>При рассмотрении алгоритмов FCFS и RR мы видели, насколько существенным для них является порядок расположения процессов в очереди процессов, готовых к исполнению. Если короткие задачи расположены в очереди ближе к ее началу, то общая производительность этих алгоритмов значительно возрастает. Если бы мы знали время следующих CPU burst для процессов, находящихся в состоянии готовность, то могли бы выбрать для исполнения не процесс из начала очереди, а процесс с минимальной длительностью CPU burst. Если же таких процессов два или больше, то для выбора одного из них можно использовать уже известный нам алгоритм FCFS. Квантование времени при этом не применяется. Описанный алгоритм получил название &quot;кратчайшая работа первой&quot; или Shortest Job First (SJF).</p><p>SJF-алгоритм краткосрочного планирования может быть как вытесняющим, так и невытесняющим.</p><p>При невытесняющем SJF-планировании процессор предоставляется избранному процессу на все необходимое ему время, независимо от событий, происходящих в вычислительной системе. При вытесняющем SJF-планировании учитывается появление новых процессов в очереди готовых к исполнению (из числа вновь родившихся или разблокированных) во время работы выбранного процесса. Если CPU burst нового процесса меньше, чем остаток CPU burst у исполняющегося, то исполняющийся процесс вытесняется новым.</p><p>Рассмотрим пример работы невытесняющего алгоритма SJF. Пусть в состоянии готовность находятся четыре процесса, p0, p1, p2 и p3, для которых известны времена их очередных CPU burst. Эти времена приведены в таблице 3.4. Как и прежде, будем полагать, что вся деятельность процессов ограничивается использованием только одного промежутка CPU burst, что процессы не совершают операций ввода-вывода и что временем переключения контекста можно пренебречь.</p><p><strong>Таблица 3.4.</strong></p><table tabindex="0"><thead><tr><th style="text-align:center;">Процесс</th><th style="text-align:center;">Продолжительность очередного CPU burst</th></tr></thead><tbody><tr><td style="text-align:center;">p0</td><td style="text-align:center;">5</td></tr><tr><td style="text-align:center;">p1</td><td style="text-align:center;">3</td></tr><tr><td style="text-align:center;">p2</td><td style="text-align:center;">7</td></tr><tr><td style="text-align:center;">p3</td><td style="text-align:center;">1</td></tr></tbody></table><p>Основы операционных систем 34</p><p>При использовании невытесняющего алгоритма SJF первым для исполнения будет выбран процесс p3, имеющий наименьшее значение продолжительности очередного CPU burst. После его завершения для исполнения выбирается процесс p1, затем p0 и, наконец, p2. Эта картина отражена в таблице 3.5.</p><p><strong>Таблица 3.5.</strong></p><table tabindex="0"><thead><tr><th style="text-align:center;">Время</th><th style="text-align:center;">1</th><th style="text-align:center;">2</th><th style="text-align:center;">3</th><th style="text-align:center;">4</th><th style="text-align:center;">5</th><th style="text-align:center;">6</th><th style="text-align:center;">7</th><th style="text-align:center;">8</th><th style="text-align:center;">9</th><th style="text-align:center;">10</th><th style="text-align:center;">11</th><th style="text-align:center;">12</th><th style="text-align:center;">13</th><th style="text-align:center;">14</th><th style="text-align:center;">15</th><th style="text-align:center;">16</th></tr></thead><tbody><tr><td style="text-align:center;">p0</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">p1</td><td style="text-align:center;">Г</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">p2</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td></tr><tr><td style="text-align:center;">p3</td><td style="text-align:center;">И</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table><p>Как мы видим, среднее время ожидания для алгоритма SJF составляет (4 + 1 + 9 + 0)/4 = 3,5 единицы времени. Легко посчитать, что для алгоритма FCFS при порядке процессов p0, p1, p2, p3 эта величина будет равняться (0 + 5 + 8 + 15)/4 = 7 единицам времени, т. е. будет в два раза больше, чем для алгоритма SJF. Можно показать, что для заданного набора процессов (если в очереди не появляются новые процессы) алгоритм SJF является оптимальным с точки зрения минимизации среднего времени ожидания среди класса невытесняющих алгоритмов.</p><p>Для рассмотрения примера вытесняющего SJF планирования мы возьмем ряд процессов p0, p1, p2 и p3 с различными временами CPU burst и различными моментами их появления в очереди процессов, готовых к исполнению (см. табл. 3.6.).</p><p><strong>Таблица 3.6.</strong></p><table tabindex="0"><thead><tr><th style="text-align:center;">Процесс</th><th style="text-align:center;">Время появления в очереди</th><th style="text-align:center;">Продолжительность CPU burst</th></tr></thead><tbody><tr><td style="text-align:center;">p0</td><td style="text-align:center;">0</td><td style="text-align:center;">6</td></tr><tr><td style="text-align:center;">p1</td><td style="text-align:center;">2</td><td style="text-align:center;">2</td></tr><tr><td style="text-align:center;">p2</td><td style="text-align:center;">6</td><td style="text-align:center;">7</td></tr><tr><td style="text-align:center;">p3</td><td style="text-align:center;">0</td><td style="text-align:center;">5</td></tr></tbody></table><p>В начальный момент времени в состоянии готовность находятся только два процесса, p0 и p3. Меньшее время очередного CPU burst оказывается у процесса p3, поэтому он и выбирается для исполнения (см. таблицу 3.7.). По прошествии 2 единиц времени в систему поступает процесс p1. Время его CPU burst меньше, чем остаток CPU burst у процесса p3, который вытесняется из состояния исполнение и переводится в состояние готовность. По прошествии еще 2 единиц времени процесс p1 завершается, и для исполнения вновь выбирается процесс p3. В момент времени t = 6 в очереди процессов, готовых к исполнению, появляется процесс p2, но поскольку ему для работы нужно 7 единиц времени, а процессу p3 осталось трудиться всего 1 единицу времени, то процесс p3 остается в состоянии исполнение. После его завершения в момент времени t = 7 в очереди находятся процессы p0 и p2, из которых выбирается процесс p0. Наконец, последним получит возможность выполняться процесс p2.</p><p><strong>Таблица 3.7.</strong></p><table tabindex="0"><thead><tr><th style="text-align:center;">Время</th><th style="text-align:center;">1</th><th style="text-align:center;">2</th><th style="text-align:center;">3</th><th style="text-align:center;">4</th><th style="text-align:center;">5</th><th style="text-align:center;">6</th><th style="text-align:center;">7</th><th style="text-align:center;">8</th><th style="text-align:center;">9</th><th style="text-align:center;">10</th><th style="text-align:center;">11</th><th style="text-align:center;">12</th><th style="text-align:center;">13</th><th style="text-align:center;">14</th><th style="text-align:center;">15</th><th style="text-align:center;">16</th><th style="text-align:center;">17</th><th style="text-align:center;">18</th><th style="text-align:center;">19</th><th style="text-align:center;">20</th></tr></thead><tbody><tr><td style="text-align:center;">p0</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">p1</td><td style="text-align:center;"></td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">p2</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td></tr><tr><td style="text-align:center;">p3</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table><p>Основную сложность при реализации алгоритма SJF представляет невозможность точного знания продолжительности очередного CPU burst для исполняющихся процессов. В пакетных системах количество процессорного времени, необходимое заданию для выполнения, указывает пользователь при формировании задания. Мы можем брать эту величину для осуществления долгосрочного SJF-планирования. Если пользователь укажет больше времени, чем ему нужно, он будет ждать результата дольше, чем мог бы, так как задание будет загружено в систему позже. Если же он укажет меньшее количество времени, задача</p><p>Основы операционных систем 35</p><p>может не досчитаться до конца. Таким образом, в пакетных системах решение задачи оценки времени использования процессора перекладывается на плечи пользователя. При краткосрочном планировании мы можем делать только прогноз длительности следующего CPU burst, исходя из предыстории работы процесса. Пусть τ(n) -- величина n-го CPU burst, T(n + 1) -- предсказываемое значение для n + 1-го CPU burst, α -- некоторая величина в диапазоне от 0 до 1.</p><p>Определим рекуррентное соотношение: T(n+1) = α * τ(n) + (1-α) * T(n)</p><p>T(0) положим произвольной константой. Первое слагаемое учитывает последнее поведение процесса, тогда как второе слагаемое учитывает его предысторию. При α = 0 мы перестаем следить за последним поведением процесса, фактически полагая: T(n) = T(n+1) = ... = T(0)</p><p>т. е. оценивая все CPU burst одинаково, исходя из некоторого начального предположения.</p><p>Положив α = 1, мы забываем о предыстории процесса. В этом случае мы полагаем, что время очередного CPU burst будет совпадать со временем последнего CPU burst: T(n+1) = τ(n)</p><p>Обычно выбирают α = 1/2 для равноценного учета последнего поведения и предыстории. Надо отметить, что такой выбор удобен и для быстрой организации вычисления оценки T(n + 1). Для подсчета новой оценки нужно взять старую оценку, сложить с измеренным временем CPU burst и полученную сумму разделить на 2, например, сдвинув ее на 1 бит вправо. Полученные оценки T(n + 1) применяются как продолжительности очередных промежутков времени непрерывного использования процессора для краткосрочного SJF-планирования.</p><p><strong>Гарантированное планирование</strong></p><p>При интерактивной работе N пользователей в вычислительной системе можно применить алгоритм планирования, который гарантирует, что каждый из пользователей будет иметь в своем распоряжении ~1/N часть процессорного времени. Пронумеруем всех пользователей от 1 до N. Для каждого пользователя с номером i введем две величины: Ti -- время нахождения пользователя в системе или, другими словами, длительность сеанса его общения с машиной и τi -- суммарное процессорное время уже выделенное всем его процессам в течение сеанса. Справедливым для пользователя было бы получение Ti/N процессорного времени. Если τi &lt;&lt; Ti/N то i-й пользователь несправедливо обделен процессорным временем. Если же τi &gt;&gt; Ti/N то система явно благоволит к пользователю с номером i. Вычислим для процессов каждого пользователя значение коэффициента справедливости: τi * N / Ti и будем предоставлять очередной квант времени готовому процессу с наименьшей величиной этого отношения. Предложенный алгоритм называют алгоритмом гарантированного планирования. К недостаткам этого алгоритма можно отнести невозможность предугадать поведение пользователей. Если некоторый пользователь отправится на пару часов пообедать и поспать, не прерывая сеанса работы, то по возвращении его процессы будут получать неоправданно много процессорного времени.</p><p>Основы операционных систем 36</p><p><strong>Приоритетное планирование</strong></p><p>Алгоритмы SJF и гарантированного планирования представляют собой частные случаи приоритетного планирования. При приоритетном планировании каждому процессу присваивается определенное числовое значение -- приоритет, в соответствии с которым ему выделяется процессор. Процессы с одинаковыми приоритетами планируются в порядке FCFS. Для алгоритма SJF в качестве такого приоритета выступает оценка продолжительности следующего CPU burst. Чем меньше значение этой оценки, тем более высокий приоритет имеет процесс. Для алгоритма гарантированного планирования приоритетом служит вычисленный коэффициент справедливости. Чем он меньше, тем больше у процесса приоритет.</p><p>Алгоритмы назначения приоритетов процессов могут опираться как на внутренние параметры, связанные с происходящим внутри вычислительной системы, так и на внешние по отношению к ней. К внутренним параметрам относятся различные количественные и качественные характеристики процесса такие как: ограничения по времени использования процессора, требования к размеру памяти, число открытых файлов и используемых устройств ввода-вывода, отношение средних продолжительностей I/O burst к CPU burst и т. д. Алгоритмы SJF и гарантированного планирования используют внутренние параметры. В качестве внешних параметров могут выступать важность процесса для достижения каких-либо целей, стоимость оплаченного процессорного времени и другие политические факторы. Высокий внешний приоритет может быть присвоен задаче лектора или того, кто заплатил $100 за работу в течение одного часа.</p><p>Планирование с использованием приоритетов может быть как вытесняющим, так и невытесняющим. При вытесняющем планировании процесс с более высоким приоритетом, появившийся в очереди готовых процессов, вытесняет исполняющийся процесс с более низким приоритетом. В случае невытесняющего планирования он просто становится в начало очереди готовых процессов. Давайте рассмотрим примеры использования различных режимов приоритетного планирования.</p><p>Пусть в очередь процессов, находящихся в состоянии готовность, поступают те же процессы, что и в примере для вытесняющего алгоритма SJF, только им дополнительно еще присвоены приоритеты (см. табл. 3.8.). В вычислительных системах не существует определенного соглашения, какое значение приоритета -- 1 или 4 считать более приоритетным. Во избежание путаницы, во всех наших примерах мы будем предполагать, что большее значение соответствует меньшему приоритету, т. е. наиболее приоритетным в нашем примере является процесс p3, а наименее приоритетным -- процесс p0.</p><p><strong>Таблица 3.8.</strong></p><table tabindex="0"><thead><tr><th style="text-align:center;">Процесс</th><th style="text-align:center;">Время появления в очереди</th><th style="text-align:center;">Продолжительность очередного CPU burst</th><th style="text-align:center;">Приоритет</th></tr></thead><tbody><tr><td style="text-align:center;">p0</td><td style="text-align:center;">0</td><td style="text-align:center;">6</td><td style="text-align:center;">4</td></tr><tr><td style="text-align:center;">p1</td><td style="text-align:center;">2</td><td style="text-align:center;">2</td><td style="text-align:center;">3</td></tr><tr><td style="text-align:center;">p2</td><td style="text-align:center;">6</td><td style="text-align:center;">7</td><td style="text-align:center;">2</td></tr><tr><td style="text-align:center;">p3</td><td style="text-align:center;">0</td><td style="text-align:center;">5</td><td style="text-align:center;">1</td></tr></tbody></table><p>Как будут вести себя процессы при использовании невытесняющего приоритетного планирования? Первым для выполнения в момент времени t = 0 выбирается процесс p3, как обладающий наивысшим приоритетом. После его завершения в момент времени t = 5 в очереди процессов, готовых к исполнению, окажутся два процесса p0 и p1. Больший приоритет из них у процесса p1, он и начнет выполняться (см. табл. 3.9.). Затем в момент времени t = 8 для исполнения будет избран процесс p2, и лишь потом -- процесс p0.</p><p><strong>Таблица 3.9.</strong></p><table tabindex="0"><thead><tr><th style="text-align:center;">Время</th><th style="text-align:center;">1</th><th style="text-align:center;">2</th><th style="text-align:center;">3</th><th style="text-align:center;">4</th><th style="text-align:center;">5</th><th style="text-align:center;">6</th><th style="text-align:center;">7</th><th style="text-align:center;">8</th><th style="text-align:center;">9</th><th style="text-align:center;">10</th><th style="text-align:center;">11</th><th style="text-align:center;">12</th><th style="text-align:center;">13</th><th style="text-align:center;">14</th><th style="text-align:center;">15</th><th style="text-align:center;">16</th><th style="text-align:center;">17</th><th style="text-align:center;">18</th><th style="text-align:center;">19</th><th style="text-align:center;">20</th></tr></thead><tbody><tr><td style="text-align:center;">p0</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td></tr><tr><td style="text-align:center;">p1</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">p2</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">Г</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">p3</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table><p>Основы операционных систем 37</p><p>Иным будет предоставление процессора процессам в случае вытесняющего приоритетного планирования (см. табл. 3.10.). Первым, как и в предыдущем случае, начнет исполняться процесс p3, а по его окончании -- процесс p1. Однако в момент времени t = 6 он будет вытеснен процессом p2 и продолжит свое выполнение только в момент времени t = 13. Последним, как и раньше, будет исполняться процесс p0.</p><p><strong>Таблица 3.10.</strong></p><table tabindex="0"><thead><tr><th style="text-align:center;">Время</th><th style="text-align:center;">1</th><th style="text-align:center;">2</th><th style="text-align:center;">3</th><th style="text-align:center;">4</th><th style="text-align:center;">5</th><th style="text-align:center;">6</th><th style="text-align:center;">7</th><th style="text-align:center;">8</th><th style="text-align:center;">9</th><th style="text-align:center;">10</th><th style="text-align:center;">11</th><th style="text-align:center;">12</th><th style="text-align:center;">13</th><th style="text-align:center;">14</th><th style="text-align:center;">15</th><th style="text-align:center;">16</th><th style="text-align:center;">17</th><th style="text-align:center;">18</th><th style="text-align:center;">19</th><th style="text-align:center;">20</th></tr></thead><tbody><tr><td style="text-align:center;">p0</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td></tr><tr><td style="text-align:center;">p1</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">И</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">Г</td><td style="text-align:center;">И</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">p2</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">p3</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;">И</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table><p>В рассмотренном выше примере приоритеты процессов с течением времени не изменялись. Такие приоритеты принято называть статическими. Механизмы статической приоритетности легко реализовать, и они сопряжены с относительно небольшими издержками на выбор наиболее приоритетного процесса. Однако статические приоритеты не реагируют на изменения ситуации в вычислительной системе, которые могут сделать желательной корректировку порядка исполнения процессов. Более гибкими являются динамические приоритеты процессов, изменяющие свои значения по ходу исполнения процессов. Начальное значение динамического приоритета, присвоенное процессу, действует в течение лишь короткого периода времени, после чего ему назначается новое, более подходящее значение. Изменение динамического приоритета процесса является единственной операцией над процессами, которую мы до сих пор не рассмотрели. Как правило, изменение приоритета процессов проводится согласованно с совершением каких-либо других операций: при рождении нового процесса, при разблокировке или блокировании процесса, по истечении определенного кванта времени или по завершении процесса. Примерами алгоритмов с динамическими приоритетами являются алгоритм SJF и алгоритм гарантированного планирования.</p><p>Схемы с динамической приоритетностью гораздо сложнее в реализации и связаны с большими издержками по сравнению со статическими схемами. Однако их использование предполагает, что эти издержки оправдываются улучшением работы системы.</p><p>Главная проблема приоритетного планирования заключается в том, что при ненадлежащем выборе механизма назначения и изменения приоритетов низкоприоритетные процессы могут не запускаться неопределенно долгое время. Обычно случается одно из двух. Или они все же дожидаются своей очереди на исполнение (в девять часов утра в воскресенье, когда все приличные программисты ложатся спать). Или вычислительную систему приходится выключать, и они теряются (при остановке IBM 7094 в Массачусетском технологическом институте в 1973 году были найдены процессы, запущенные в 1967 году и ни разу с тех пор не исполнявшиеся). Решение этой проблемы может быть достигнуто с помощью увеличения со временем значения приоритета процесса, находящегося в состоянии готовность. Пусть изначально процессам присваиваются приоритеты от 128 до 255. Каждый раз по истечении определенного промежутка времени значения приоритетов готовых процессов уменьшаются на 1. Процессу, побывавшему в состоянии исполнение, присваивается первоначальное значение приоритета. Даже такая грубая схема гарантирует, что любому процессу в разумные сроки будет предоставлено право на исполнение.</p><p><strong>Многоуровневые очереди (Multilevel Queue)</strong></p><p>Для систем, в которых процессы могут быть легко рассортированы по разным группам, был разработан другой класс алгоритмов планирования. Для каждой группы процессов создается своя очередь процессов, находящихся в состоянии готовность (см. рис. 3.5). Этим очередям приписываются фиксированные приоритеты. Например, приоритет очереди системных процессов устанавливается выше, чем приоритет очередей пользовательских процессов. А приоритет очереди процессов, запущенных студентами, ниже, чем для очереди процессов, запущенных преподавателями. Это значит, что ни один пользовательский процесс не будет выбран для исполнения, пока есть хоть один готовый системный процесс, и ни один студенческий процесс не получит в свое распоряжение процессор, если есть процессы преподавателей, готовые к исполнению. Внутри этих очередей для планирования могут применяться самые разные алгоритмы. Так, например, для больших счетных процессов, не требующих взаимодействия с пользователем (фоновых процессов), может использоваться алгоритм FCFS, а для интерактивных процессов -- алгоритм</p><p>Основы операционных систем 38</p><p>RR. Подобный подход, получивший название многоуровневых очередей, повышает гибкость планирования: для процессов с различными характеристиками применяется наиболее подходящий им алгоритм.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>+-----------------+</span></span>
<span class="line"><span>| Очередь 0 (RR)  |&lt;-- Высший приоритет</span></span>
<span class="line"><span>| Системные       |</span></span>
<span class="line"><span>+-----------------+</span></span>
<span class="line"><span>| Очередь 1 (RR)  |</span></span>
<span class="line"><span>| Интерактивные   |</span></span>
<span class="line"><span>+-----------------+</span></span>
<span class="line"><span>| Очередь 2 (FCFS)|</span></span>
<span class="line"><span>| Фоновые         |</span></span>
<span class="line"><span>+-----------------+</span></span>
<span class="line"><span>| Очередь 3 (FCFS)|&lt;-- Низший приоритет</span></span>
<span class="line"><span>| Пакетные        |</span></span>
<span class="line"><span>+-----------------+</span></span></code></pre></div><p><em>Рис. 3.5. Несколько очередей планирования</em></p><p><strong>Многоуровневые очереди с обратной связью (Multilevel Feedback Queue)</strong></p><p>Дальнейшим развитием алгоритма многоуровневых очередей является добавление к нему механизма обратной связи. Здесь процесс не постоянно приписан к определенной очереди, а может мигрировать из одной очереди в другую в зависимости от своего поведения.</p><p>Для простоты рассмотрим ситуацию, когда процессы в состоянии готовность организованы в 4 очереди, как на рисунке 3.6. Планирование процессов между очередями осуществляется на основе вытесняющего приоритетного механизма. Чем выше на рисунке располагается очередь, тем выше ее приоритет. Процессы в очереди 1 не могут исполняться, если в очереди 0 есть хотя бы один процесс. Процессы в очереди 2 не будут выбраны для выполнения, пока есть хоть один процесс в очередях 0 и 1. И наконец, процесс в очереди 3 может получить процессор в свое распоряжение только тогда, когда очереди 0, 1 и 2 пусты.</p><p>Если при работе процесса появляется другой процесс в какой-либо более приоритетной очереди, исполняющийся процесс вытесняется новым. Планирование процессов внутри очередей 0--2 осуществляется с использованием алгоритма RR, планирование процессов в очереди 3 основывается на алгоритме FCFS.</p><p>Основы операционных систем 39</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>+-----------------+  Квант 8  +-----------------+  Квант 16 +-----------------+  Квант 32 +-----------------+</span></span>
<span class="line"><span>| Очередь 0 (RR)  |&lt;----------| Очередь 1 (RR)  |&lt;----------| Очередь 2 (RR)  |&lt;----------| Очередь 3 (FCFS)|</span></span>
<span class="line"><span>| Высший приор.   |           |                 |           |                 |           | Низший приор.  |</span></span>
<span class="line"><span>+-----------------+           +-----------------+           +-----------------+           +-----------------+</span></span>
<span class="line"><span>      ^                               ^                               ^                               ^</span></span>
<span class="line"><span>      |                               |                               |                               |</span></span>
<span class="line"><span>      +-------------------------------+-------------------------------+-------------------------------+</span></span>
<span class="line"><span>                                      Миграция процессов при исчерпании кванта времени</span></span></code></pre></div><p><em>Рис. 3.6. Схема миграции процессов в многоуровневых очередях планирования с обратной связью. Вытеснение процессов более приоритетными процессами и завершение процессов на схеме не показано</em></p><p>Родившийся процесс поступает в очередь 0. При выборе на исполнение он получает в свое распоряжение квант времени размером 8 единиц. Если продолжительность его CPU burst меньше этого кванта времени, процесс остается в очереди 0. В противном случае он переходит в очередь 1. Для процессов из очереди 1 квант времени имеет величину 16. Если процесс не укладывается в это время, он переходит в очередь 2. Если укладывается -- остается в очереди 1. В очереди 2 величина кванта времени составляет 32 единицы. Если для непрерывной работы процесса и этого мало, процесс поступает в очередь 3, для которой квантование времени не применяется и, при отсутствии готовых процессов в других очередях, может исполняться до окончания своего CPU burst. Чем больше значение продолжительности CPU burst, тем в менее приоритетную очередь попадает процесс, но тем на большее процессорное время он может рассчитывать.</p><p>Таким образом, через некоторое время все процессы, требующие малого времени работы процессора, окажутся размещенными в высокоприоритетных очередях, а все процессы, требующие большого счета и с низкими запросами к времени отклика, -- в низкоприоритетных.</p><p>Миграция процессов в обратном направлении может осуществляться по различным принципам. Например, после завершения ожидания ввода с клавиатуры процессы из очередей 1, 2 и 3 могут помещаться в очередь 0, после завершения дисковых операций ввода-вывода процессы из очередей 2 и 3 могут помещаться в очередь 1, а после завершения ожидания всех других событий -- из очереди 3 в очередь 2. Перемещение процессов из очередей с низкими приоритетами в очереди с высокими приоритетами позволяет более полно учитывать изменение поведения процессов с течением времени.</p><p>Многоуровневые очереди с обратной связью представляют собой наиболее общий подход к планированию процессов из числа подходов, рассмотренных нами. Они наиболее трудны в реализации, но в то же время обладают наибольшей гибкостью. Понятно, что существует много других разновидностей такого способа планирования, помимо варианта, приведенного выше. Для полного описания их конкретного воплощения необходимо указать:</p><ul><li>Количество очередей для процессов, находящихся в состоянии готовность.</li><li>Алгоритм планирования, действующий между очередями.</li><li>Алгоритмы планирования, действующие внутри очередей.</li><li>Правила помещения родившегося процесса в одну из очередей.</li><li>Правила перевода процессов из одной очереди в другую.</li></ul><p>Изменяя какой-либо из перечисленных пунктов, мы можем существенно менять поведение вычислительной системы.</p><p>На этом мы прекращаем рассмотрение различных алгоритмов планирования процессов, ибо, как было сказано: &quot;Нельзя объять необъятное&quot;.</p><p><strong>Заключение</strong></p><p>Одним из наиболее ограниченных ресурсов вычислительной системы является процессорное время. Для его распределения между многочисленными процессами в системе приходится применять процедуру планирования процессов. По степени длительности влияния планирования на поведение вычислительной системы различают краткосрочное, среднесрочное и долгосрочное планирование процессов. Конкретные алгоритмы планирования процессов зависят от поставленных целей, класса решаемых задач и опираются на статические и динамические параметры процессов и компьютерных систем. Различают вытесняющий и невытесняющий режимы планирования. При невытесняющем планировании исполняющийся процесс уступает процессор другому процессу только по собственному желанию, при вытесняющем планировании исполняющийся процесс может быть вытеснен из состояния исполнения помимо своей воли.</p><p>Простейшим алгоритмом планирования является невытесняющий алгоритм FCFS, который, однако, может существенно задерживать короткие процессы, не вовремя перешедшие в состояние готовность. В системах разделения времени широкое распространение получила вытесняющая версия этого алгоритма -- RR.</p><p>Основы операционных систем 40</p><p>Среди всех невытесняющих алгоритмов оптимальным с точки зрения среднего времени ожидания процессов является алгоритм SJF. Существует и вытесняющий вариант этого алгоритма. В интерактивных системах часто используется алгоритм гарантированного планирования, обеспечивающий пользователям равные части процессорного времени.</p><p>Алгоритм SJF и алгоритм гарантированного планирования являются частными случаями планирования с использованием приоритетов. В более общих методах приоритетного планирования применяются многоуровневые очереди процессов, готовых к исполнению, и многоуровневые очереди с обратной связью. Будучи наиболее сложными в реализации, эти способы планирования обеспечивают гибкое поведение вычислительных систем и их адаптивность к решению задач разных классов.</p>`,74)]))}const h=e(s,[["render",a]]);export{p as __pageData,h as default};
