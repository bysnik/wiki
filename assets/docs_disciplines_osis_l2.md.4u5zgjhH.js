import{_ as l,c as n,o as p,ag as a,j as i,a as t}from"./chunks/framework.D4Vqf8I7.js";const y=JSON.parse('{"title":"Лекция 2. Процессы и нити: механизмы обмена информацией","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"docs/disciplines/osis/l2.md","filePath":"docs/disciplines/osis/l2.md","lastUpdated":1761642269000}'),e={name:"docs/disciplines/osis/l2.md"},h={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},d={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.186ex"},xmlns:"http://www.w3.org/2000/svg",width:"6.816ex",height:"2.072ex",role:"img",focusable:"false",viewBox:"0 -833.9 3012.6 915.9","aria-hidden":"true"};function k(o,s,r,g,c,u){return p(),n("div",null,[s[8]||(s[8]=a('<h1 id="лекция-2-процессы-и-нити-механизмы-обмена-информациеи" tabindex="-1">Лекция 2. Процессы и нити: механизмы обмена информацией <a class="header-anchor" href="#лекция-2-процессы-и-нити-механизмы-обмена-информациеи" aria-label="Permalink to &quot;Лекция 2. Процессы и нити: механизмы обмена информацией&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">Дополнительная литература</p><p><a href="http://www.vlrscc.ru/uch/os_new/zan/z22/lek_4_3.pdf" target="_blank" rel="noreferrer">http://www.vlrscc.ru/uch/os_new/zan/z22/lek_4_3.pdf</a> и <a href="https://rus-linux.net/lib.php?name=/denis/art/process.html" target="_blank" rel="noreferrer">https://rus-linux.net/lib.php?name=/denis/art/process.html</a> и <a href="https://it.wikireading.ru/1731" target="_blank" rel="noreferrer">https://it.wikireading.ru/1731</a> и <a href="https://www.parallel.uran.ru/book/export/html/524" target="_blank" rel="noreferrer">https://www.parallel.uran.ru/book/export/html/524</a>, <a href="https://citforum.ru/operating_systems/unix/contents.shtml" target="_blank" rel="noreferrer">https://citforum.ru/operating_systems/unix/contents.shtml</a></p></div><h2 id="понятие-процесса" tabindex="-1">Понятие процесса <a class="header-anchor" href="#понятие-процесса" aria-label="Permalink to &quot;Понятие процесса&quot;">​</a></h2><p>Раньше мы использовали термины «программа» и «задание» для описания способов построения ОС. Но теперь мы начинаем знакомиться с деталями функционирования современных компьютерных систем, и нам придется уточнить терминологию.</p><p>Рассмотрим следующий пример. Два студента запускают программу извлечения квадратного корня. Один хочет вычислить квадратный корень из 4, а второй – из 1. С точки зрения студентов, запущена одна и та же программа; с точки зрения компьютерной системы, ей приходится заниматься двумя различными вычислительными процессами, так как разные исходные данные приводят к разному набору вычислений. Следовательно, на уровне происходящего внутри вычислительной системы мы не можем использовать термин &quot;программа&quot; в пользовательском смысле слова.</p><p>Рассматривая системы пакетной обработки, мы ввели понятие &quot;задание&quot; как совокупность программы, набора команд языка управления заданиями, необходимых для ее выполнения, и входных данных. С точки зрения студентов, они, подставив разные исходные данные, сформировали два различных задания.</p><p>Может быть, термин &quot;задание&quot; подойдет нам для описания внутреннего функционирования компьютерных систем? Пусть оба студента пытаются извлечь квадратный корень из 1, то есть пусть они сформировали идентичные задания, но загрузили их в вычислительную систему со сдвигом по времени. В то время как одно из выполняемых заданий приступило к печати полученного значения и ждет окончания операции ввода-вывода, второе только начинает исполняться. Задания не идентичны, так как состояние процесса их выполнения различно. Следовательно, и слово &quot;задание&quot; в пользовательском смысле не может применяться для описания происходящего в вычислительной системе.</p><p>Это происходит потому, что термины &quot;программа&quot; и &quot;задание&quot; предназначены для описания статических, неактивных объектов. Программа же в процессе исполнения является динамическим, активным объектом. По ходу ее работы компьютер обрабатывает различные команды и преобразует значения переменных. Для выполнения программы операционная система должна выделить определенное количество оперативной памяти, закрепить за ней определенные устройства ввода-вывода или файлы (откуда должны поступать входные данные и куда нужно доставить полученные результаты), то есть зарезервировать определенные ресурсы из общего числа ресурсов всей вычислительной системы. Их количество и конфигурация с течением времени могут изменяться. Для описания таких активных объектов внутри компьютерной системы вместо терминов &quot;программа&quot; и &quot;задание&quot; мы будем использовать новый термин – &quot;процесс&quot;.</p><div class="info custom-block"><p class="custom-block-title">Определение</p><p><strong>Понятие процесса</strong> характеризует некоторую совокупность набора исполняющихся команд, ассоциированных с ним ресурсов (выделенная для исполнения память или адресное пространство, используемые файлы и устройства ввода-вывода и т. д.) и текущего момента его выполнения (значения регистров, программного счетчика, состояние стека и значения переменных), находящуюся под управлением операционной системы. Не существует взаимно-однозначного соответствия между процессами и программами, обрабатываемыми вычислительными системами.</p></div><p>В некоторых операционных системах для работы определенных программ может организовываться более одного процесса или один и тот же процесс может исполнять последовательно несколько различных программ. Более того, даже в случае обработки только одной программы в рамках одного процесса нельзя считать, что процесс представляет собой просто динамическое описание кода исполняемого файла, данных и выделенных для них ресурсов. Процесс находится под управлением операционной системы, поэтому в нем может выполняться часть кода ее ядра (не находящегося в исполняемом файле!), как в случаях, специально запланированных авторами программы (например, при использовании системных вызовов), так и в непредусмотренных ситуациях (например, при обработке внешних прерываний).</p><h2 id="состояния-процесса" tabindex="-1">Состояния процесса <a class="header-anchor" href="#состояния-процесса" aria-label="Permalink to &quot;Состояния процесса&quot;">​</a></h2><h3 id="усредненная-структура" tabindex="-1">Усредненная структура <a class="header-anchor" href="#усредненная-структура" aria-label="Permalink to &quot;Усредненная структура&quot;">​</a></h3><p>Понятно, что реально на однопроцессорной компьютерной системе в каждый момент времени может исполняться только один процесс. Для мультипрограммных вычислительных систем псевдопараллельная обработка нескольких процессов достигается с помощью переключения процессора с одного процесса на другой. Пока один процесс выполняется, остальные ждут своей очереди.</p><p>Как видим, каждый процесс может находиться в двух состояниях: процесс исполняется и процесс не исполняется.</p>',14)),s[9]||(s[9]=i("iframe",{src:"https://viewer.diagrams.net/?highlight=0000ff&layers=1&nav=1&title=Diagram#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1sHhsGhJREe7aB6HNjPgVEcGvIcENGcJf%26export%3Ddownload",width:"100%",height:"300px",frameborder:"0",allowfullscreen:""},null,-1)),s[10]||(s[10]=i("p",null,'Процесс, находящийся в состоянии "процесс исполняется", через некоторое время может быть завершен операционной системой или приостановлен и снова переведен в состояние "процесс не исполняется". Приостановка процесса происходит по двум причинам: для его дальнейшей работы потребовалось какое-либо событие (например, завершение операции ввода-вывода) или истек временной интервал, отведенный операционной системе для работы данного процесса. После этого операционная система по определенному алгоритму выбирает для исполнения один из процессов, находящихся в состоянии "процесс не исполняется", и переводит его в состояние "процесс исполняется". Новый процесс, появляющийся в системе, первоначально помещается в состояние "процесс не исполняется".',-1)),s[11]||(s[11]=i("p",null,"Составим диаграмму состояния, принятую в курсе:",-1)),s[12]||(s[12]=i("iframe",{src:"https://viewer.diagrams.net/?highlight=0000ff&layers=1&nav=1&title=Diagram#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1m8crMPfTCQyOqD1DsWv_5eq_TtgeBU7r%26export%3Ddownload",width:"100%",height:"500px",frameborder:"0",allowfullscreen:""},null,-1)),s[13]||(s[13]=i("p",null,'При рождении процесс получает в свое распоряжение адресное пространство, в которое загружается программный код процесса; ему выделяются стек и системные ресурсы; устанавливается начальное значение программного счетчика этого процесса и т. д. Родившийся процесс переводится в состояние "готовность".',-1)),s[14]||(s[14]=i("p",null,'Операционная система, пользуясь каким-либо алгоритмом планирования, выбирает один из готовых процессов и переводит его в состояние "исполнение". В состоянии "исполнение" происходит непосредственное выполнение программного код процесса. Выйти из этого состояния процесс может по трем причинам:',-1)),s[15]||(s[15]=i("ul",null,[i("li",null,"операционная система прекращает его деятельность;"),i("li",null,"он не может продолжать свою работу, пока не произойдет некоторое событие, и операционная система переводит его в состояние ожидание;"),i("li",null,"в результате возникновения прерывания в вычислительной системе (например, прерывания от таймера по истечении предусмотренного времени выполнения) его возвращают в состояние готовность.")],-1)),s[16]||(s[16]=i("p",null,'Из состояния "ожидание" процесс попадает в состояние "готовность" после того, как ожидаемое событие произошло, и он снова может быть выбран для исполнения.',-1)),s[17]||(s[17]=i("p",null,'При завершении своей деятельности процесс из состояния "исполнение" попадает в состояние "закончил исполнение".',-1)),s[18]||(s[18]=i("p",null,"В конкретных операционных системах состояния процесса могут быть еще более детализированы. Так, например, модель состояний процессов для операционной системы Windows NT содержит 7 различных состояний, а для операционной системы Unix – 9.",-1)),s[19]||(s[19]=i("div",{class:"info custom-block"},[i("p",{class:"custom-block-title"},"Высокая сложность"),i("h3",{id:"диаграмма-состоянии-unix",tabindex:"-1"},[t("Диаграмма состояний Unix "),i("a",{class:"header-anchor",href:"#диаграмма-состоянии-unix","aria-label":'Permalink to "Диаграмма состояний Unix"'},"​")]),i("p",null,"Полный набор состояний процесса содержится в следующем перечне:"),i("ol",null,[i("li",null,"Процесс выполняется в режиме задачи."),i("li",null,"Процесс выполняется в режиме ядра."),i("li",null,"Процесс не выполняется, но готов к запуску под управлением ядра."),i("li",null,"Процесс приостановлен и находится в оперативной памяти."),i("li",null,"Процесс готов к запуску, но программа подкачки (нулевой процесс) должна еще загрузить процесс в оперативную память, прежде чем он будет запущен под управлением ядра. Это состояние будет предметом обсуждения в главе 9 при рассмотрении системы подкачки."),i("li",null,"Процесс приостановлен и программа подкачки выгрузила его во внешнюю память, чтобы в оперативной памяти освободить место для других процессов."),i("li",null,"Процесс возвращен из привилегированного режима (режима ядра) в непривилегированный (режим задачи), ядро резервирует его и переключает контекст на другой процесс. Об отличии этого состояния от состояния 3 (готовность к запуску) пойдет речь ниже."),i("li",null,"Процесс вновь создан и находится в переходном состоянии; процесс существует, но не готов к выполнению, хотя и не приостановлен. Это состояние является начальным состоянием всех процессов, кроме нулевого."),i("li",null,"Процесс вызывает системную функцию exit и прекращает существование. Однако, после него осталась запись, содержащая код выхода, и некоторая хронометрическая статистика, собираемая родительским процессом. Это состояние является последним состоянием процесса.")]),i("p",null,'Рисунок представляет собой полную диаграмму переходов процесса из состояния в состояние. Рассмотрим с помощью модели переходов типичное поведение процесса. Ситуации, которые будут обсуждаться, несколько искусственны и процессы не всегда имеют дело с ними, но эти ситуации вполне применимы для иллюстрации различных переходов. Начальным состоянием модели является создание процесса родительским процессом с помощью системной функции fork(); из этого состояния процесс неминуемо переходит в состояние готовности к запуску (3 или 5). Для простоты предположим, что процесс перешел в состояние "готовности к запуску в памяти" (3). Планировщик процессов в конечном счете выберет процесс для выполнения и процесс перейдет в состояние "выполнения в режиме ядра", где доиграет до конца роль, отведенную ему функцией fork().'),i("iframe",{src:"https://viewer.diagrams.net/?highlight=0000ff&layers=1&nav=1&title=Diagram#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1aGtVaSSSzRb0SMrLu1TNqP-tXoXmEMAk%26export%3Ddownload",width:"100%",height:"700px",frameborder:"0",allowfullscreen:""}),i("p",null,'После всего этого процесс может перейти в состояние "выполнения в режиме задачи". По прохождении определенного периода времени может произойти прерывание работы процессора по таймеру и процесс снова перейдет в состояние "выполнения в режиме ядра". Как только программа обработки прерывания закончит работу, ядру может понадобиться подготовить к запуску другой процесс, поэтому первый процесс перейдет в состояние "резервирования", уступив дорогу второму процессу. Состояние "резервирования" в действительности не отличается от состояния "готовности к запуску в памяти" (пунктирная линия на рисунке, соединяющая между собой оба состояния, подчеркивает их эквивалентность), но они выделяются в отдельные состояния, чтобы подчеркнуть, что процесс, выполняющийся в режиме ядра, может быть зарезервирован только в том случае, если он собирается вернуться в режим задачи. Следовательно, ядро может при необходимости подкачивать процесс из состояния "резервирования". При известных условиях планировщик выберет процесс для исполнения и тот снова вернется в состояние "выполнения в режиме задачи".'),i("p",null,'Когда процесс выполняет вызов системной функции, он из состояния "выполнения в режиме задачи" переходит в состояние "выполнения в режиме ядра". Предположим, что системной функции требуется ввод-вывод с диска и поэтому процесс вынужден дожидаться завершения ввода-вывода. Он переходит в состояние "приостанова в памяти", в котором будет находиться до тех пор, пока не получит извещения об окончании ввода-вывода. Когда ввод-вывод завершится, произойдет аппаратное прерывание работы центрального процессора и программа обработки прерывания возобновит выполнение процесса, в результате чего он перейдет в состояние "готовности к запуску в памяти".'),i("p",null,'Предположим, что система выполняет множество процессов, которые одновременно никак не могут поместиться в оперативной памяти, и программа подкачки (нулевой процесс) выгружает один процесс, чтобы освободить место для другого процесса, находящегося в состоянии "готов к запуску, но выгружен". Первый процесс, выгруженный из оперативной памяти, переходит в то же состояние. Когда программа подкачки выбирает наиболее подходящий процесс для загрузки в оперативную память, этот процесс переходит в состояние "готовности к запуску в памяти". Планировщик выбирает процесс для исполнения и он переходит в состояние "выполнения в режиме ядра". Когда процесс завершается, он исполняет системную функцию exit, последовательно переходя в состояния "выполнения в режиме ядра" и, наконец, в состояние "прекращения существования".'),i("p",null,'Процесс может управлять некоторыми из переходов на уровне задачи. Во-первых, один процесс может создать другой процесс. Тем не менее, в какое из состояний процесс перейдет после создания (т.е. в состояние "готов к выполнению, находясь в памяти" или в состояние "готов к выполнению, но выгружен") зависит уже от ядра. Процессу эти состояния не подконтрольны. Во-вторых, процесс может обратиться к различным системным функциям, чтобы перейти из состояния "выполнения в режиме задачи" в состояние "выполнения в режиме ядра", а также перейти в режим ядра по своей собственной воле. Тем не менее, момент возвращения из режима ядра от процесса уже не зависит; в результате каких-то событий он может никогда не вернуться из этого режима и из него перейдет в состояние "прекращения существования" (см. раздел 7.2, где говорится о сигналах). Наконец, процесс может завершиться с помощью функции exit по своей собственной воле, но как указывалось ранее, внешние события могут потребовать завершения процесса без явного обращения к функции exit. Все остальные переходы относятся к жестко закрепленной части модели, закодированной в ядре, и являются результатом определенных событий, реагируя на них в соответствии с правилами, сформулированными в этой и последующих главах. Некоторые из правил уже упоминались: например, то, что процесс может выгрузить другой процесс, выполняющийся в ядре.')],-1)),s[20]||(s[20]=a(`<h2 id="операции-над-процессами-и-связанные-с-ними-понятия" tabindex="-1">Операции над процессами и связанные с ними понятия <a class="header-anchor" href="#операции-над-процессами-и-связанные-с-ними-понятия" aria-label="Permalink to &quot;Операции над процессами и связанные с ними понятия&quot;">​</a></h2><h3 id="набор-операции" tabindex="-1">Набор операций <a class="header-anchor" href="#набор-операции" aria-label="Permalink to &quot;Набор операций&quot;">​</a></h3><p>Процесс не может перейти из одного состояния в другое самостоятельно. Изменением состояния процессов занимается операционная система. Все операции можно разбить на несколько групп:</p><ul><li>создание процесса – завершение процесса;</li><li>приостановка процесса (перевод из состояния &quot;исполнение&quot; в состояние &quot;готовность&quot;) – запуск процесса (перевод из состояния &quot;готовность&quot; в состояние &quot;исполнение&quot;);</li><li>блокирование процесса (перевод из состояния &quot;исполнение&quot; в состояние &quot;ожидание&quot;) – разблокирование процесса (перевод из состояния &quot;ожидание&quot; в состояние &quot;готовность&quot;).</li></ul><p>Операции создания и завершения процесса являются одноразовыми, так как применяются к процессу не более одного раза (некоторые системные процессы не завершаются никогда). Все остальные операции, связанные с изменением состояния процессов, будь то запуск или блокировка, как правило, являются многоразовыми. Рассмотрим подробнее, как операционная система выполняет операции над процессами.</p><h3 id="process-control-block-и-контекст-процесса" tabindex="-1">Process Control Block и контекст процесса <a class="header-anchor" href="#process-control-block-и-контекст-процесса" aria-label="Permalink to &quot;Process Control Block и контекст процесса&quot;">​</a></h3><p>Каждый процесс представляется в системе некоторой структурой данных. Эта структура содержит информацию, специфичную для данного процесса:</p><ul><li>состояние, в котором находится процесс;</li><li>программный счетчик процесса или, другими словами, адрес команды, которая должна быть выполнена для него следующей;</li><li>содержимое регистров процессора;</li><li>данные, необходимые для планирования использования процессора и управления памятью (приоритет процесса, размер и расположение адресного пространства и т. д.);</li><li>учетные данные (идентификационный номер процесса, какой пользователь инициировал его работу, общее время использования процессора данным процессом и т. д.);</li><li>сведения об устройствах ввода-вывода, связанных с процессом (например, какие устройства закреплены за процессом, таблицу открытых файлов).</li></ul><p>Для нас важно лишь то, что для любого процесса вся информация, необходимая для совершения операций над ним, доступна операционной системе. Для простоты изложения будем считать, что она хранится в одной структуре данных. Мы будем называть ее <strong>PCB (Process Control Block)</strong> или блоком управления процессом, он является моделью процесса для операционной системы. Любая операция, производимая операционной системой над процессом, вызывает определенные изменения в PCB. В рамках принятой модели состояний процессов содержимое PCB между операциями остается постоянным.</p><p>Информацию, для хранения которой предназначен блок управления процессом, удобно для дальнейшего изложения разделить на две части. Содержимое всех регистров процессора (включая значение программного счетчика) будем называть <strong>регистровым контекстом процесса</strong>, а все остальное – <strong>системным контекстом процесса</strong>. Знания регистрового и системного контекстов процесса достаточно для того, чтобы управлять его работой в операционной системе, совершая над ним операции, но недостаточно, чтобы полностью охарактеризовать процесс. Операционную систему не интересует, какой код и какие данные находятся в адресном пространстве процесса. С точки зрения пользователя, наоборот, наибольший интерес представляет содержимое адресного пространства процесса, возможно, наряду с регистровым контекстом определяющее последовательность преобразования данных и полученные результаты. Код и данные, находящиеся в адресном пространстве процесса, будем называть его пользовательским контекстом. Совокупность регистрового, системного и пользовательского контекстов процесса для краткости принято называть просто контекстом процесса. В любой момент времени процесс полностью характеризуется своим контекстом.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>В Linux <strong>нельзя напрямую посмотреть структуру Process Control Block (PCB)</strong> так, как это показано в учебниках по операционным системам, потому что PCB — это <strong>внутренняя структура ядра</strong>, недоступная напрямую пользователю. Однако <strong>информация, хранящаяся в PCB</strong>, доступна косвенно через различные системные интерфейсы и файлы в специальных каталогах.</p><p>В Linux PCB реализован как структура <code>task_struct</code> в исходном коде ядра.</p><p>Как получить доступ к информации из PCB?</p><p>Хотя сам <code>task_struct</code> недоступен, ядро предоставляет <strong>виртуальную файловую систему <code>/proc</code></strong>, в которой для каждого процесса есть каталог с его PID, содержащий почти всю информацию из PCB.</p><hr><p><strong>1. Просмотр информации о процессе через <code>/proc/&lt;PID&gt;/</code></strong></p><p>Замените <code>&lt;PID&gt;</code> на реальный идентификатор процесса.</p><p><strong>Пример:</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/1234</span></span></code></pre></div><p>В этом каталоге вы найдёте файлы, соответствующие полям PCB:</p><table tabindex="0"><thead><tr><th>Файл</th><th>Что содержит</th></tr></thead><tbody><tr><td><code>/proc/&lt;PID&gt;/status</code></td><td>Основная информация: PID, PPID, UID, состояние, память и т.д.</td></tr><tr><td><code>/proc/&lt;PID&gt;/stat</code></td><td>Статистика процесса в одной строке (технический формат)</td></tr><tr><td><code>/proc/&lt;PID&gt;/cmdline</code></td><td>Команда, которой запущен процесс</td></tr><tr><td><code>/proc/&lt;PID&gt;/exe</code></td><td>Символическая ссылка на исполняемый файл</td></tr><tr><td><code>/proc/&lt;PID&gt;/cwd</code></td><td>Символическая ссылка на текущую директорию процесса</td></tr><tr><td><code>/proc/&lt;PID&gt;/fd/</code></td><td>Каталог с файловыми дескрипторами процесса</td></tr><tr><td><code>/proc/&lt;PID&gt;/mem</code></td><td>Образ памяти процесса (только через <code>gdb</code> или <code>ptrace</code>)</td></tr><tr><td><code>/proc/&lt;PID&gt;/limits</code></td><td>Лимиты ресурсов (например, max open files)</td></tr><tr><td><code>/proc/&lt;PID&gt;/sched</code></td><td>Информация о планировщике (приоритет, политика)</td></tr><tr><td><code>/proc/&lt;PID&gt;/maps</code></td><td>Карта памяти процесса (сегменты кода, стека, кучи)</td></tr></tbody></table><hr><p><strong>2. Практические примеры</strong></p><p>✅ Посмотреть основную информацию о процессе:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/1234/status</span></span></code></pre></div><p>Пример вывода:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Name:   bash</span></span>
<span class="line"><span>State:  S (sleeping)</span></span>
<span class="line"><span>Tgid:   1234</span></span>
<span class="line"><span>Pid:    1234</span></span>
<span class="line"><span>PPid:   1000</span></span>
<span class="line"><span>Uid:    1000    1000    1000    1000</span></span>
<span class="line"><span>Gid:    1000    1000    1000    1000</span></span>
<span class="line"><span>VmSize:   1234 kB</span></span>
<span class="line"><span>VmRSS:     567 kB</span></span>
<span class="line"><span>...</span></span></code></pre></div><p>✅ Узнать, в каком состоянии процесс:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;State:&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/1234/status</span></span></code></pre></div><p>✅ Посмотреть команду запуска:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/1234/cmdline</span></span></code></pre></div><p>⚠️ Иногда выводится без пробелов — можно использовать <code>tr &#39;\\0&#39; &#39; &#39;</code>:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/1234/cmdline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> tr</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;\\0&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39; &#39;</span></span></code></pre></div><p>✅ Посмотреть дерево памяти:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/1234/maps</span></span></code></pre></div><p>✅ Посмотреть открытые файлы:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -l</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/1234/fd/</span></span></code></pre></div><hr><p><strong>3. Использование команд для получения данных PCB</strong></p><p>Многие утилиты читают <code>/proc</code> и отображают данные из PCB в удобной форме:</p><table tabindex="0"><thead><tr><th>Команда</th><th>Что показывает</th><th>Источник данных</th></tr></thead><tbody><tr><td><code>ps aux</code></td><td>PID, TTY, %CPU, %MEM, COMMAND</td><td><code>/proc/&lt;PID&gt;/stat</code>, <code>/status</code></td></tr><tr><td><code>top</code></td><td>Реальное время мониторинга</td><td><code>/proc/&lt;PID&gt;/stat</code>, <code>/stat</code></td></tr><tr><td><code>pstree</code></td><td>Иерархия процессов</td><td><code>/proc/&lt;PID&gt;/stat</code>, PPID</td></tr><tr><td><code>lsof -p &lt;PID&gt;</code></td><td>Открытые файлы</td><td><code>/proc/&lt;PID&gt;/fd/</code></td></tr><tr><td><code>pmap &lt;PID&gt;</code></td><td>Карта памяти</td><td><code>/proc/&lt;PID&gt;/maps</code></td></tr><tr><td><code>cat /proc/&lt;PID&gt;/environ</code></td><td>Переменные окружения</td><td><code>/proc/&lt;PID&gt;/environ</code></td></tr></tbody></table><hr><p><strong>4. Особенности и ограничения</strong></p><ul><li><strong>Обычные пользователи</strong> могут читать только свои <code>/proc/&lt;PID&gt;/...</code> (кроме некоторых системных процессов).</li><li>Некоторые файлы (например, <code>/proc/&lt;PID&gt;/mem</code>) доступны <strong>только через <code>ptrace</code></strong> (например, с помощью <code>gdb</code>), и только если процесс не запущен в другом пространстве (например, в контейнере).</li><li>Информация обновляется динамически — <code>/proc</code> — это <strong>виртуальная файловая система</strong>.</li></ul></div><h3 id="одноразовые-операции" tabindex="-1">Одноразовые операции <a class="header-anchor" href="#одноразовые-операции" aria-label="Permalink to &quot;Одноразовые операции&quot;">​</a></h3><p>Сложный жизненный путь процесса начинается с его рождения. В очень простых системах (например, в системах, спроектированных для работы только одного конкретного приложения) все процессы могут быть порождены на этапе старта системы. Более сложные операционные системы создают процессы динамически, по мере необходимости. Инициатором рождения нового процесса после старта операционной системы может выступить либо процесс пользователя, <strong>совершивший специальный системный вызов</strong>, либо сама операционная система. Процесс, инициировавший создание нового процесса, принято называть процессом-родителем <strong>(parent process)</strong>, а вновь созданный процесс – процессом-ребенком <strong>(child process)</strong>. Процессы-дети могут в свою очередь порождать новых детей и т. д., образуя, в общем случае, внутри системы набор генеалогических деревьев процессов – <strong>генеалогический лес</strong>.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>       init (PID 1)</span></span>
<span class="line"><span>       /    \\</span></span>
<span class="line"><span>  (PID 2)  (PID 3)</span></span>
<span class="line"><span>    /  \\       \\</span></span>
<span class="line"><span>(PID 4)(PID 5) (PID 6)</span></span></code></pre></div><p>Следует отметить, что все пользовательские процессы вместе с некоторыми процессами операционной системы принадлежат одному и тому же дереву леса. Стрелочка означает отношение родитель–ребенок.</p>`,15)),i("p",null,[s[2]||(s[2]=t("В операционной системе GNU/Linux присвоение идентификационных номеров процессов начинается с номера 0, который получает процесс ")),s[3]||(s[3]=i("code",null,"kernel",-1)),s[4]||(s[4]=t(" при старте операционной системы. Этот номер впоследствии не может быть присвоен никакому другому процессу. Максимально возможное значение для номера процесса в Linux на базе 32-разрядных процессоров Intel составляет ")),i("mjx-container",h,[(p(),n("svg",d,s[0]||(s[0]=[a('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" style="stroke-width:3;"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" style="stroke-width:3;"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)" style="stroke-width:3;"></path></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" style="stroke-width:3;"></path></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" style="stroke-width:3;"></path></g></g></g>',1)]))),s[1]||(s[1]=i("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[i("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[i("msup",null,[i("mn",null,"2"),i("mrow",{"data-mjx-texclass":"ORD"},[i("mn",null,"31")])]),i("mo",null,"−"),i("mn",null,"1")])],-1))]),s[5]||(s[5]=t('. Процессы создают иерархию в виде дерева. Самым "главным" предком, то есть процессом, стоящим на вершине этого дерева, является процесс ')),s[6]||(s[6]=i("code",null,"init (PID=1)",-1)),s[7]||(s[7]=t("."))]),s[21]||(s[21]=a(`<div class="info custom-block"><p class="custom-block-title">INFO</p><p>В Linux существует несколько способов вывести <strong>дерево процессов</strong> — то есть иерархию родительских и дочерних процессов, где наглядно видно, какой процесс кем был порождён. Ниже приведены основные команды для отображения дерева процессов, от простых к более продвинутым.</p><hr><p><strong><code>pstree</code> — отображение процессов в виде дерева</strong></p><p>Самый простой и наглядный способ — команда <code>pstree</code>.</p><p>Выводит дерево всех процессов в виде иерархии, начиная с <code>init</code> или <code>systemd</code>.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pstree</span></span></code></pre></div><p>Показывает <strong>PID</strong> каждого процесса в скобках:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pstree</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span></span></code></pre></div><p>Вывод:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>systemd(1)─┬─sshd(500)───sshd(1234)───bash(1235)───pstree(1236)</span></span>
<span class="line"><span>           ├─cron(400)</span></span>
<span class="line"><span>           └─apache2(600)───apache2(601)</span></span></code></pre></div><p>Отображает <strong>имя пользователя</strong>, запустившего процесс.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pstree</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -u</span></span></code></pre></div><p>Показывает дерево процессов только указанного пользователя:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pstree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">имя_пользовател</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">я</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>Показывает <strong>путь от корня до указанного процесса</strong> (включая всех родителей):</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pstree</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">PI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>Вывод:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>systemd(1)───sshd(500)───sshd(1234)───bash(1235)</span></span></code></pre></div><hr><p><strong><code>ps</code> — команда для детального просмотра процессов</strong></p><p>Команда <code>ps</code> может выводить процессы в древовидном формате с помощью опций.</p><p>📌 Примеры:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> aux</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --forest</span></span></code></pre></div><p>Выводит все процессы (<code>a</code> — по всем пользователям, <code>u</code> — в формате пользователя, <code>x</code> — включая процессы без терминала) с визуальным отображением иерархии («лесенкой»).</p><p>Пример вывода:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span></span>
<span class="line"><span>root         1  0.0  0.1 123456  7890 ?        Ss   10:00   0:01 /sbin/init</span></span>
<span class="line"><span>root         2  0.0  0.0      0     0 ?        S    10:00   0:00 [kthreadd]</span></span>
<span class="line"><span>root         3  0.0  0.0      0     0 ?        S    10:00   0:00  \\_ [ksoftirqd/0]</span></span>
<span class="line"><span>root       500  0.1  0.2 234567 12345 ?        Ss   10:00   0:05  \\_ /usr/sbin/sshd</span></span>
<span class="line"><span>den       1234  0.0  0.1 111111  9876 ?        Ss   10:05   0:00      \\_ sshd: den@pts/0</span></span>
<span class="line"><span>den       1235  0.1  0.3 222222 20000 pts/0    Ss   10:05   0:01          \\_ -bash</span></span>
<span class="line"><span>den       1236  0.0  0.0 100000  3000 pts/0    R+   10:06   0:00              \\_ ps aux --forest</span></span></code></pre></div><p>Флаг <code>--forest</code> рисует графические линии, показывающие родство процессов.</p></div><p>При рождении процесса система заводит новый <strong>PCB</strong> с состоянием процесса &quot;рождение&quot; и начинает его заполнять, получает собственный уникальный идентификационный номер.</p><p>Для хранения идентификационного номера процесса в операционной системе отводится ограниченное количество битов, для соблюдения уникальности номеров количество одновременно присутствующих в ней процессов должно быть ограничено. После завершения какого-либо процесса его освободившийся идентификационный номер может быть повторно использован для другого процесса.</p><p>Обычно для выполнения своих функций процесс-ребенок требует определенных ресурсов: памяти, файлов, устройств ввода-вывода и т. д. Способы: Новый процесс может получить в свое распоряжение некоторую часть родительских ресурсов, или может получить свои ресурсы непосредственно от операционной системы. Информация о выделенных ресурсах заносится в PCB.</p><p>После наделения процесса-ребенка ресурсами необходимо занести в его адресное пространство программный код, значения данных, установить программный счетчик.</p><p>В первом случае для запуска новой программы необходимо сначала создать копию процесса-родителя, а затем процесс-ребенок должен заменить свой пользовательский контекст с помощью специального системного вызова. Во втором случае процесс-ребенок загружается новой программой из какого-либо файла. Операционная система Unix разрешает порождение процесса только первым способом;</p><p>Порождение нового процесса как дубликата процесса-родителя приводит к возможности существования программ (т. е. исполняемых файлов), для работы которых организуется более одного процесса. Возможность замены пользовательского контекста процесса по ходу его работы (т. е. загрузки для исполнения новой программы) приводит к тому, что в рамках одного и того же процесса может последовательно выполняться несколько различных программ.</p><p>После того как процесс наделен содержанием, в PCB дописывается оставшаяся информация, и состояние нового процесса изменяется на &quot;готовность&quot;.</p><p>Процесс-родитель может продолжать свое выполнение одновременно с выполнением процесса-ребенка, а может ожидать завершения работы некоторых или всех своих &quot;детей&quot;.</p><p>После завершения работы процесса, освобождает все ассоциированные с ним ресурсы, делая соответствующие записи в PCB. При этом сам PCB не уничтожается, а остается в системе еще некоторое время. Это связано с тем, что процесс-родитель после завершения процесса-ребенка может запросить операционную систему о причине &quot;смерти&quot; порожденного им процесса и/или статистическую информацию о его работе. Подобная информация сохраняется в PCB отработавшего процесса до запроса процесса-родителя или до конца его деятельности, после чего все следы завершившегося процесса окончательно исчезают из системы. В операционной системе Unix процессы, находящиеся в состоянии &quot;закончил исполнение&quot;, принято называть <strong>процессами-зомби</strong>.</p><p>Следует заметить, что в ряде операционных систем гибель процесса-родителя приводит к завершению работы всех его &quot;детей&quot;. В других операционных системах процессы-дети продолжают свое существование и после окончания работы процесса-родителя. При этом возникает необходимость изменения информации в PCB процессов-детей о породившем их процессе для того, чтобы генеалогический лес процессов оставался целостным.</p><p>Как правило, &quot;осиротевшие&quot; процессы &quot;усыновляются&quot; одним из системных процессов, который порождается при старте операционной системы и функционирует все время, пока она работает.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p><strong>Практическая демонстрация: наблюдение за состояниями процессов с помощью <code>top</code></strong></p><p>Для изучения состояний процессов в операционной системе Linux мы будем использовать утилиту <code>top</code> — мощный инструмент мониторинга, позволяющий в реальном времени наблюдать за работой процессов, загрузкой процессора, использованием памяти и многим другим.</p><p>Рассмотрим типичный вывод программы <code>top</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>15:03:11  up 58 min,  4 users,  load average: 0,02, 0,01, 0,00</span></span>
<span class="line"><span>52 processes: 51 sleeping, 1 running, 0 zombie, 0 stopped</span></span>
<span class="line"><span>CPU states:  0,8% user,  0,6% system,  0,0% nice,  0,0% iowait, 98,3% idle</span></span>
<span class="line"><span>Mem:   127560k av,  124696k used,    2864k free,       0k shrd,     660k buff</span></span>
<span class="line"><span>        13460k active,              17580k inactive</span></span>
<span class="line"><span>Swap:  152576k av,    8952k used,  143624k free                   28892k cached</span></span>
<span class="line"><span></span></span>
<span class="line"><span> PID USER     PRI  NI  SIZE  RSS SHARE STAT %CPU %MEM   TIME COMMAND</span></span>
<span class="line"><span> 3097 den       15   0  1128 1128   832 R     2,8  0,8   0:00 top</span></span>
<span class="line"><span>    1 root       8   0   120   84    60 S     0,0  0,0   0:04 init</span></span>
<span class="line"><span>    2 root      12   0     0    0     0 SW    0,0  0,0   0:00 keventd</span></span>
<span class="line"><span>    3 root      19  19     0    0     0 SWN   0,0  0,0   0:00 ksoftirqd_CPU0</span></span>
<span class="line"><span>...</span></span></code></pre></div><p><strong>1. Общая информация (верхние строки)</strong></p><ul><li><strong>Первая строка</strong>: <ul><li><code>15:03:11</code> — текущее системное время.</li><li><code>up 58 min</code> — время, в течение которого система работает без перезагрузки.</li><li><code>4 users</code> — количество пользователей, вошедших в систему.</li><li><code>load average: 0,02, 0,01, 0,00</code> — средняя нагрузка на систему за последние 1, 5 и 15 минут.</li></ul></li></ul><p><strong>Примечание</strong>: <em>Средняя нагрузка (load average)</em> — это среднее количество процессов, находящихся в состоянии <strong>выполнения (R)</strong> или <strong>ожидания ресурсов (D)</strong>. Значение меньше 1 на одноядерной системе говорит о низкой нагрузке.</p><ul><li><p><strong>Вторая строка</strong>:</p><ul><li>Общее количество процессов: 52.</li><li><code>51 sleeping</code> — ожидают событий (например, ввода/вывода).</li><li><code>1 running</code> — активно выполняется (или готов к выполнению).</li><li><code>0 zombie, 0 stopped</code> — нет &quot;зомби&quot; и остановленных процессов.</li></ul></li><li><p><strong>Следующие строки</strong> содержат информацию о загрузке CPU и использовании памяти (RAM и swap). Эта информация полезна для диагностики, но сейчас мы сосредоточимся на <strong>состояниях процессов</strong>.</p></li></ul><hr><p><strong>2. Таблица процессов: ключевые колонки</strong></p><p>В таблице <code>top</code> отображаются важные атрибуты каждого процесса. Нас в первую очередь интересуют:</p><ul><li><strong>PID</strong> — уникальный идентификатор процесса.</li><li><strong>USER</strong> — пользователь, запустивший процесс.</li><li><strong>STAT</strong> — состояние процесса.</li><li><strong>COMMAND</strong> — команда, запустившая процесс.</li></ul><p><strong>Коды состояний (STAT):</strong></p><table tabindex="0"><thead><tr><th>Символ</th><th>Значение</th></tr></thead><tbody><tr><td><code>R</code></td><td>Running — процесс выполняется или готов к выполнению</td></tr><tr><td><code>S</code></td><td>Sleeping — процесс ожидает события (например, ввода)</td></tr><tr><td><code>D</code></td><td>Uninterruptible sleep — ожидание ввода/вывода (нельзя прервать)</td></tr><tr><td><code>T</code></td><td>Stopped — процесс приостановлен (например, сигналом SIGSTOP)</td></tr><tr><td><code>Z</code></td><td>Zombie — процесс завершился, но остался в таблице процессов</td></tr><tr><td><code>&lt;</code></td><td>Процесс с повышенным приоритетом (отрицательное значение <code>nice</code>)</td></tr><tr><td><code>N</code></td><td>Процесс с пониженным приоритетом (положительное значение <code>nice</code>)</td></tr></tbody></table><hr><p><strong>3. Эксперимент 1: процесс в состоянии R (Running)</strong></p><p>Создадим простой bash-скрипт <code>process</code>:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#!/bin/bash</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ $x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-lt</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">done</span></span></code></pre></div><p>Сделаем его исполняемым и запустим:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chmod</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> +x</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> process</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./process</span></span></code></pre></div><p>В другом терминале выполним:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> process</span></span></code></pre></div><p>Увидим PID процесса (например, 4035). Затем отслеживаем его через <code>top</code>:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">top</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4035</span></span></code></pre></div><p><strong>Наблюдение</strong>: в колонке <code>STAT</code> будет стоять <code>R</code> — процесс находится в состоянии выполнения, так как он постоянно выполняет цикл.</p><hr><p><strong>4. Эксперимент 2: переход в состояние T (Stopped)</strong></p><p>Вернёмся к терминалу, где работает <code>./process</code>, и нажмём <strong>Ctrl+Z</strong>. Процесс будет приостановлен.</p><p>Теперь снова запустим <code>top -p 4035</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PID   STAT   COMMAND</span></span>
<span class="line"><span>4035  T      process</span></span></code></pre></div><p><strong>Вывод</strong>: процесс перешёл в состояние <code>T</code> — он остановлен и не потребляет CPU.</p><hr><p><strong>5. Эксперимент 3: процесс в состоянии S (Sleeping)</strong></p><p>Остановим процесс (если он ещё запущен) командой <code>kill 4035</code>, затем модифицируем скрипт:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#!/bin/bash</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sleep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 10m</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # спим 10 минут</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ $x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-lt</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">done</span></span></code></pre></div><p>Запустим его снова и через <code>ps</code> найдём PID, затем — <code>top -p &lt;PID&gt;</code>.</p><p><strong>Наблюдение</strong>: в колонке <code>STAT</code> будет <code>S</code> — процесс &quot;спит&quot;, ожидая окончания команды <code>sleep</code>.</p><hr><p><strong>6. Эксперимент 4: создание процесса-зомби (Zombie)</strong></p><p>Процесс-зомби — это завершившийся дочерний процесс, чья запись осталась в таблице процессов, потому что родитель ещё не считал его статус завершения.</p><p>Создадим программу на C:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;unistd.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;signal.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdlib.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;sys/wait.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pid;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> status, died;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   pid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pid) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   case</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;can&#39;t fork</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;   I&#39;m the child of PID </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getppid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;   My PID is </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getpid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // завершаемся сразу</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;I&#39;m the parent.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;   My PID is </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getpid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ждём 10 секунд</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       died </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">status</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // только теперь забираем статус</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Компилируем:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gcc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> zombie</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> zombie.c</span></span></code></pre></div><p>Запускаем:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./zombie</span></span></code></pre></div><p>Программа выведет PID дочернего процесса (например, 1148). Быстро переключаемся на другой терминал и выполняем:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">top</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1148</span></span></code></pre></div><p><strong>Наблюдение</strong>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PID   STAT   COMMAND</span></span>
<span class="line"><span>1148  Z      zombie &lt;defunct&gt;</span></span></code></pre></div><p>Процесс стал зомби (<code>Z</code>) — он уже завершился, но запись о нём осталась, пока родитель не вызвал <code>wait()</code>.</p><blockquote><p><strong>Важно</strong>: зомби не потребляют память, но занимают слот в таблице процессов. Если их слишком много — это может привести к исчерпанию PID.</p></blockquote></div><h3 id="сигналы-в-unix-системах-управление-процессами-на-уровне-ос" tabindex="-1"><strong>Сигналы в UNIX-системах: управление процессами на уровне ОС</strong> <a class="header-anchor" href="#сигналы-в-unix-системах-управление-процессами-на-уровне-ос" aria-label="Permalink to &quot;**Сигналы в UNIX-системах: управление процессами на уровне ОС**&quot;">​</a></h3><p>Каждый процесс в UNIX-подобных операционных системах может получать и реагировать на <strong>сигналы</strong> — специальные программные прерывания, используемые для уведомления процесса о различных событиях.</p><h4 id="что-такое-сигнал" tabindex="-1"><strong>Что такое сигнал?</strong> <a class="header-anchor" href="#что-такое-сигнал" aria-label="Permalink to &quot;**Что такое сигнал?**&quot;">​</a></h4><p>Сигнал — это асинхронное уведомление, отправляемое процессу операционной системой или другим процессом. Сигналы используются для:</p><ul><li>Завершения процесса (например, при нажатии Ctrl+C).</li><li>Приостановки или возобновления выполнения.</li><li>Обработки ошибок (например, сегментация памяти).</li><li>Взаимодействия между процессами.</li></ul><p>Всего существует <strong>64 сигнала</strong>, пронумерованных от 1 до 64:</p><ul><li><strong>1–32</strong> — стандартные сигналы (например, <code>SIGTERM</code>, <code>SIGKILL</code>, <code>SIGSTOP</code>).</li><li><strong>33–64</strong> — сигналы реального времени (real-time signals), которые используются для специализированных задач и не рассматриваются в рамках базового курса.</li></ul><p>Сигналы можно вызывать по <strong>номеру</strong> (например, <code>9</code>) или по <strong>имени</strong> (например, <code>SIGKILL</code>).</p><p>Чтобы увидеть список всех доступных сигналов, выполните:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">kill</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -l</span></span></code></pre></div><p>Вывод будет примерно таким:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1) SIGHUP   2) SIGINT   3) SIGQUIT   4) SIGILL   5) SIGTRAP</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>9) SIGKILL 15) SIGTERM 19) SIGSTOP</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p><strong>Как процессы реагируют на сигналы?</strong></p><p>Процесс может:</p><ul><li><strong>Игнорировать</strong> сигнал (кроме двух исключений).</li><li><strong>Выполнить действие по умолчанию</strong> (например, завершиться).</li><li><strong>Обработать сигнал</strong> с помощью пользовательской функции (в программах на C и других языках).</li></ul><p><strong>Исключения: два неуловимых сигнала</strong></p><p>Существуют <strong>два сигнала, которые нельзя игнорировать и нельзя перехватить</strong>:</p><table tabindex="0"><thead><tr><th>Сигнал</th><th>Номер</th><th>Действие</th></tr></thead><tbody><tr><td><code>SIGKILL</code></td><td>9</td><td>Принудительное завершение процесса. Немедленно останавливает процесс без возможности завершить работу корректно.</td></tr><tr><td><code>SIGSTOP</code></td><td>19</td><td>Принудительная остановка процесса. Процесс нельзя продолжить, пока не получит <code>SIGCONT</code>.</td></tr></tbody></table><p>⚠️ Эти сигналы всегда действуют независимо от кода процесса. Их используют, когда процесс не отвечает на другие команды.</p><hr><p><strong>Отправка сигналов: команды <code>kill</code> и <code>killall</code></strong></p><p>Для отправки сигналов процессам используются две основные команды:</p><table tabindex="0"><thead><tr><th>Команда</th><th>Назначение</th></tr></thead><tbody><tr><td><code>kill</code></td><td>Отправляет сигнал процессу по его <strong>PID</strong> (идентификатору).</td></tr><tr><td><code>killall</code></td><td>Отправляет сигнал <strong>всем процессам</strong> с указанным <strong>именем</strong>.</td></tr></tbody></table><p><strong>Синтаксис:</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">kill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [опция] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PID</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">killall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [опция] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">имя_процесса</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p><strong>Примеры:</strong></p><ol><li><strong>Завершить процесс с PID 785</strong> (по умолчанию отправляется <code>SIGTERM</code>, номер 15):</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">kill</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 785</span></span></code></pre></div><ol start="2"><li><strong>Принудительно убить процесс</strong> (сигнал <code>SIGKILL</code>):</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">kill</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -9</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 785</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># или</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">kill</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -KILL</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 785</span></span></code></pre></div><ol start="3"><li><strong>Остановить процесс</strong> (без завершения):</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">kill</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -19</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 785</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># или</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">kill</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -STOP</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 785</span></span></code></pre></div><ol start="4"><li><strong>Возобновить остановленный процесс</strong>:</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">kill</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -18</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 785</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># или</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">kill</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -CONT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 785</span></span></code></pre></div><ol start="5"><li><strong>Завершить все процессы с именем <code>firefox</code></strong>:</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">killall</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> firefox</span></span></code></pre></div><ol start="6"><li><strong>Принудительно завершить все процессы <code>chrome</code></strong>:</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">killall</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -9</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> chrome</span></span></code></pre></div><p>🔐 <strong>Важно</strong>: обычный пользователь может отправлять сигналы <strong>только своим процессам</strong>. Для управления чужими процессами требуется права суперпользователя (<code>root</code>).</p><hr><p><strong>Интерактивное управление процессами: <code>top</code> как инструмент администрирования</strong></p><p>Утилита <code>top</code> — не только средство наблюдения, но и <strong>интерактивный инструмент управления процессами</strong>. Она объединяет функции <code>ps</code> (просмотр) и <code>kill</code> (управление), позволяя в реальном времени:</p><ul><li>Отслеживать нагрузку на CPU и память.</li><li>Управлять процессами.</li><li>Изменять приоритеты.</li></ul><p>После запуска <code>top</code> вы можете управлять им с помощью клавиатуры. Вот основные команды:</p><table tabindex="0"><thead><tr><th>Клавиша</th><th>Действие</th></tr></thead><tbody><tr><td><strong><code>k</code></strong></td><td>Отправить сигнал процессу. <code>top</code> запросит PID и номер/имя сигнала (по умолчанию <code>SIGTERM</code>).</td></tr><tr><td><strong><code>r</code></strong></td><td>Изменить приоритет (nice value) процесса. <code>top</code> запросит PID и новое значение <code>nice</code>.</td></tr><tr><td><strong><code>P</code></strong></td><td>Сортировка по загрузке CPU (<code>%CPU</code>) — режим по умолчанию.</td></tr><tr><td><strong><code>M</code></strong></td><td>Сортировка по использованию памяти (<code>%MEM</code>).</td></tr><tr><td><strong><code>u</code></strong></td><td>Показать процессы только указанного пользователя.</td></tr><tr><td><strong><code>i</code></strong></td><td>Переключение: показывать все процессы или только активные (<code>R</code> — running).</td></tr><tr><td><strong><code>h</code></strong></td><td>Показать справку по командам.</td></tr><tr><td><strong><code>q</code></strong></td><td>Выйти из <code>top</code>.</td></tr></tbody></table><p><strong>Практический пример: завершение зависшего процесса через <code>top</code></strong></p><ol><li>Запустите <code>top</code>.</li><li>Найдите PID проблемного процесса (например, <code>firefox</code>, который &quot;завис&quot;).</li><li>Нажмите <strong><code>k</code></strong>.</li><li>Введите PID процесса.</li><li>Введите номер сигнала: <code>9</code> (для <code>SIGKILL</code>).</li><li>Процесс будет немедленно завершён.</li></ol><p>💡 Это удобно, когда вы не хотите запоминать PID — вы видите его прямо в интерфейсе.</p></div><p><strong>Многоразовые операции</strong></p><p>Одноразовые операции приводят к изменению количества процессов, находящихся под управлением операционной системы, и всегда связаны с выделением или освобождением определенных ресурсов.</p><p>Многоразовые операции, напротив, не приводят к изменению количества процессов в операционной системе и не обязаны быть связанными с выделением или освобождением ресурсов.</p><p><strong>Запуск процесса.</strong> Из числа процессов, находящихся в состоянии &quot;готовность&quot;, операционная система выбирает один процесс для последующего исполнения.</p><p>Для избранного процесса операционная система обеспечивает наличие в оперативной памяти информации, необходимой для его дальнейшего выполнения. Далее состояние процесса изменяется на &quot;исполнение&quot;, восстанавливаются значения регистров для данного процесса и управление передается команде, на которую указывает счетчик команд процесса. Все данные, необходимые для восстановления контекста, извлекаются из PCB процесса, над которым совершается операция.</p><p><strong>Приостановка процесса</strong>. Работа процесса приостанавливается в результате какого-либо прерывания. Процессор автоматически сохраняет счетчик команд и, возможно, один или несколько регистров в стеке исполняемого процесса, а затем передает управление по специальному адресу обработки данного прерывания. На этом деятельность hardware по обработке прерывания завершается. По указанному адресу обычно располагается одна из частей операционной системы. Она сохраняет динамическую часть системного и регистрового контекстов процесса в его PCB, переводит процесс в состояние &quot;готовность&quot; и приступает к обработке прерывания, то есть к выполнению определенных действий, связанных с возникшим прерыванием.</p><p><strong>Блокирование процесса</strong>. Процесс блокируется, когда он не может продолжать работу, не дождавшись возникновения какого-либо события в вычислительной системе. Для этого он обращается к операционной системе с помощью определенного системного вызова. Операционная система обрабатывает системный вызов (инициализирует операцию ввода-вывода, добавляет процесс в очередь процессов, дожидающихся освобождения устройства или возникновения события, и т. д.) и, при необходимости сохранив нужную часть контекста процесса в его PCB, переводит процесс из состояния &quot;исполнение&quot; в состояние &quot;ожидание&quot;.</p><p><strong>Разблокирование процесса</strong>. После возникновения в системе какого-либо события операционной системе нужно точно определить, какое именно событие произошло. Затем операционная система проверяет, находился ли некоторый процесс в состоянии &quot;ожидание&quot; для данного события, и если находился, переводит его в состояние &quot;готовность&quot;, выполняя необходимые действия, связанные с наступлением события (инициализация операции ввода-вывода для очередного ожидающего процесса и т. п.).</p><p><strong>Переключение контекста</strong></p><p>Деятельность мультипрограммной операционной системы состоит из цепочек операций, выполняемых над различными процессами, и сопровождается переключением процессора с одного процесса на другой.</p><p>Давайте для примера упрощенно рассмотрим, как в реальности может протекать операция разблокирования процесса, ожидающего ввода-вывода. При исполнении процессором некоторого процесса (на рисунке – процесс 1) возникает прерывание от устройства ввода-вывода, сигнализирующее об окончании операций на устройстве. Над выполняющимся процессом производится операция приостановки. Далее операционная система разблокирует процесс, инициировавший запрос на ввод-вывод (на рисунке – процесс 2) и осуществляет запуск приостановленного или нового процесса, выбранного при выполнении планирования (на рисунке был выбран разблокированный процесс). Как мы видим, в результате обработки информации об окончании операции ввода-вывода возможна смена процесса, находящегося в состоянии &quot;исполнение&quot;.</p>`,37)),s[22]||(s[22]=i("iframe",{src:"https://viewer.diagrams.net/?highlight=0000ff&layers=1&nav=1&title=Diagram#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D16wwivex5uqbn5z3tFI2dFyDnMa358Emc%26export%3Ddownload",width:"100%",height:"600px",frameborder:"0",allowfullscreen:""},null,-1)),s[23]||(s[23]=a(`<p>Для корректного переключения процессора с одного процесса на другой необходимо сохранить контекст исполнявшегося процесса и восстановить контекст процесса, на который будет переключен процессор.</p><p>Такая процедура сохранения/восстановления работоспособности процессов называется <strong>переключением контекста</strong>. Время, затраченное на переключение контекста, не используется вычислительной системой для совершения полезной работы и представляет собой накладные расходы, снижающие производительность системы. Оно меняется от машины к машине и обычно колеблется в диапазоне от 1 до 1000 микросекунд. Существенно сократить накладные расходы в современных операционных системах позволяет расширенная модель процессов, включающая в себя понятие <strong>threads</strong> (<strong>нити исполнения</strong> или просто <strong>нити</strong>).</p><h2 id="взаимодеиствующие-процессы" tabindex="-1">Взаимодействующие процессы <a class="header-anchor" href="#взаимодеиствующие-процессы" aria-label="Permalink to &quot;Взаимодействующие процессы&quot;">​</a></h2><p>Для достижения поставленной цели различные процессы (возможно, даже принадлежащие разным пользователям) могут исполняться псевдопараллельно на одной вычислительной системе или параллельно на разных вычислительных системах, взаимодействуя между собой.</p><p>Процессы не могут взаимодействовать, не общаясь, то есть не обмениваясь информацией. &quot;Общение&quot; процессов обычно приводит к изменению их поведения в зависимости от полученной информации. Если деятельность процессов остается неизменной при любой принятой ими информации, то это означает, что они на самом деле в &quot;общении&quot; не нуждаются. Процессы, которые влияют на поведение друг друга путем обмена информацией, принято называть кооперативными или взаимодействующими процессами, в отличие от независимых процессов, не оказывающих друг на друга никакого воздействия.</p><p>Различные процессы в вычислительной системе изначально представляют собой обособленные сущности. Работа одного процесса не должна приводить к нарушению работы другого процесса. Для этого, в частности, разделены их адресные пространства и системные ресурсы, и для обеспечения корректного взаимодействия процессов требуются специальные средства и действия операционной системы. Нельзя просто поместить значение, вычисленное в одном процессе, в область памяти, соответствующую переменной в другом процессе, не предприняв каких-либо дополнительных усилий. Давайте рассмотрим основные аспекты организации совместной работы процессов.</p><h3 id="категории-средств-обмена-информациеи" tabindex="-1">Категории средств обмена информацией <a class="header-anchor" href="#категории-средств-обмена-информациеи" aria-label="Permalink to &quot;Категории средств обмена информацией&quot;">​</a></h3><p>Процессы могут взаимодействовать друг с другом, только обмениваясь информацией. По объему передаваемой информации и степени возможного воздействия на поведение другого процесса все средства такого обмена можно разделить на три категории.</p><ul><li><p><strong>Сигнальные</strong> Передается минимальное количество информации – один бит, &quot;да&quot; или &quot;нет&quot;. Используются, как правило, для извещения процесса о наступлении какого-либо события. Степень воздействия на поведение процесса, получившего информацию, минимальна. Все зависит от того, знает ли он, что означает полученный сигнал, надо ли на него реагировать и каким образом. Неправильная реакция на сигнал или его игнорирование могут привести к трагическим последстви- ям. Вспомним профессора Плейшнера из кинофильма &quot;Семнадцать мгновений весны&quot;. Сигнал тревоги – цветочный горшок на подоконнике – был ему передан, но профессор проигнорировал его. И к чему это привело?</p></li><li><p><strong>Канальные</strong> &quot;Общение&quot; процессов происходит через линии связи, предоставленные операционной системой, и напоминает общение людей по телефону, с помощью записок, писем или объявлений. Объем передаваемой информации в единицу времени ограничен пропускной способностью линий связи. С увеличением количества информации возрастает и возможность влияния на поведение другого процесса.</p></li><li><p><strong>Разделяемая память</strong> Два или более процессов могут совместно использовать некоторую область адресного пространства. Созданием разделяемой памяти занимается операционная система (если, конечно, ее об этом попросят). &quot;Общение&quot; процессов напоминает совместное проживание студентов в одной комнате общежития. Возможность обмена информацией максимальна, как, впрочем, и влияние на поведение другого процесса, но требует повышенной осторожности (если вы переложили на другое место вещи вашего соседа по комнате, а часть из них еще и выбросили). Использование разделяемой памяти для передачи/получения информации осуществляется с помощью средств обычных языков программирования, в то время как сигнальным и канальным средствам коммуникации для этого необходимы специальные системные вызовы. Разделяемая память представляет собой наиболее быстрый способ взаимодействия процессов в одной вычислительной системе.</p></li></ul><h3 id="логическая-организация-механизма-передачи-информации" tabindex="-1">Логическая организация механизма передачи информации <a class="header-anchor" href="#логическая-организация-механизма-передачи-информации" aria-label="Permalink to &quot;Логическая организация механизма передачи информации&quot;">​</a></h3><p>При рассмотрении любого из средств коммуникации нас будет интересовать не их физическая реализация (общая шина данных, прерывания, аппаратно разделяемая память и т. д.), а логическая, определяющая в конечном счете механизм их использования. Некоторые важные аспекты логической реализации являются общими для всех категорий средств связи, некоторые относятся к отдельным категориям. Давайте кратко охарактеризуем основные вопросы, требующие разъяснения при изучении того или иного способа обмена информацией.</p><h4 id="как-устанавливается-связь" tabindex="-1">Как устанавливается связь? <a class="header-anchor" href="#как-устанавливается-связь" aria-label="Permalink to &quot;Как устанавливается связь?&quot;">​</a></h4><p>Могу ли я использовать средство связи непосредственно для обмена информацией сразу после создания процесса или первоначально необходимо предпринять определенные действия для инициализации обмена? Например, для использования общей памяти различными процессами потребуется специальное обращение к операционной системе, которая выделит необходимую область адресного пространства. Но для передачи сигнала от одного процесса к другому никакая инициализация не нужна. В то же время передача информации по линияи связи может потребовать первоначального резервирования такой линии для процессов, желающих обменяться информацией.</p><p>К этому же вопросу тесно примыкает вопрос о способе адресации при использовании средства связи. Если я передаю некоторую информацию, я должен указать, куда я ее передаю. Если я желаю получить некоторую информацию, то мне нужно знать, откуда я могу ее получить.</p><p>Различают два способа адресации: прямую и непрямую. В случае прямой адресации взаимодействующие процессы непосредственно общаются друг с другом, при каждой операции обмена данными явно указывая имя или номер процесса, которому информация предназначена или от которого она должна быть получена. Если и процесс, от которого данные исходят, и процесс, принимающий данные, указывают имена своих партнеров по взаимодействию, то такая схема адресации называется симметричной прямой адресацией. Ни один другой процесс не может вмешаться в процедуру симметричного прямого общения двух процессов, перехватить посланные или подменить ожидаемые данные. Если только один из взаимодействующих процессов, например передающий, указывает имя своего партнера по кооперации, а второй процесс в качестве возможного партнера рассматривает любой процесс в системе, например ожидает получения информации от произвольного источника, то такая схема адресации называется асимметричной прямой адресацией.</p><p>При непрямой адресации данные помещаются передающим процессом в некоторый промежуточный объект для хранения данных, имеющий свой адрес, откуда они могут быть затем изъяты каким-либо другим процессом. Примером такого объекта может служить обычная доска объявлений или рекламная газета. При этом передающий процесс не знает, как именно идентифицируется процесс, который получит информацию, а принимающий процесс не имеет представления об идентификаторе процесса, от которого он должен ее получить.</p><p>При использовании прямой адресации связь между процессами в классической операционной системе устанавливается автоматически, без дополнительных инициализирующих действий. Единственное, что нужно для использования средства связи, -- это знать, как идентифицируются процессы, участвующие в обмене данными.</p><p>При использовании непрямой адресации инициализация средства связи может и не требоваться. Информация, которой должен обладать процесс для взаимодействия с другими процессами, - это некий идентификатор промежуточного объекта для хранения данных, если он, конечно, не является единственным и неповторимым в вычислительной системе для всех процессов.</p><h4 id="особенности-передачи-информации-с-помощью-линии-связи-ipc" tabindex="-1">Особенности передачи информации с помощью линий связи (IPC) <a class="header-anchor" href="#особенности-передачи-информации-с-помощью-линии-связи-ipc" aria-label="Permalink to &quot;Особенности передачи информации с помощью линий связи (IPC)&quot;">​</a></h4><p><strong>IPC (Inter-Process Communication)</strong> — Межпроцессное взаимодействие</p><p>Как уже говорилось выше, передача информации между процессами посредством линий связи является достаточно безопасной по сравнению с использованием разделяемой памяти и более информативной по сравнению с сигнальными средствами коммуникации. Кроме того, разделяемая память не может быть использована для связи процессов, функционирующих на различных вычислительных системах. Возможно, именно поэтому каналы связи из средств коммуникации процессов получили наибольшее распространение. Коснемся некоторых вопросов, связанных с логической реализацией канальных средств коммуникации.</p><h5 id="буферизация" tabindex="-1">Буферизация <a class="header-anchor" href="#буферизация" aria-label="Permalink to &quot;Буферизация&quot;">​</a></h5><p>Может ли линия связи сохранять информацию, переданную одним процессом, до ее получения другим процессом или помещения в промежуточный объект? Каков объем этой информации? Иными словами, речь идет о том, обладает ли канал связи буфером и каков объем этого буфера. Здесь можно выделить три принципиальных варианта.</p><ol><li><strong>Буфер нулевой емкости.</strong> или отсутствует. Никакая информация не может сохраняться на линии связи. В этом случае процесс, посылающий информацию, должен ожидать, пока процесс, принимающий информацию, не соблаговолит ее получить, прежде чем заниматься своими дальнейшими делами (в реальности этот случай никогда не реализуется).</li><li><strong>Буфер ограниченной емкости.</strong> Размер буфера равен n, то есть линия связи не может хранить до момента получения более чем n единиц информации. Если в момент передачи данных в буфере хватает места, то передающий процесс не должен ничего ожидать. Информация просто копируется в буфер. Если же в момент передачи данных буфер заполнен или места недостаточно, то необходимо задержать работу процесса отправителя до появления в буфере свободного пространства.</li><li><strong>Буфер неограниченной емкости.</strong> Теоретически это возможно, но практически вряд ли реализуемо. Процесс, посылающий информацию, никогда не ждет окончания ее передачи и приема другим процессом.</li></ol><p>При использовании канального средства связи с непрямой адресацией под емкостью буфера обычно понимается количество информации, которое может быть помещено в промежуточный объект для хранения данных.</p><h5 id="поток-ввода-вывода-и-сообщения" tabindex="-1">Поток ввода/вывода и сообщения <a class="header-anchor" href="#поток-ввода-вывода-и-сообщения" aria-label="Permalink to &quot;Поток ввода/вывода и сообщения&quot;">​</a></h5><p>Существует две модели передачи данных по каналам связи - поток ввода-вывода и сообщения. При передаче данных с помощью потоковой модели операции передачи/приема информации вообще не интересуются содержимым данных. Процесс, прочитавший 100 байт из линии связи, не знает и не может знать, были ли они переданы одновременно, т. е. одним куском или порциями по 20 байт, пришли они от одного процесса или от разных. Данные представляют собой простой поток байтов, без какой-либо их интерпретации со стороны системы. Примерами потоковых каналов связи могут служить <strong>pipe</strong> и <strong>FIFO</strong>, описанные ниже.</p><p>Одним из наиболее простых способов передачи информации между процессами по линиям связи является передача данных через <strong>pipe</strong> (<strong>канал</strong>, <strong>трубу</strong> или, как его еще называют в литературе, <strong>конвейер</strong>). Представим себе, что у нас есть некоторая труба в вычислительной системе, в один из концов которой процессы могут &quot;сливать&quot; информацию, а из другого конца принимать полученный поток. Такой способ реализует потоковую модель ввода/вывода. Информацией о расположении трубы в операционной системе обладает только процесс, создавший ее. Этой информацией он может поделиться исключительно со своими наследниками - процессами-детьми и их потомками. Поэтому использовать pipe для связи между собой могут только родственные процессы, имеющие общего предка, создавшего данный канал связи.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>В Linux каждая программа работает с тремя стандартными потоками ввода-вывода:</p><ul><li><strong>stdin (0)</strong> — стандартный ввод (по умолчанию: клавиатура)</li><li><strong>stdout (1)</strong> — стандартный вывод (по умолчанию: терминал)</li><li><strong>stderr (2)</strong> — стандартный поток ошибок (вывод ошибок)</li></ul><p>Примеры:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Вывод команды в файл</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> files.txt</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Перенаправление ошибок в файл</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /noexist</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 2&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> error.log</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Использование pipe для передачи данных</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> aux</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> firefox</span></span></code></pre></div><ol><li><code>ps aux</code> — выводит список всех запущенных процессов.</li><li><code>|</code> — символ <strong>pipe</strong>, передаёт вывод первой команды на вход второй.</li><li><code>grep firefox</code> — фильтрует строки, содержащие слово <code>firefox</code>.</li></ol></div><p>Если разрешить процессу, создавшему трубу, сообщать о ее местонахождении в системе другим процессам, сделав вход и выход трубы каким-либо образом видимыми для всех остальных, например, зарегистрировав ее в операционной системе под определенным именем, мы получим объект, который принято называть <strong>FIFO</strong> или <strong>именованный pipe</strong>. Именованный pipe может использоваться для организации связи между любыми процессами в системе.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>🔧 Создание FIFO:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkfifo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /tmp/mypipe</span></span></code></pre></div><p><strong>1. В одном терминале — пишем:</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Привет из FIFO&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /tmp/mypipe</span></span></code></pre></div><p>(команда блокируется, пока нет получателя)</p><p><strong>2. В другом терминале — читаем:</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /tmp/mypipe</span></span></code></pre></div><p>После этого данные передаются, и <code>echo</code> завершается.</p><p>✅ Особенности:</p><ul><li>FIFO — это специальный файл (<code>ls -l /tmp/mypipe</code> покажет <code>p------</code>).</li><li>Данные передаются по принципу <strong>очереди</strong>: первым вошёл — первым вышел.</li><li>Поддерживает <strong>только одностороннюю</strong> передачу.</li><li>Используется для межпроцессного взаимодействия (IPC) в сценариях, логировании, сервисах.</li></ul><hr><p>📌 Удаление:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mypipe</span></span></code></pre></div></div><p>В модели сообщений процессы налагают на передаваемые данные некоторую структуру. Весь поток информации они разделяют на отдельные сообщения, вводя между данными, по крайней мере, границы сообщений. Примером границ сообщений являются точки между предложениями в сплошном тексте или границы абзаца. Кроме того, к передаваемой информации могут быть присоединены указания на то, кем конкретное сообщение было послано и для кого оно предназначено. Примером указания отправителя могут служить подписи под эпиграфами в книге. Все сообщения могут иметь одинаковый фиксированный размер или могут быть переменной длины.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>В Linux передача сообщений реализуется через очереди сообщений POSIX (<code>mqueue</code>), но для простоты продемонстрируем более простой вариант: <code>DBus</code> + <code>systemd</code>.</p><p>К сожалению, <strong>systemd напрямую не использует и не заменяет традиционные IPC-механизмы</strong>, такие как очереди сообщений System V или POSIX. Однако <strong>systemd активно применяет собственную модель обмена сообщениями через D-Bus</strong> — шину межпроцессного взаимодействия, которая лежит в основе современных Linux-систем.</p><p>✅ <strong>Практика: Отправка уведомления через D-Bus с помощью systemd-сервиса</strong></p><p>В этом примере мы создадим простой systemd-сервис, который при запуске отправляет <strong>уведомление на рабочий стол</strong> через <strong>D-Bus</strong> — демонстрируя, как systemd взаимодействует с другими компонентами системы по модели сообщений.</p><hr><p>🧰 Что используется:</p><ul><li><code>systemd</code> — для управления сервисом</li><li><code>D-Bus</code> — как система обмена сообщениями</li><li><code>notify-send</code> — утилита для отправки уведомлений через D-Bus</li><li>Переменная окружения <code>DBUS_SESSION_BUS_ADDRESS</code> — для доступа к пользовательской шине</li></ul><hr><p>🔧 Шаг 1: Создайте скрипт уведомления</p><p>Создайте файл:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nano</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/user/notify.sh</span></span></code></pre></div><p>Содержимое:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#!/bin/bash</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DISPLAY</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DBUS_SESSION_BUS_ADDRESS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;unix:path=/run/user/$(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">id</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -u</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)/bus&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/usr/bin/notify-send</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Системное уведомление&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Сервис ExampleNotifier запущен!&quot;</span></span></code></pre></div><p>Замените <code>user</code> на ваше имя пользователя.</p><p>Путь <code>/run/user/&lt;UID&gt;/bus</code> — стандартный путь к пользовательской D-Bus шине.</p><p>Сделайте скрипт исполняемым:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chmod</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> +x</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/user/notify.sh</span></span></code></pre></div><hr><p>🔧 Шаг 2: Создайте systemd-сервис</p><p>Создайте файл сервиса:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nano</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/systemd/system/example-notifier.service</span></span></code></pre></div><p>Содержимое:</p><div class="language-ini vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">[Unit]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Description</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=Пример сервиса с обменом сообщениями через D-Bus</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">After</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=graphical-session.target</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">[Service]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=oneshot</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=your_username</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ExecStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=/home/your_username/notify.sh</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RemainAfterExit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=yes</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">[Install]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WantedBy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=multi-user.target</span></span></code></pre></div><blockquote><p>🔹 Замените <code>your_username</code> на имя вашего пользователя.</p></blockquote><hr><p>🔧 Шаг 3: Включите и запустите сервис</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Перезагрузите конфигурацию systemd</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> systemctl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> daemon-reexec</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> systemctl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> daemon-reload</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Включить сервис (чтобы запускался при старте)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> systemctl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> enable</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> example-notifier.service</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Запустить вручную</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> systemctl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> example-notifier.service</span></span></code></pre></div><hr><p>✅ Результат</p><p>На экране пользователя появится <strong>уведомление</strong>: <strong>Системное уведомление</strong><br> Сервис ExampleNotifier запущен!</p><hr><p>💬 Что произошло (модель сообщений):</p><ol><li><strong>Сервис (systemd)</strong> — инициировал действие.</li><li><strong>Скрипт</strong> — подготовил сообщение.</li><li><strong>notify-send</strong> — отправил сообщение через <strong>D-Bus</strong> (систему обмена сообщениями).</li><li><strong>Демон уведомлений (например, <code>xfce4-notifyd</code> или <code>gnome-shell</code>)</strong> — получил сообщение и отобразил его.</li></ol><p>Это классический пример <strong>модели обмена сообщениями</strong>: отправитель не знает получателя, а шина (D-Bus) обеспечивает доставку.</p></div><p>И потоковые линии связи, и каналы сообщений всегда имеют буфер конечной длины. Когда мы будем говорить о емкости буфера для потоков данных, мы будем измерять ее в байтах. Когда мы будем говорить о емкости буфера для сообщений, мы будем измерять ее в сообщениях.</p><h5 id="другие-варианты" tabindex="-1">Другие варианты <a class="header-anchor" href="#другие-варианты" aria-label="Permalink to &quot;Другие варианты&quot;">​</a></h5><p>Сокеты, разделяемая память, семафоры и т.д. будут обсуждаться на других лекциях.</p><h4 id="надежность-средств-связи" tabindex="-1">Надежность средств связи <a class="header-anchor" href="#надежность-средств-связи" aria-label="Permalink to &quot;Надежность средств связи&quot;">​</a></h4><div class="tip custom-block"><p class="custom-block-title">Dependence</p><ul><li>Дисциплина: Основы теории информации</li><li>Дисциплина: Технологии физического уровня передачи данных</li></ul></div><p>Данный вопрос обширен. Смотри зависимости.</p><h4 id="как-завершается-связь" tabindex="-1">Как завершается связь? <a class="header-anchor" href="#как-завершается-связь" aria-label="Permalink to &quot;Как завершается связь?&quot;">​</a></h4><p>Наконец, важным вопросом при изучении средств обмена данными является вопрос прекращения обмена. Здесь нужно выделить два аспекта: требуются ли от процесса какие-либо специальные действия по прекращению использования средства коммуникации и влияет ли такое прекращение на поведение других процессов. Для способов связи, которые не подразумевали никаких инициализирующих действий, обычно ничего специального для окончания взаимодействия предпринимать не надо. Если же установление связи требовало некоторой инициализации, то, как правило, при ее завершении бывает необходимо выполнить ряд операций, например сообщить операционной системе об освобождении выделенного связного ресурса.</p><p>Если кооперативные процессы прекращают взаимодействие согласованно, то такое прекращение не влияет на их дальнейшее поведение. Иная картина наблюдается при несогласованном окончании связи одним из процессов. Если какой-либо из взаимодействующих процессов, не завершивших общение, находится в этот момент в состоянии ожидания получения данных либо попадает в такое состояние позже, то операционная система обязана предпринять некоторые действия для того, чтобы исключить вечное блокирование этого процесса. Обычно это либо прекращение работы ожидающего процесса, либо его извещение о том, что связи больше нет (например, с помощью передачи заранее определенного сигнала).</p><h2 id="нити-исполнения" tabindex="-1">Нити исполнения <a class="header-anchor" href="#нити-исполнения" aria-label="Permalink to &quot;Нити исполнения&quot;">​</a></h2><p>Рассмотренные выше аспекты логической реализации относятся к средствам связи, ориентированным на организацию взаимодействия различных процессов (<strong>IPC</strong>). Однако усилия, направленные на ускорение решения задач в рамках классических операционных систем, привели к появлению совершенно иных механизмов, к изменению самого понятия &quot;процесс&quot;.</p><p>В свое время внедрение идеи мультипрограммирования позволило повысить пропускную способность компьютерных систем, т. е. уменьшить среднее время ожидания результатов работы процессов. Но любой отдельно взятый процесс в мультипрограммной системе никогда не может быть выполнен быстрее, чем при работе в однопрограммном режиме на том же вычислительном комплексе. Тем не менее, если алгоритм решения задачи обладает определенным внутренним параллелизмом, мы могли бы ускорить его работу, организовав взаимодействие нескольких процессов.</p><p>Для того чтобы реализовать нашу идею, введем новую абстракцию внутри понятия &quot;процесс&quot; - <strong>нить исполнения</strong> или просто <strong>нить</strong> (в англоязычной литературе используется термин <strong>thread</strong> (<strong>Поток</strong>)). Нити процесса разделяют его программный код, глобальные переменные и системные ресурсы, но каждая нить имеет собственный программный счетчик, свое содержимое регистров и свой стек. Теперь процесс представляется как совокупность взаимодействующих нитей и выделенных ему ресурсов. Процесс, содержащий всего одну нить исполнения, идентичен процессу в том смысле, который мы употребляли ранее. Для таких процессов мы в дальнейшем будем использовать термин &quot;традиционный процесс&quot;. Иногда нити называют <strong>облегченными процессами</strong> или <strong>мини-процессами</strong>, так как во многих отношениях они подобны традиционным процессом. Нити, как и процессы, могут порождать нити-потомки, правда, только внутри своего процесса, и переходить из одного состояния в другое. Состояния нитей аналогичны состояниям традиционных процессов. Из состояния рождение процесс приходит содержащим всего одну нить исполнения. Другие нити процесса будут являться потомками этой нити-прародительницы.</p><ul><li><p>Мы можем считать, что процесс находится в состоянии готовность, если хотя бы одна из его нитей находится в состоянии готовность и ни одна из нитей не находится в состоянии исполнение.</p></li><li><p>Мы можем считать, что процесс находится в состоянии исполнение, если одна из его нитей находится в состоянии исполнение.</p></li><li><p>Процесс будет находиться в состоянии ожидание, если все его нити находятся в состоянии ожидание.</p></li><li><p>Наконец, процесс находится в состояние закончил исполнение, если все его нити находятся в состоянии закончила исполнение. Пока одна нить процесса заблокирована, другая нить того же процесса может выполняться. Нити разделяют процессор так же, как это делали традиционные процессы, в соответствии с рассмотренными алгоритмами планирования.</p></li></ul><p>Поскольку нити одного процесса разделяют существенно больше ресурсов, чем различные процессы, то операции создания новой нити и переключения контекста между нитями одного процесса занимают значительно меньше времени, чем аналогичные операции для процессов в целом.</p><p>Различают операционные системы, поддерживающие нити на уровне ядра и на уровне библиотек. Все сказанное выше справедливо для операционных систем, поддерживающих нити на уровне ядра. В них планирование использования процессора происходит в терминах нитей, а управление памятью и другими системными ресурсами остается в терминах процессов. В операционных системах, поддерживающих нити на уровне библиотек пользователей, и планирование процессора, и управление системными ресурсами осуществляются в терминах процессов. Распределение использования процессора по нитям в рамках выделенного процессу временного интервала осуществляется средствами библиотеки. В подобных системах блокирование одной нити приводит к блокированию всего процесса, ибо ядро операционной системы не имеет представления о существовании нитей. По сути дела, в таких вычислительных системах просто имитируется наличие нитей исполнения.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Практическая реализация в Linux (POSIX Threads)</p><p>В Linux работа с потоками реализована через стандарт POSIX Threads (pthreads). Для использования необходимо подключить заголовочный файл <code>pthread.h</code> и компилировать программу с флагом <code>-pthread</code>.</p><p><strong>Пример: Параллельное вычисление и вывод</strong></p><p>Следующая программа создает массив чисел в главном потоке, а затем порождает дополнительный поток для вычисления суммы его элементов. Главный поток ожидает завершения вычислений и выводит результат.</p><p><strong>Код программы (<code>simple_thread.c</code>):</strong></p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdlib.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;pthread.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;unistd.h&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // для sleep</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Структура для передачи данных в поток</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">array;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">thread_data_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Функция, которую будет выполнять поток</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> calculate_sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    thread_data_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">thread_data_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) arg;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    data-&gt;sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data-&gt;size; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        data-&gt;sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data-&gt;array[i];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Дочерний поток: сумма вычислена = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, data-&gt;sum);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Задержка 5 секунд</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    pthread_exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Создаем и заполняем массив</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array_size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">numbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> malloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array_size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array_size; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">        numbers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Подготавливаем структуру с данными для потока</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    thread_data_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> thread_data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    thread_data.array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    thread_data.size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array_size;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    pthread_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> thread_id;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Идентификатор потока</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Задержка 5 секунд</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Создаем поток</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pthread_create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">thread_id, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, calculate_sum, (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">thread_data);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        perror</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Ошибка при создании потока&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        free</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(numbers);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Главный поток: ожидание завершения дочернего потока...</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Ожидаем завершения дочернего потока</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pthread_join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(thread_id, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        perror</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Ошибка при join потока&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        free</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(numbers);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Результат уже лежит в thread_data.sum</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Главный поток: общая сумма элементов массива = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, thread_data.sum);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Задержка 5 секунд в главном потоке</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    free</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(numbers);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>Инструкция по компиляции и запуску:</strong></p><ol><li>Сохраните код в файл <code>simple_thread.c</code>.</li><li>Откройте терминал и выполните команду компиляции:</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gcc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> simple_thread</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> simple_thread.c</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -pthread</span></span></code></pre></div><ol start="3"><li>Запустите полученный исполняемый файл в фоновом режиме:</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./simple_thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;</span></span></code></pre></div><ol start="4"><li>Сразу же запустим небольшой мониторинг, будет видно как появился и исчез поток:</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ps</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -T</span></span></code></pre></div><p><strong>Что произойдет при выполнении:</strong></p><ol><li>Главный поток (main) создаст и заполнит массив чисел от 1 до 100.</li><li>Главный поток создаст дочерний поток, передав ему указатель на структуру с данными массива.</li><li>Оба потока начинают выполняться конкурентно. Главный поток доходит до <code>pthread_join</code> и блокируется, ожидая завершения дочернего.</li><li>Дочерний поток вычисляет сумму элементов массива, сохраняет её в переданную структуру и завершается.</li><li>Главный поток продолжает работу, выводит результат, полученный из структуры, и завершает программу.</li></ol><p>Этот пример демонстрирует главный принцип: потоки работают с общими данными (массив <code>numbers</code> и структура <code>thread_data</code>) без необходимости сложных механизмов IPC, что делает их идеальным инструментом для параллелизации задач внутри одного приложения.</p><p><strong>Поддержка нитей в Linux</strong></p><p>В Linux нет принципиального различия между процессом и потоком на уровне ядра. Ядро оперирует концепцией <strong>&quot;задача&quot; (task)</strong>. И процесс, и нить — это просто задачи, которые могут иметь общие или различные атрибуты.</p><ul><li><strong>Процесс</strong> — это задача, которая имеет свое собственное уникальное виртуальное адресное пространство и другие ресурсы (например, таблицу файлов).</li><li><strong>Нить</strong> — это задача, которая <strong>разделяет виртуальное адресное пространство и другие ресурсы</strong> с другой задачей (или задачами).</li></ul><p>Когда вы создаете новый нить с помощью <code>pthread_create()</code>, системный вызов в глубине (<code>clone()</code>) передает ядру специальные флаги (например, <code>CLONE_VM</code>, <code>CLONE_FS</code>, <code>CLONE_FILES</code>), которые указывают: &quot;создай новую задачу, но заставь ее разделить память, информацию о файловой системе и таблицу открытых файлов с родительской задачей&quot;.</p><p>Таким образом, ядро <em>знает</em> о существовании каждого потока и планирует их выполнение независимо друг от друга.</p></div>`,50))])}const E=l(e,[["render",k]]);export{y as __pageData,E as default};
