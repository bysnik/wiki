import{_ as e,c as l,o as i,ag as t}from"./chunks/framework.D4Vqf8I7.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/disciplines/osis/l11.md","filePath":"docs/disciplines/osis/l11.md","lastUpdated":1760455628000}'),r={name:"docs/disciplines/osis/l11.md"};function s(n,o,d,c,a,g){return i(),l("div",null,o[0]||(o[0]=[t('<h3 id="_1-философские-и-исторические-предпосылки-архитектуры" tabindex="-1"><strong>1. Философские и исторические предпосылки архитектуры</strong> <a class="header-anchor" href="#_1-философские-и-исторические-предпосылки-архитектуры" aria-label="Permalink to &quot;**1. Философские и исторические предпосылки архитектуры**&quot;">​</a></h3><p>Архитектура Linux не возникла на пустом месте. Она является прямым наследником идей, заложенных в операционной системе UNIX в 1970-х годах.</p><ul><li><p><strong>Философия UNIX:</strong></p><ul><li><strong>&quot;Все есть файл&quot; (Everything is a file):</strong> Это фундаментальная абстракция, упрощающая взаимодействие с системой. Не только данные на диске, но и устройства (клавиатура, мышь, жесткий диск), процессы, сетевое соединение представлены как файлы, с которыми можно работать через стандартные операции: <code>open</code>, <code>read</code>, <code>write</code>, <code>close</code>.</li><li><strong>Модульность (Modularity):</strong> Система должна состоять из небольших, простых программ (утилит), каждая из которых идеально выполняет одну функцию. Эти программы можно комбинировать через конвейеры (pipes) для решения сложных задач. Эта идея проецируется и на ядро через механизм загружаемых модулей.</li><li><strong>Примитивы (KISS - Keep It Simple, Stupid):</strong> Предоставление простых, но мощных механизмов (примитивов), из которых можно собрать сложное поведение. Например, системные вызовы <code>fork</code>, <code>exec</code>, <code>pipe</code> являются такими примитивами для управления процессами.</li></ul></li><li><p><strong>Влияние проектов GNU и Linux:</strong></p><ul><li><strong>Проект GNU (1984, Ричард Столлман):</strong> Ставил целью создание полностью свободной UNIX-совместимой операционной системы. К началу 1990-х был создан почти весь пользовательский пространственный софт: компилятор GCC, библиотека C (glibc), оболочка Bash, coreutils. Не хватало лишь ядра (Hurd разрабатывалось, но не было готово).</li><li><strong>Ядро Linux (1991, Линус Торвальдс):</strong> Появилось как хобби-проект по созданию минимального работоспособного ядра для персонального компьютера. Оно идеально дополнило проект GNU. Союз ядра Linux и набора утилит GNU дал миру операционную систему GNU/Linux.</li></ul></li><li><p><strong>Монолитное ядро vs. Микроядро:</strong></p><ul><li><strong>Микроядро:</strong> Реализует лишь минимальный набор функций (управление памятью, IPC, базовое планирование), а всё остальное (драйверы, файловые системы, сетевой стек) работает в виде изолированных сервисов в пользовательском пространстве. Плюсы: стабильность (сбой драйвера не падает всё ядро), безопасность. Минусы: высокие накладные расходы на IPC между компонентами, что снижает производительность. Примеры: GNU Hurd, Minix, QNX.</li><li><strong>Монолитное ядро:</strong> Все основные подсистемы (перечисленные выше) выполняются в едином адресном пространстве ядра. Плюсы: высочайшая производительность за счет отсутствия переключений контекста при вызове функций между подсистемами. Минусы: сложность разработки и отладки; сбой в любом драйвере ведет к падению всей системы.</li><li><strong>Компромисс Linux:</strong> Linux — это <em>монолитное ядро</em>, но с поддержкой <em>загружаемых модулей</em>. Это значит, что ядро компилируется как единое целое, но необязательные его части (многие драйверы, файловые системы) могут быть динамически загружены и выгружены в пространство ядра по мере необходимости. Это сочетает производительность монолитного ядра с гибкостью, близкой к микроядерной модели.</li></ul></li></ul><h3 id="_2-обзор-высокоуровневои-архитектуры-взгляд-слоями" tabindex="-1"><strong>2. Обзор высокоуровневой архитектуры: взгляд слоями</strong> <a class="header-anchor" href="#_2-обзор-высокоуровневои-архитектуры-взгляд-слоями" aria-label="Permalink to &quot;**2. Обзор высокоуровневой архитектуры: взгляд слоями**&quot;">​</a></h3><p>Архитектуру GNU/Linux можно представить в виде трех основных слоев:</p><ol><li><p><strong>Аппаратное обеспечение (Hardware):</strong></p><ul><li>Центральный процессор (CPU), оперативная память (RAM), жесткие диски (HDD/SSD), сетевые карты (NIC), устройства ввода-вывода и т.д.</li><li>Ядро напрямую взаимодействует с &quot;железом&quot;, абстрагируя его особенности для верхних уровней.</li></ul></li><li><p><strong>Ядро (Kernel Space):</strong></p><ul><li>Это привилегированная часть ОС, выполняющаяся в отдельном адресном пространстве. Имеет прямой доступ ко всей памяти и аппаратным ресурсам.</li><li>Код ядра загружается в память при старте системы и остается там до выключения.</li><li>Основные функции: <ul><li>Управление процессами и их планирование.</li><li>Управление памятью.</li><li>Предоставление интерфейса к устройствам через драйверы.</li><li>Реализация файловых систем и сетевого стека.</li><li>Обеспечение безопасности и разграничения доступа.</li></ul></li></ul></li><li><p><strong>Пользовательское пространство (User Space):</strong></p><ul><li>Это среда, в которой выполняются все пользовательские приложения (от текстового редактора до веб-сервера).</li><li>Каждое приложение работает в своем собственном <em>виртуальном</em> адресном пространстве, изолированном от других приложений и от ядра.</li><li>Компоненты: <ul><li><strong>Системные библиотеки:</strong> Самая важная — <strong>glibc</strong> (GNU C Library). Она предоставляет реализации стандартных функций (например, <code>printf</code>, <code>malloc</code>), но главное — она содержит <em>обертки</em> для системных вызовов, которые являются точкой входа в ядро.</li><li><strong>Оболочка (Shell):</strong> Интерпретатор команд (bash, zsh), который является основным интерфейсом взаимодействия пользователя с системой.</li><li><strong>Утилиты и приложения:</strong> Все программы, которые пользователь запускает явно.</li></ul></li></ul></li><li><p><strong>Системные вызовы (System Calls):</strong></p><ul><li>Это не слой, а четко определенный <em>интерфейс</em> между User Space и Kernel Space.</li><li>Приложения не могут напрямую обращаться к ресурсам или функциям ядра. Вместо этого они запрашивают услугу у ядра, выполняя системный вызов.</li><li>Процесс: <ol><li>Приложение вызывает функцию из библиотеки (например, <code>glibc</code>).</li><li>Библиотека подготавливает аргументы и инициирует специальную инструкцию процессора (например, <code>syscall</code> или <code>int 0x80</code> на x86), которая вызывает <em>переключение контекста</em> из пользовательского режима в режим ядра.</li><li>Процессор передает управление заранее определенному обработчику в ядре.</li><li>Ядро проверяет корректность запроса и права процесса, выполняет запрошенную операцию.</li><li>Ядро возвращает результат и управление обратно в пользовательское пространство.</li></ol></li><li>Примеры системных вызовов: <code>read</code>, <code>write</code>, <code>open</code>, <code>close</code>, <code>fork</code>, <code>execve</code>, <code>kill</code>.</li></ul></li></ol><p>Эта слоистая архитектура обеспечивает изоляцию, стабильность и безопасность. Сбойное приложение в User Space не может напрямую повредить ядро или другие приложения.</p><h3 id="_3-детальныи-разбор-подсистем-ядра-linux" tabindex="-1"><strong>3. Детальный разбор подсистем ядра Linux</strong> <a class="header-anchor" href="#_3-детальныи-разбор-подсистем-ядра-linux" aria-label="Permalink to &quot;**3. Детальный разбор подсистем ядра Linux**&quot;">​</a></h3><h4 id="_3-1-подсистема-управления-процессами-и-планировщик-process-scheduler" tabindex="-1"><strong>3.1. Подсистема управления процессами и планировщик (Process Scheduler)</strong> <a class="header-anchor" href="#_3-1-подсистема-управления-процессами-и-планировщик-process-scheduler" aria-label="Permalink to &quot;**3.1. Подсистема управления процессами и планировщик (Process Scheduler)**&quot;">​</a></h4><p>Эта подсистема отвечает за создание, уничтожение, управление и планирование выполнения всех процессов и потоков в системе.</p><ul><li><p><strong>Задачи, процессы, потоки:</strong></p><ul><li>В Linux нет фундаментальной разницы между процессом и потоком. Ядро оперирует понятием <strong>&quot;задача&quot; (task)</strong>. Поток — это просто задача, которая разделяет с другими задачами (потоками) свое адресное пространство (память, файловые дескрипторы и т.д.).</li><li><strong>Дескриптор задачи <code>struct task_struct</code>:</strong> Это огромная структура данных в ядре, которая содержит <em>всю</em> информацию о задаче: идентификатор (PID), состояние, приоритет, указатель на адресное пространство, открытые файлы, сигналы, родительский процесс и т.д. Все задачи образуют связный список (и древовидную структуру), что позволяет планировщику эффективно их перебирать.</li></ul></li><li><p><strong>Планировщик (Completely Fair Scheduler - CFS):</strong></p><ul><li><strong>Цель:</strong> Справедливо распределить процессорное время между всеми исполняемыми задачами, минимизируя задержки и обеспечивая высокую пропускную способность.</li><li><strong>Принцип работы:</strong> CFS использует концепцию <em>виртуального времени</em>. Каждой задаче назначается доля процессорного времени (ее &quot;вес&quot;), основанная на ее приоритете (nice value). CFS стремится к идеалу, где каждая задача получила ровно <code>n</code>-ую часть процессорного времени за данный период.</li><li><strong>Очереди выполнения:</strong> CFS использует красно-черное дерево (эффективная структура данных для сортировки) для организации задач, готовых к выполнению. Ключом в дереве является <code>vruntime</code> (виртуальное время, которое задача уже использовала). Задача с наименьшим <code>vruntime</code> (та, которой досталось меньше всего CPU) будет выбрана для выполнения следующей.</li><li><strong>Кванты времени:</strong> CFS не использует фиксированные кванты времени. Задача выполняется, пока ее <code>vruntime</code> не станет больше, чем у следующей задачи в дереве. Это предотвращает инверсию приоритетов.</li></ul></li><li><p><strong>Создание процессов: <code>fork()</code>, <code>exec()</code>, <code>clone()</code>:</strong></p><ul><li><strong><code>fork()</code>:</strong> Системный вызов, создающий <em>почти</em> точную копию текущего процесса. Дочерний процесс получает копии всех ресурсов родителя (памяти, файловых дескрипторов и т.д.).</li><li><strong>Copy-on-Write (CoW):</strong> Ключевая оптимизация. При <code>fork()</code> память родителя и потомка <em>логически</em> разделяется, но помечается как read-only. Физическое копирование страниц памяти происходит только тогда, когда один из процессов пытается изменить данные. Это drastically сокращает накладные расходы на создание процессов.</li><li><strong><code>exec()</code>:</strong> Системный вызов, который <em>заменяет</em> образ текущего процесса новым образом, загружаемым из исполняемого файла. Происходит после <code>fork()</code>: родительский процесс (например, оболочка) делает <code>fork()</code>, а дочерний делает <code>exec()</code>, чтобы запустить новую программу.</li><li><strong><code>clone()</code>:</strong> Более низкоуровневый системный вызов, который позволяет точно контролировать, какие ресурсы родительского процесса будут разделены с потомком. Используется библиотеками (например, <code>pthreads</code>) для создания потоков.</li></ul></li><li><p><strong>Состояния процесса:</strong></p><ul><li><strong>TASK_RUNNING:</strong> Готов к выполнению или выполняется.</li><li><strong>TASK_INTERRUPTIBLE / TASK_UNINTERRUPTIBLE:</strong> Ожидание события (например, данных от устройства). Может быть прервано сигналом / не может.</li><li><strong>TASK_STOPPED:</strong> Процесс остановлен (сигналом SIGSTOP).</li><li><strong>TASK_ZOMBIE:</strong> Процесс завершился, но его родитель еще не забрал его статус завершения (<code>wait()</code>).</li></ul></li><li><p><strong>Контекстные переключения:</strong> Когда планировщик решает переключиться с одной задачи на другую, происходит контекстное переключение. Это включает в себя сохранение состояния регистров процессора и указателя на текущую таблицу страниц старой задачи и загрузку состояния новой задачи. Это дорогая операция, поэтому CFS старается минимизировать их количество.</p></li></ul><h4 id="_3-2-подсистема-управления-памятью-memory-management-mm" tabindex="-1"><strong>3.2. Подсистема управления памятью (Memory Management - MM)</strong> <a class="header-anchor" href="#_3-2-подсистема-управления-памятью-memory-management-mm" aria-label="Permalink to &quot;**3.2. Подсистема управления памятью (Memory Management - MM)**&quot;">​</a></h4><p>MM отвечает за управление виртуальной и физической памятью, обеспечивая изоляцию процессов и эффективное использование RAM.</p><ul><li><p><strong>Менеджер виртуальной памяти:</strong></p><ul><li>Каждый процесс в User Space работает в своем собственном <em>виртуальном адресном пространстве</em>. Ему кажется, что он один владеет всей памятью машины (например, от адреса 0x0 до 0xffff...).</li><li>Ядро и MMU (Memory Management Unit) процессора транслируют эти виртуальные адреса в <em>физические адреса</em> в RAM.</li><li>Это обеспечивает безопасность: процесс не может получить доступ к памяти другого процесса или ядра, так как его виртуальные адреса отображаются на его собственный набор физических страниц.</li></ul></li><li><p><strong>Страничная организация памяти:</strong></p><ul><li>Память делится на фиксированные блоки — <em>страницы</em> (обычно 4 KiB). Физическая память — на <em>фреймы</em> такого же размера.</li><li><strong>Таблицы страниц (Page Tables):</strong> Иерархические структуры данных (многоуровневые), которые хранят mapping виртуальных страниц на физические фреймы. У каждого процесса есть своя собственная таблица страниц.</li><li><strong>TLB (Translation Lookaside Buffer):</strong> Кэш внутри процессора для трансляции адресов. Содержит недавно использованные mapping&#39;и виртуальных адресов в физические. При промахе TLB обращение идет к таблице страниц в RAM, что медленно.</li></ul></li><li><p><strong>Выделение памяти:</strong></p><ul><li><strong>В пользовательском пространстве:</strong> Функция <code>malloc()</code> (из glibc) не всегда запрашивает память у ядра. Сначала она использует заранее выделенный кусок виртуальной памяти процесса — <em>кучу (heap)</em>. Когда куча исчерпана, <code>malloc()</code> вызывает системные вызовы <code>brk()</code> или <code>sbrk()</code>, чтобы расширить кучу, или <code>mmap()</code>, чтобы выделить большие, анонимные регионы памяти.</li><li><strong>В ядре:</strong> Используются быстрые аллокаторы для часто используемых небольших объектов (<code>kmalloc</code> → <strong>slab/slub/slob allocator</strong>). Они предотвращают фрагментацию и кэшируют готовые объекты для быстрого повторного использования.</li></ul></li><li><p><strong>Механизм подкачки (Swapping) и кэширования:</strong></p><ul><li><strong>Page Cache:</strong> Ядро использует незанятую оперативную память для кэширования данных с диска. Когда процесс читает файл, данные помещаются в кэш страниц. При повторном чтении данные берутся из быстрой RAM, а не с медленного диска. Запись также часто буферизуется в кэше и сбрасывается на диск позже (это можно контролировать).</li><li><strong>Swapping:</strong> Когда физической памяти становится мало, подсистема MM вытесняет редко используемые <em>анонимные</em> страницы (не связанные с файлом, например, стек процесса) в специальную область на диске — <em>swap-раздел</em> или <em>swap-файл</em>. Это освобождает RAM. При попытке доступа к вытесненной странице возникает page fault, и ядро загружает ее обратно в RAM, возможно, вытеснив другую страницу.</li></ul></li></ul><h4 id="_3-3-виртуальная-фаиловая-система-virtual-file-system-vfs" tabindex="-1"><strong>3.3. Виртуальная файловая система (Virtual File System - VFS)</strong> <a class="header-anchor" href="#_3-3-виртуальная-фаиловая-система-virtual-file-system-vfs" aria-label="Permalink to &quot;**3.3. Виртуальная файловая система (Virtual File System - VFS)**&quot;">​</a></h4><p>VFS — это прослойка абстракции между системными вызовами, связанными с файлами (<code>open</code>, <code>read</code>, <code>write</code>), и конкретными реализациями файловых систем (ext4, NTFS, NFS).</p><ul><li><p><strong>Абстракции VFS:</strong></p><ul><li><strong>superblock:</strong> Представляет собой смонтированную файловую систему.</li><li><strong>inode (index node):</strong> Уникально идентифицирует файл на диске и содержит его метаданные (права доступа, владелец, размер, временные метки, указатели на блоки данных). <em>Не содержит имени файла.</em></li><li><strong>dentry (directory entry):</strong> Представляет собой элемент каталога. Связывает <em>имя</em> файла с его <em>inode</em>. Кэшируется в RAM для ускорения поиска путей (dentry cache).</li><li><strong>file:</strong> Представляет открытый файл. Содержит информацию о текущей позиции в файле (offset) и права доступа, с которыми он был открыт.</li></ul></li><li><p><strong>Принцип &quot;Все есть файл&quot;:</strong></p><ul><li>VFS позволяет представлять через файловый интерфейс что угодно. Для этого драйвер устройства или другая подсистема должна реализовать стандартный набор операций (<code>file_operations</code>, <code>inode_operations</code>).</li><li>Например, при открытии файла <code>/dev/sda</code> VFS перенаправляет вызов драйверу блочного устройства. При открытии файла в <code>/proc</code> (виртуальная ФС процессов) вызов перенаправляется подсистеме ядра, которая генерирует информацию о процессе на лету.</li></ul></li><li><p><strong>Поддержка конкретных ФС:</strong></p><ul><li>Каждая ФС (ext4, Btrfs, XFS, FAT) предоставляет ядру свою реализацию функций для работы с VFS (например, <code>ext4_read()</code>, <code>ext4_write()</code>).</li><li>Когда процесс вызывает <code>read()</code> для файла на ext4: <ol><li>VFS находит <code>file</code>, <code>dentry</code>, <code>inode</code> для этого файла.</li><li>VFS определяет, что inode принадлежит ФС ext4.</li><li>VFS вызывает конкретную функцию <code>ext4_read()</code>, передавая ей необходимые параметры.</li><li>ext4, в свою очередь, может обращаться к подсистеме блочных устройств для чтения конкретных секторов с диска.</li></ol></li></ul></li></ul><h4 id="_3-4-сетевая-подсистема-networking-stack" tabindex="-1"><strong>3.4. Сетевая подсистема (Networking Stack)</strong> <a class="header-anchor" href="#_3-4-сетевая-подсистема-networking-stack" aria-label="Permalink to &quot;**3.4. Сетевая подсистема (Networking Stack)**&quot;">​</a></h4><p>Сетевой стек Linux реализует многоуровневую модель сетевых протоколов (в основном TCP/IP).</p><ul><li><p><strong>Архитектура:</strong></p><ul><li><strong>Сокеты (Sockets):</strong> Интерфейс между пользовательским пространством и сетевым стеком. Системный вызов <code>socket()</code> создает конечную точку для связи. <code>bind()</code>, <code>listen()</code>, <code>accept()</code>, <code>connect()</code>, <code>send()</code>, <code>recv()</code> работают с сокетами.</li><li><strong>Уровни стека:</strong><ul><li><strong>Уровень приложения (Application Layer):</strong> Реализуется в пользовательском пространстве (например, веб-браузер, sshd).</li><li><strong>Транспортный уровень (Transport Layer):</strong> В ядре (TCP, UDP). Отвечает за надежность, управление потоком.</li><li><strong>Сетевой уровень (Network Layer):</strong> IP (IPv4, IPv6), маршрутизация.</li><li><strong>Канальный уровень (Link Layer):</strong> Ethernet, обработка MAC-адресов.</li><li><strong>Физический уровень (Physical Layer):</strong> Реализуется драйвером сетевой карты (NIC).</li></ul></li></ul></li><li><p><strong><code>sk_buff</code> (socket buffer):</strong></p><ul><li>Это основная структура данных для представления сетевого пакета внутри ядра. Когда пакет прибывает с сетевой карты, драйвер создает <code>sk_buff</code> и заполняет его данными.</li><li><code>sk_buff</code> проходит вверх по стеку: к канальному уровню, сетевому (где проверяется IP-адрес, принимается решение о маршрутизации), транспортному (TCP/UDP).</li><li>При отправке данные из пользовательского пространства копируются в <code>sk_buff</code> и проходят стек вниз, пока не будут переданы драйверу сетевой карты для отправки.</li><li><code>sk_buff</code> эффективно управляет данными пакета, позволяя добавлять и удалять заголовки протоколов без копирования всего пакета.</li></ul></li><li><p><strong>Netfilter:</strong></p><ul><li>Это framework внутри ядра, который позволяет перехватывать и manipulateровать пакеты на различных этапах их прохождения по стеку.</li><li><strong>Место iptables/nftables:</strong> Пользовательские утилиты <code>iptables</code> и <code>nftables</code> всего лишь являются фронтендами для настройки правил в таблицах Netfilter. Эти правила определяют, что делать с пакетом: принять (ACCEPT), отбросить (DROP), перенаправить (NAT).</li></ul></li></ul><h4 id="_3-5-подсистема-ввода-вывода-и-управления-устроиствами" tabindex="-1"><strong>3.5. Подсистема ввода-вывода и управления устройствами</strong> <a class="header-anchor" href="#_3-5-подсистема-ввода-вывода-и-управления-устроиствами" aria-label="Permalink to &quot;**3.5. Подсистема ввода-вывода и управления устройствами**&quot;">​</a></h4><ul><li><p><strong>Абстракция &quot;Устройство-файл&quot;:</strong></p><ul><li>Все устройства представлены файлами в каталоге <code>/dev</code>. Это прямое следствие философии &quot;все есть файл&quot;.</li><li><strong>Блочные устройства:</strong> Устройства с случайным доступом к данным блоками (жесткие диски, SSD). Файлы: <code>/dev/sda1</code>, <code>/dev/nvme0n1p2</code>.</li><li><strong>Символьные устройства:</strong> Устройства с последовательным или потоковым доступом (клавиатура, мышь, принтер, терминал). Файлы: <code>/dev/ttyS0</code> (COM-порт), <code>/dev/input/event0</code>.</li><li><strong>Сетевые устройства:</strong> Не имеют файлов в <code>/dev</code>. Доступ к ним осуществляется исключительно через сетевой стек и сокеты.</li></ul></li><li><p><strong>Драйверы устройств:</strong></p><ul><li>Это модули ядра (или часть монолитного ядра), которые &quot;знают&quot;, как общаться с конкретным hardware.</li><li>Они регистрируются в ядре и предоставляют стандартный набор операций (<code>file_operations</code> для символьных устройств, <code>block_device_operations</code> для блочных).</li><li>Когда пользовательская программа читает из <code>/dev/sda1</code>, VFS определяет, что это блочное устройство, и перенаправляет вызов <code>read</code> соответствующему драйверу, который преобразует его в команды, понятные контроллеру диска.</li></ul></li><li><p><strong>Менеджер устройств (<code>udev</code>):</strong></p><ul><li>Важно понимать, что <code>udev</code> — это <em>пользовательский</em> демон (работает в User Space).</li><li>Его задача — динамически создавать и удалять файлы устройств в <code>/dev</code> в ответ на события от ядра. Например, при подключении флешки ядро обнаруживает новое блочное устройство и отправляет сообщение в User Space через специальную файловую систему <code>sysfs</code> (<code>/sys</code>). <code>udev</code> получает это сообщение, считывает свойства устройства (например, vendor ID, model) и создает соответствующий файл в <code>/dev</code> (например, <code>/dev/sdb1</code>), возможно, применяя заранее заданные правила (создать символьную ссылку <code>/dev/my_usb</code>).</li></ul></li></ul><h3 id="_4-механизмы-взаимодеиствия-подсистем-как-все-работает-вместе" tabindex="-1"><strong>4. Механизмы взаимодействия подсистем: как всё работает вместе</strong> <a class="header-anchor" href="#_4-механизмы-взаимодеиствия-подсистем-как-все-работает-вместе" aria-label="Permalink to &quot;**4. Механизмы взаимодействия подсистем: как всё работает вместе**&quot;">​</a></h3><p>Подсистемы ядра не живут изолированно. Они постоянно взаимодействуют через четко определенные механизмы.</p><ul><li><p><strong>Прерывания (Interrupts):</strong></p><ul><li>Это аппаратный механизм, уведомляющий процессор о том, что устройству требуется внимание (например, пришел сетевой пакет, нажата клавиша, завершена операция дискового ввода-вывода).</li><li>Процессор приостанавливает текущее выполнение, сохраняет контекст и прыгает на заранее заданный <strong>обработчик прерывания (Interrupt Handler - ISR)</strong> в ядре.</li><li>ISR должен быть очень быстрым. Обычно он только acknowledges прерывание, копирует критически важные данные из hardware в память и <strong>планирует отложенную обработку</strong>.</li></ul></li><li><p><strong>Очереди отложенного выполнения:</strong></p><ul><li>Поскольку выполнять всю работу в контексте прерывания нельзя (это блокирует все другие прерывания и задачи), используются три основных механизма: <ul><li><strong>SoftIRQs:</strong> Статические, заранее определенные точки для отложенной обработки с высокими требованиями к производительности (обработка сетевых пакетов, таймеры). Выполняются в контексте ядра с отключенными прерываниями.</li><li><strong>Tasklets:</strong> Основаны на SoftIRQs, но более динамичны и безопасны. Гарантируется, что один и тот же tasklet не будет выполняться одновременно на нескольких процессорах.</li><li><strong>Workqueues:</strong> Выполняют работу в контексте отдельного <em>потока ядра (kernel thread)</em>. Это значит, что они могут &quot;спать&quot; (блокироваться), что недоступно для SoftIRQs и tasklets. Используются для более тяжелой работы, не критичной ко времени.</li></ul></li></ul></li><li><p><strong>Средства межпроцессного взаимодействия (IPC):</strong></p><ul><li><strong>Сигналы (Signals):</strong> Асинхронные уведомления, посылаемые ядром или одним процессом другому (например, <code>SIGKILL</code>, <code>SIGTERM</code>).</li><li><strong>Каналы (Pipes) и именованные каналы (FIFOs):</strong> Односторонние каналы связи. <code>|</code> в shell создает pipe.</li><li><strong>Очереди сообщений (SysV IPC, POSIX MQ):</strong> Позволяют процессам обмениваться структурированными сообщениями.</li><li><strong>Разделяемая память (Shared Memory):</strong> Самый быстрый метод IPC. Несколько процессов отображают один и тот же сегмент физической памяти в свое адресное пространство.</li><li><strong>Сокеты (Sockets):</strong> Могут использоваться для IPC между процессами на одной машине (Unix domain sockets) помимо сетевого обмена.</li></ul></li><li><p><strong>Синхронизация в ядре:</strong></p><ul><li>В многопроцессорных (SMP) системах несколько потоков ядра могут одновременно обращаться к одним и тем же данным, что приводит к race conditions.</li><li><strong>Spinlocks:</strong> Низкоуровневая блокировка. Поток в ядре, пытающийся захватить занятый spinlock, будет крутиться в цикле (&quot;spin&quot;), активно потребляя CPU, пока lock не освободится. Используется для очень кратковременной блокировки.</li><li><strong>Мьютексы (Mutexes):</strong> Если мьютекс занят, поток переходит в состояние ожидания и не потребляет CPU, пока его не разбудят. Подходит для более долгих критических секций.</li><li><strong>Семафоры (Semaphores):</strong> Обобщение мьютексов, позволяющее одновременно доступ N потокам к ресурсу.</li></ul></li></ul><h3 id="_5-пример-сквозного-выполнения-от-нажатия-клавиши-до-вывода-на-экран" tabindex="-1"><strong>5. Пример сквозного выполнения: от нажатия клавиши до вывода на экран</strong> <a class="header-anchor" href="#_5-пример-сквозного-выполнения-от-нажатия-клавиши-до-вывода-на-экран" aria-label="Permalink to &quot;**5. Пример сквозного выполнения: от нажатия клавиши до вывода на экран**&quot;">​</a></h3><p>Рассмотрим, как взаимодействуют подсистемы на примере ввода команды <code>ls</code> в оболочке.</p><ol><li><strong>Аппаратное прерывание:</strong> Пользователь нажимает клавишу &#39;L&#39; на клавиатуре. Контроллер клавиатуры генерирует прерывание (IRQ).</li><li><strong>Обработка прерывания:</strong> Процессор переключается в режим ядра и выполняет ISR драйвера клавиатуры. ISR считывает скан-код клавиши из порта, преобразует его в код символа (например, ASCII &#39;l&#39;) и помещает этот код в буфер ввода в ядре. ISR отмечает, что прерывание обработано, и планирует выполнение tasklet для дальнейшей обработки.</li><li><strong>Пробуждение процесса:</strong> Tasklet, связанный с вводом, выполняется. Он видит, что в буфере появились данные для терминального устройства (<code>/dev/ttyX</code>), к которому привязана оболочка. Он будит процессы, которые ждут чтения с этого терминала. Планировщик помещает спящий процесс оболочки в очередь выполнения.</li><li><strong>Чтение из устройства:</strong> В какой-то момент планировщик передает управление процессу оболочки. Оболочка до этого была заблокирована на системном вызове <code>read()</code> от своего стандартного ввода (терминала). Вызов <code>read()</code> проходит через VFS. VFS определяет, что файловый дескриптор STDIN указывает на символьное устройство (терминал), и вызывает функцию <code>read</code> драйвера терминала (tty). Драйвер копирует данные (&#39;l&#39;) из внутреннего буфера ядра в буфер пользовательского пространства оболочки.</li><li><strong>Обработка ввода оболочкой:</strong> Оболочка получает символ, добавляет его в свою внутреннюю строку, и, получив символ новой строки (Enter), понимает, что команда готова к исполнению.</li><li><strong>Создание процесса <code>ls</code>:</strong> Оболочка вызывает <code>fork()</code>, создавая свою копию (с помощью CoW). Затем дочерний процесс вызывает <code>execve(&quot;/bin/ls&quot;, ...)</code>. Подсистема управления процессами находит исполняемый файл <code>/bin/ls</code>, загружает его код и данные в память (через подсистему управления памятью и VFS, которая читает файл с диска), настраивает стек и регистры и начинает выполнение <code>ls</code>.</li><li><strong>Работа <code>ls</code>:</strong> <code>ls</code> с помощью системного вызова <code>getdents64()</code> (или подобного) читает содержимое текущего каталога. VFS и конкретная файловая система (например, ext4) обрабатывают этот запрос, возвращая список файлов.</li><li><strong>Вывод на экран:</strong> <code>ls</code> выводит список через стандартный вывод (STDOUT), используя системный вызов <code>write()</code>. VFS определяет, что STDOUT — это тоже терминальное устройство, и передает данные драйверу терминала. Драйвер терминала копирует данные (буквы &#39;l&#39;, &#39;s&#39;, &#39;\\n&#39; и т.д.) в свой буфер вывода.</li><li><strong>Драйвер видеокарты:</strong> Драйвер терминала (tty) взаимодействует с драйвером видеокарты (через подсистему framebuffer или более сложные интерфейсы вроде DRM/KMS). Драйвер видеокарты преобразует символы в пиксели и обновляет видеопамять, что приводит к появлению букв на экране.</li><li><strong>Завершение:</strong> Процесс <code>ls</code> завершается. Его родитель (оболочка) получает об этом уведомление через системный вызов <code>wait()</code>, выводит приглашение командной строки и снова блокируется в <code>read()</code>, ожидая следующую команду.</li></ol><p>Этот пример наглядно показывает, как практически все рассмотренные подсистемы участвуют в выполнении даже такой простой задачи.</p><h3 id="_6-заключение" tabindex="-1"><strong>6. Заключение</strong> <a class="header-anchor" href="#_6-заключение" aria-label="Permalink to &quot;**6. Заключение**&quot;">​</a></h3><p>Архитектура GNU/Linux — это блестящий пример эволюции идей, заложенных в UNIX, адаптированных к современным реалиям. Её сила заключается в:</p><ol><li><strong>Четком разделении ответственности:</strong> Каждая подсистема решает свою узкую задачу и делает это хорошо.</li><li><strong>Мощных абстракциях:</strong> VFS, задачи, виртуальная память — эти абстракции скрывают сложность hardware и предоставляют единообразный интерфейс для разработки.</li><li><strong>Эффективности:</strong> Монолитное ядро с модулями обеспечивает высочайшую производительность, сравнимую с микроядерными архитектурами.</li><li><strong>Гибкости:</strong> Модульность позволяет добавлять поддержку нового hardware и файловых систем без перекомпиляции всего ядра.</li></ol><p>Архитектура продолжает развиваться. Появление таких технологий, как:</p><ul><li><strong>cgroups и namespaces</strong> — основа контейнеризации (Docker, LXC), обеспечивающая изоляцию и управление ресурсами.</li><li><strong>eBPF</strong> — позволяет безопасно выполнять пользовательский код в ядре для наблюдения и манипуляции в реальном времени без изменения самого ядра. доказывает, что архитектура Linux не только прочна, но и достаточно гибка, чтобы адаптироваться к новым вызовам и парадигмам вычислений.</li></ul><p>Эта эволюция во многом управляется глобальным сообществом разработчиков, что делает Linux одной из самых динамичных, стабильных и инновационных операционных систем в истории.</p>',35)]))}const m=e(r,[["render",s]]);export{p as __pageData,m as default};
